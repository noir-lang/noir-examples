/*! For license information please see index.js.LICENSE.txt */
var __webpack_modules__ = {
    742: (__unused_webpack_module, exports) => {
        exports.byteLength = byteLength;
        exports.toByteArray = toByteArray;
        exports.fromByteArray = fromByteArray;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i];
            revLookup[code.charCodeAt(i)] = i;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b64) {
            var len = b64.length;
            if (len % 4 > 0) {
                throw new Error("Invalid string. Length must be a multiple of 4");
            }
            var validLen = b64.indexOf("=");
            if (validLen === -1) validLen = len;
            var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
            return [ validLen, placeHoldersLen ];
        }
        function byteLength(b64) {
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function toByteArray(b64) {
            var tmp;
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
            var curByte = 0;
            var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
            var i;
            for (i = 0; i < len; i += 4) {
                tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
                arr[curByte++] = tmp >> 16 & 255;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 2) {
                tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
                arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 1) {
                tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
            }
            return arr;
        }
        function tripletToBase64(num) {
            return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start, end) {
            var tmp;
            var output = [];
            for (var i = start; i < end; i += 3) {
                tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
                output.push(tripletToBase64(tmp));
            }
            return output.join("");
        }
        function fromByteArray(uint8) {
            var tmp;
            var len = uint8.length;
            var extraBytes = len % 3;
            var parts = [];
            var maxChunkLength = 16383;
            for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
            }
            if (extraBytes === 1) {
                tmp = uint8[len - 1];
                parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
            } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + uint8[len - 1];
                parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
            }
            return parts.join("");
        }
    },
    764: (__unused_webpack_module, exports, __webpack_require__) => {
        var __webpack_unused_export__;
        const base64 = __webpack_require__(742);
        const ieee754 = __webpack_require__(645);
        const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
        exports.lW = Buffer;
        __webpack_unused_export__ = SlowBuffer;
        exports.h2 = 50;
        const K_MAX_LENGTH = 2147483647;
        __webpack_unused_export__ = K_MAX_LENGTH;
        Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
        if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
            console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
        }
        function typedArraySupport() {
            try {
                const arr = new Uint8Array(1);
                const proto = {
                    foo: function() {
                        return 42;
                    }
                };
                Object.setPrototypeOf(proto, Uint8Array.prototype);
                Object.setPrototypeOf(arr, proto);
                return arr.foo() === 42;
            } catch (e) {
                return false;
            }
        }
        Object.defineProperty(Buffer.prototype, "parent", {
            enumerable: true,
            get: function() {
                if (!Buffer.isBuffer(this)) return undefined;
                return this.buffer;
            }
        });
        Object.defineProperty(Buffer.prototype, "offset", {
            enumerable: true,
            get: function() {
                if (!Buffer.isBuffer(this)) return undefined;
                return this.byteOffset;
            }
        });
        function createBuffer(length) {
            if (length > K_MAX_LENGTH) {
                throw new RangeError('The value "' + length + '" is invalid for option "size"');
            }
            const buf = new Uint8Array(length);
            Object.setPrototypeOf(buf, Buffer.prototype);
            return buf;
        }
        function Buffer(arg, encodingOrOffset, length) {
            if (typeof arg === "number") {
                if (typeof encodingOrOffset === "string") {
                    throw new TypeError('The "string" argument must be of type string. Received type number');
                }
                return allocUnsafe(arg);
            }
            return from(arg, encodingOrOffset, length);
        }
        Buffer.poolSize = 8192;
        function from(value, encodingOrOffset, length) {
            if (typeof value === "string") {
                return fromString(value, encodingOrOffset);
            }
            if (ArrayBuffer.isView(value)) {
                return fromArrayView(value);
            }
            if (value == null) {
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof value);
            }
            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                return fromArrayBuffer(value, encodingOrOffset, length);
            }
            if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
                return fromArrayBuffer(value, encodingOrOffset, length);
            }
            if (typeof value === "number") {
                throw new TypeError('The "value" argument must not be of type number. Received type number');
            }
            const valueOf = value.valueOf && value.valueOf();
            if (valueOf != null && valueOf !== value) {
                return Buffer.from(valueOf, encodingOrOffset, length);
            }
            const b = fromObject(value);
            if (b) return b;
            if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
            }
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof value);
        }
        Buffer.from = function(value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length);
        };
        Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
        Object.setPrototypeOf(Buffer, Uint8Array);
        function assertSize(size) {
            if (typeof size !== "number") {
                throw new TypeError('"size" argument must be of type number');
            } else if (size < 0) {
                throw new RangeError('The value "' + size + '" is invalid for option "size"');
            }
        }
        function alloc(size, fill, encoding) {
            assertSize(size);
            if (size <= 0) {
                return createBuffer(size);
            }
            if (fill !== undefined) {
                return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
            }
            return createBuffer(size);
        }
        Buffer.alloc = function(size, fill, encoding) {
            return alloc(size, fill, encoding);
        };
        function allocUnsafe(size) {
            assertSize(size);
            return createBuffer(size < 0 ? 0 : checked(size) | 0);
        }
        Buffer.allocUnsafe = function(size) {
            return allocUnsafe(size);
        };
        Buffer.allocUnsafeSlow = function(size) {
            return allocUnsafe(size);
        };
        function fromString(string, encoding) {
            if (typeof encoding !== "string" || encoding === "") {
                encoding = "utf8";
            }
            if (!Buffer.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
            }
            const length = byteLength(string, encoding) | 0;
            let buf = createBuffer(length);
            const actual = buf.write(string, encoding);
            if (actual !== length) {
                buf = buf.slice(0, actual);
            }
            return buf;
        }
        function fromArrayLike(array) {
            const length = array.length < 0 ? 0 : checked(array.length) | 0;
            const buf = createBuffer(length);
            for (let i = 0; i < length; i += 1) {
                buf[i] = array[i] & 255;
            }
            return buf;
        }
        function fromArrayView(arrayView) {
            if (isInstance(arrayView, Uint8Array)) {
                const copy = new Uint8Array(arrayView);
                return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
            }
            return fromArrayLike(arrayView);
        }
        function fromArrayBuffer(array, byteOffset, length) {
            if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('"offset" is outside of buffer bounds');
            }
            if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('"length" is outside of buffer bounds');
            }
            let buf;
            if (byteOffset === undefined && length === undefined) {
                buf = new Uint8Array(array);
            } else if (length === undefined) {
                buf = new Uint8Array(array, byteOffset);
            } else {
                buf = new Uint8Array(array, byteOffset, length);
            }
            Object.setPrototypeOf(buf, Buffer.prototype);
            return buf;
        }
        function fromObject(obj) {
            if (Buffer.isBuffer(obj)) {
                const len = checked(obj.length) | 0;
                const buf = createBuffer(len);
                if (buf.length === 0) {
                    return buf;
                }
                obj.copy(buf, 0, 0, len);
                return buf;
            }
            if (obj.length !== undefined) {
                if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                    return createBuffer(0);
                }
                return fromArrayLike(obj);
            }
            if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                return fromArrayLike(obj.data);
            }
        }
        function checked(length) {
            if (length >= K_MAX_LENGTH) {
                throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
            }
            return length | 0;
        }
        function SlowBuffer(length) {
            if (+length != length) {
                length = 0;
            }
            return Buffer.alloc(+length);
        }
        Buffer.isBuffer = function isBuffer(b) {
            return b != null && b._isBuffer === true && b !== Buffer.prototype;
        };
        Buffer.compare = function compare(a, b) {
            if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
            if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            }
            if (a === b) return 0;
            let x = a.length;
            let y = b.length;
            for (let i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                    x = a[i];
                    y = b[i];
                    break;
                }
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
        };
        Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;

              default:
                return false;
            }
        };
        Buffer.concat = function concat(list, length) {
            if (!Array.isArray(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
            }
            if (list.length === 0) {
                return Buffer.alloc(0);
            }
            let i;
            if (length === undefined) {
                length = 0;
                for (i = 0; i < list.length; ++i) {
                    length += list[i].length;
                }
            }
            const buffer = Buffer.allocUnsafe(length);
            let pos = 0;
            for (i = 0; i < list.length; ++i) {
                let buf = list[i];
                if (isInstance(buf, Uint8Array)) {
                    if (pos + buf.length > buffer.length) {
                        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                        buf.copy(buffer, pos);
                    } else {
                        Uint8Array.prototype.set.call(buffer, buf, pos);
                    }
                } else if (!Buffer.isBuffer(buf)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                } else {
                    buf.copy(buffer, pos);
                }
                pos += buf.length;
            }
            return buffer;
        };
        function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) {
                return string.length;
            }
            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                return string.byteLength;
            }
            if (typeof string !== "string") {
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof string);
            }
            const len = string.length;
            const mustMatch = arguments.length > 2 && arguments[2] === true;
            if (!mustMatch && len === 0) return 0;
            let loweredCase = false;
            for (;;) {
                switch (encoding) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return len;

                  case "utf8":
                  case "utf-8":
                    return utf8ToBytes(string).length;

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return len * 2;

                  case "hex":
                    return len >>> 1;

                  case "base64":
                    return base64ToBytes(string).length;

                  default:
                    if (loweredCase) {
                        return mustMatch ? -1 : utf8ToBytes(string).length;
                    }
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
            }
        }
        Buffer.byteLength = byteLength;
        function slowToString(encoding, start, end) {
            let loweredCase = false;
            if (start === undefined || start < 0) {
                start = 0;
            }
            if (start > this.length) {
                return "";
            }
            if (end === undefined || end > this.length) {
                end = this.length;
            }
            if (end <= 0) {
                return "";
            }
            end >>>= 0;
            start >>>= 0;
            if (end <= start) {
                return "";
            }
            if (!encoding) encoding = "utf8";
            while (true) {
                switch (encoding) {
                  case "hex":
                    return hexSlice(this, start, end);

                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);

                  case "ascii":
                    return asciiSlice(this, start, end);

                  case "latin1":
                  case "binary":
                    return latin1Slice(this, start, end);

                  case "base64":
                    return base64Slice(this, start, end);

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);

                  default:
                    if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase();
                    loweredCase = true;
                }
            }
        }
        Buffer.prototype._isBuffer = true;
        function swap(b, n, m) {
            const i = b[n];
            b[n] = b[m];
            b[m] = i;
        }
        Buffer.prototype.swap16 = function swap16() {
            const len = this.length;
            if (len % 2 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 16-bits");
            }
            for (let i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
            }
            return this;
        };
        Buffer.prototype.swap32 = function swap32() {
            const len = this.length;
            if (len % 4 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 32-bits");
            }
            for (let i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
            }
            return this;
        };
        Buffer.prototype.swap64 = function swap64() {
            const len = this.length;
            if (len % 8 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 64-bits");
            }
            for (let i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
            }
            return this;
        };
        Buffer.prototype.toString = function toString() {
            const length = this.length;
            if (length === 0) return "";
            if (arguments.length === 0) return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
        };
        Buffer.prototype.toLocaleString = Buffer.prototype.toString;
        Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
            if (this === b) return true;
            return Buffer.compare(this, b) === 0;
        };
        Buffer.prototype.inspect = function inspect() {
            let str = "";
            const max = exports.h2;
            str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
            if (this.length > max) str += " ... ";
            return "<Buffer " + str + ">";
        };
        if (customInspectSymbol) {
            Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
        }
        Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
            if (isInstance(target, Uint8Array)) {
                target = Buffer.from(target, target.offset, target.byteLength);
            }
            if (!Buffer.isBuffer(target)) {
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof target);
            }
            if (start === undefined) {
                start = 0;
            }
            if (end === undefined) {
                end = target ? target.length : 0;
            }
            if (thisStart === undefined) {
                thisStart = 0;
            }
            if (thisEnd === undefined) {
                thisEnd = this.length;
            }
            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError("out of range index");
            }
            if (thisStart >= thisEnd && start >= end) {
                return 0;
            }
            if (thisStart >= thisEnd) {
                return -1;
            }
            if (start >= end) {
                return 1;
            }
            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target) return 0;
            let x = thisEnd - thisStart;
            let y = end - start;
            const len = Math.min(x, y);
            const thisCopy = this.slice(thisStart, thisEnd);
            const targetCopy = target.slice(start, end);
            for (let i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                    x = thisCopy[i];
                    y = targetCopy[i];
                    break;
                }
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
        };
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            if (buffer.length === 0) return -1;
            if (typeof byteOffset === "string") {
                encoding = byteOffset;
                byteOffset = 0;
            } else if (byteOffset > 2147483647) {
                byteOffset = 2147483647;
            } else if (byteOffset < -2147483648) {
                byteOffset = -2147483648;
            }
            byteOffset = +byteOffset;
            if (numberIsNaN(byteOffset)) {
                byteOffset = dir ? 0 : buffer.length - 1;
            }
            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) {
                if (dir) return -1; else byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
                if (dir) byteOffset = 0; else return -1;
            }
            if (typeof val === "string") {
                val = Buffer.from(val, encoding);
            }
            if (Buffer.isBuffer(val)) {
                if (val.length === 0) {
                    return -1;
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === "number") {
                val = val & 255;
                if (typeof Uint8Array.prototype.indexOf === "function") {
                    if (dir) {
                        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                    } else {
                        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                    }
                }
                return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);
            }
            throw new TypeError("val must be string, number or Buffer");
        }
        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            let indexSize = 1;
            let arrLength = arr.length;
            let valLength = val.length;
            if (encoding !== undefined) {
                encoding = String(encoding).toLowerCase();
                if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                    if (arr.length < 2 || val.length < 2) {
                        return -1;
                    }
                    indexSize = 2;
                    arrLength /= 2;
                    valLength /= 2;
                    byteOffset /= 2;
                }
            }
            function read(buf, i) {
                if (indexSize === 1) {
                    return buf[i];
                } else {
                    return buf.readUInt16BE(i * indexSize);
                }
            }
            let i;
            if (dir) {
                let foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                    if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                        if (foundIndex === -1) foundIndex = i;
                        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                    } else {
                        if (foundIndex !== -1) i -= i - foundIndex;
                        foundIndex = -1;
                    }
                }
            } else {
                if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                    let found = true;
                    for (let j = 0; j < valLength; j++) {
                        if (read(arr, i + j) !== read(val, j)) {
                            found = false;
                            break;
                        }
                    }
                    if (found) return i;
                }
            }
            return -1;
        }
        Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
        };
        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
        };
        Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
        };
        function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            const remaining = buf.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = Number(length);
                if (length > remaining) {
                    length = remaining;
                }
            }
            const strLen = string.length;
            if (length > strLen / 2) {
                length = strLen / 2;
            }
            let i;
            for (i = 0; i < length; ++i) {
                const parsed = parseInt(string.substr(i * 2, 2), 16);
                if (numberIsNaN(parsed)) return i;
                buf[offset + i] = parsed;
            }
            return i;
        }
        function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
        }
        function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
        }
        function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
        }
        function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
        }
        Buffer.prototype.write = function write(string, offset, length, encoding) {
            if (offset === undefined) {
                encoding = "utf8";
                length = this.length;
                offset = 0;
            } else if (length === undefined && typeof offset === "string") {
                encoding = offset;
                length = this.length;
                offset = 0;
            } else if (isFinite(offset)) {
                offset = offset >>> 0;
                if (isFinite(length)) {
                    length = length >>> 0;
                    if (encoding === undefined) encoding = "utf8";
                } else {
                    encoding = length;
                    length = undefined;
                }
            } else {
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            }
            const remaining = this.length - offset;
            if (length === undefined || length > remaining) length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                throw new RangeError("Attempt to write outside buffer bounds");
            }
            if (!encoding) encoding = "utf8";
            let loweredCase = false;
            for (;;) {
                switch (encoding) {
                  case "hex":
                    return hexWrite(this, string, offset, length);

                  case "utf8":
                  case "utf-8":
                    return utf8Write(this, string, offset, length);

                  case "ascii":
                  case "latin1":
                  case "binary":
                    return asciiWrite(this, string, offset, length);

                  case "base64":
                    return base64Write(this, string, offset, length);

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ucs2Write(this, string, offset, length);

                  default:
                    if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
            }
        };
        Buffer.prototype.toJSON = function toJSON() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            };
        };
        function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
            } else {
                return base64.fromByteArray(buf.slice(start, end));
            }
        }
        function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            const res = [];
            let i = start;
            while (i < end) {
                const firstByte = buf[i];
                let codePoint = null;
                let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                if (i + bytesPerSequence <= end) {
                    let secondByte, thirdByte, fourthByte, tempCodePoint;
                    switch (bytesPerSequence) {
                      case 1:
                        if (firstByte < 128) {
                            codePoint = firstByte;
                        }
                        break;

                      case 2:
                        secondByte = buf[i + 1];
                        if ((secondByte & 192) === 128) {
                            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                            if (tempCodePoint > 127) {
                                codePoint = tempCodePoint;
                            }
                        }
                        break;

                      case 3:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                                codePoint = tempCodePoint;
                            }
                        }
                        break;

                      case 4:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        fourthByte = buf[i + 3];
                        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                                codePoint = tempCodePoint;
                            }
                        }
                    }
                }
                if (codePoint === null) {
                    codePoint = 65533;
                    bytesPerSequence = 1;
                } else if (codePoint > 65535) {
                    codePoint -= 65536;
                    res.push(codePoint >>> 10 & 1023 | 55296);
                    codePoint = 56320 | codePoint & 1023;
                }
                res.push(codePoint);
                i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
        }
        const MAX_ARGUMENTS_LENGTH = 4096;
        function decodeCodePointsArray(codePoints) {
            const len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints);
            }
            let res = "";
            let i = 0;
            while (i < len) {
                res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            }
            return res;
        }
        function asciiSlice(buf, start, end) {
            let ret = "";
            end = Math.min(buf.length, end);
            for (let i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 127);
            }
            return ret;
        }
        function latin1Slice(buf, start, end) {
            let ret = "";
            end = Math.min(buf.length, end);
            for (let i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
            }
            return ret;
        }
        function hexSlice(buf, start, end) {
            const len = buf.length;
            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;
            let out = "";
            for (let i = start; i < end; ++i) {
                out += hexSliceLookupTable[buf[i]];
            }
            return out;
        }
        function utf16leSlice(buf, start, end) {
            const bytes = buf.slice(start, end);
            let res = "";
            for (let i = 0; i < bytes.length - 1; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
        }
        Buffer.prototype.slice = function slice(start, end) {
            const len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;
            if (start < 0) {
                start += len;
                if (start < 0) start = 0;
            } else if (start > len) {
                start = len;
            }
            if (end < 0) {
                end += len;
                if (end < 0) end = 0;
            } else if (end > len) {
                end = len;
            }
            if (end < start) end = start;
            const newBuf = this.subarray(start, end);
            Object.setPrototypeOf(newBuf, Buffer.prototype);
            return newBuf;
        };
        function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
            if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
        }
        Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            let val = this[offset];
            let mul = 1;
            let i = 0;
            while (++i < byteLength && (mul *= 256)) {
                val += this[offset + i] * mul;
            }
            return val;
        };
        Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
                checkOffset(offset, byteLength, this.length);
            }
            let val = this[offset + --byteLength];
            let mul = 1;
            while (byteLength > 0 && (mul *= 256)) {
                val += this[offset + --byteLength] * mul;
            }
            return val;
        };
        Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
        };
        Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
        };
        Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
        };
        Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
        };
        Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        };
        Buffer.prototype.readBigUInt64LE = defineBigIntMethod((function readBigUInt64LE(offset) {
            offset = offset >>> 0;
            validateNumber(offset, "offset");
            const first = this[offset];
            const last = this[offset + 7];
            if (first === undefined || last === undefined) {
                boundsError(offset, this.length - 8);
            }
            const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
            const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
            return BigInt(lo) + (BigInt(hi) << BigInt(32));
        }));
        Buffer.prototype.readBigUInt64BE = defineBigIntMethod((function readBigUInt64BE(offset) {
            offset = offset >>> 0;
            validateNumber(offset, "offset");
            const first = this[offset];
            const last = this[offset + 7];
            if (first === undefined || last === undefined) {
                boundsError(offset, this.length - 8);
            }
            const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
            const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
            return (BigInt(hi) << BigInt(32)) + BigInt(lo);
        }));
        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            let val = this[offset];
            let mul = 1;
            let i = 0;
            while (++i < byteLength && (mul *= 256)) {
                val += this[offset + i] * mul;
            }
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
        };
        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            let i = byteLength;
            let mul = 1;
            let val = this[offset + --i];
            while (i > 0 && (mul *= 256)) {
                val += this[offset + --i] * mul;
            }
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
        };
        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128)) return this[offset];
            return (255 - this[offset] + 1) * -1;
        };
        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            const val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
        };
        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            const val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
        };
        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        };
        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        };
        Buffer.prototype.readBigInt64LE = defineBigIntMethod((function readBigInt64LE(offset) {
            offset = offset >>> 0;
            validateNumber(offset, "offset");
            const first = this[offset];
            const last = this[offset + 7];
            if (first === undefined || last === undefined) {
                boundsError(offset, this.length - 8);
            }
            const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
            return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
        }));
        Buffer.prototype.readBigInt64BE = defineBigIntMethod((function readBigInt64BE(offset) {
            offset = offset >>> 0;
            validateNumber(offset, "offset");
            const first = this[offset];
            const last = this[offset + 7];
            if (first === undefined || last === undefined) {
                boundsError(offset, this.length - 8);
            }
            const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
            return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
        }));
        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
        };
        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
        };
        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
        };
        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
        };
        function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length) throw new RangeError("Index out of range");
        }
        Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
                const maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
            }
            let mul = 1;
            let i = 0;
            this[offset] = value & 255;
            while (++i < byteLength && (mul *= 256)) {
                this[offset + i] = value / mul & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
                const maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
            }
            let i = byteLength - 1;
            let mul = 1;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
                this[offset + i] = value / mul & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
            this[offset] = value & 255;
            return offset + 1;
        };
        Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            return offset + 2;
        };
        Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
            return offset + 2;
        };
        Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 255;
            return offset + 4;
        };
        Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
            return offset + 4;
        };
        function wrtBigUInt64LE(buf, value, offset, min, max) {
            checkIntBI(value, min, max, buf, offset, 7);
            let lo = Number(value & BigInt(4294967295));
            buf[offset++] = lo;
            lo = lo >> 8;
            buf[offset++] = lo;
            lo = lo >> 8;
            buf[offset++] = lo;
            lo = lo >> 8;
            buf[offset++] = lo;
            let hi = Number(value >> BigInt(32) & BigInt(4294967295));
            buf[offset++] = hi;
            hi = hi >> 8;
            buf[offset++] = hi;
            hi = hi >> 8;
            buf[offset++] = hi;
            hi = hi >> 8;
            buf[offset++] = hi;
            return offset;
        }
        function wrtBigUInt64BE(buf, value, offset, min, max) {
            checkIntBI(value, min, max, buf, offset, 7);
            let lo = Number(value & BigInt(4294967295));
            buf[offset + 7] = lo;
            lo = lo >> 8;
            buf[offset + 6] = lo;
            lo = lo >> 8;
            buf[offset + 5] = lo;
            lo = lo >> 8;
            buf[offset + 4] = lo;
            let hi = Number(value >> BigInt(32) & BigInt(4294967295));
            buf[offset + 3] = hi;
            hi = hi >> 8;
            buf[offset + 2] = hi;
            hi = hi >> 8;
            buf[offset + 1] = hi;
            hi = hi >> 8;
            buf[offset] = hi;
            return offset + 8;
        }
        Buffer.prototype.writeBigUInt64LE = defineBigIntMethod((function writeBigUInt64LE(value, offset = 0) {
            return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
        }));
        Buffer.prototype.writeBigUInt64BE = defineBigIntMethod((function writeBigUInt64BE(value, offset = 0) {
            return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
        }));
        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
                const limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            let i = 0;
            let mul = 1;
            let sub = 0;
            this[offset] = value & 255;
            while (++i < byteLength && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                    sub = 1;
                }
                this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
                const limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            let i = byteLength - 1;
            let mul = 1;
            let sub = 0;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                    sub = 1;
                }
                this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
            if (value < 0) value = 255 + value + 1;
            this[offset] = value & 255;
            return offset + 1;
        };
        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            return offset + 2;
        };
        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
            return offset + 2;
        };
        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
            return offset + 4;
        };
        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0) value = 4294967295 + value + 1;
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
            return offset + 4;
        };
        Buffer.prototype.writeBigInt64LE = defineBigIntMethod((function writeBigInt64LE(value, offset = 0) {
            return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }));
        Buffer.prototype.writeBigInt64BE = defineBigIntMethod((function writeBigInt64BE(value, offset = 0) {
            return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }));
        function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError("Index out of range");
            if (offset < 0) throw new RangeError("Index out of range");
        }
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
        }
        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
        };
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
        }
        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
        };
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (targetStart >= target.length) targetStart = target.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start;
            if (end === start) return 0;
            if (target.length === 0 || this.length === 0) return 0;
            if (targetStart < 0) {
                throw new RangeError("targetStart out of bounds");
            }
            if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
            if (end < 0) throw new RangeError("sourceEnd out of bounds");
            if (end > this.length) end = this.length;
            if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
            }
            const len = end - start;
            if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                this.copyWithin(targetStart, start, end);
            } else {
                Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
            }
            return len;
        };
        Buffer.prototype.fill = function fill(val, start, end, encoding) {
            if (typeof val === "string") {
                if (typeof start === "string") {
                    encoding = start;
                    start = 0;
                    end = this.length;
                } else if (typeof end === "string") {
                    encoding = end;
                    end = this.length;
                }
                if (encoding !== undefined && typeof encoding !== "string") {
                    throw new TypeError("encoding must be a string");
                }
                if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                    throw new TypeError("Unknown encoding: " + encoding);
                }
                if (val.length === 1) {
                    const code = val.charCodeAt(0);
                    if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                        val = code;
                    }
                }
            } else if (typeof val === "number") {
                val = val & 255;
            } else if (typeof val === "boolean") {
                val = Number(val);
            }
            if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError("Out of range index");
            }
            if (end <= start) {
                return this;
            }
            start = start >>> 0;
            end = end === undefined ? this.length : end >>> 0;
            if (!val) val = 0;
            let i;
            if (typeof val === "number") {
                for (i = start; i < end; ++i) {
                    this[i] = val;
                }
            } else {
                const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
                const len = bytes.length;
                if (len === 0) {
                    throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                }
                for (i = 0; i < end - start; ++i) {
                    this[i + start] = bytes[i % len];
                }
            }
            return this;
        };
        const errors = {};
        function E(sym, getMessage, Base) {
            errors[sym] = class NodeError extends Base {
                constructor() {
                    super();
                    Object.defineProperty(this, "message", {
                        value: getMessage.apply(this, arguments),
                        writable: true,
                        configurable: true
                    });
                    this.name = `${this.name} [${sym}]`;
                    this.stack;
                    delete this.name;
                }
                get code() {
                    return sym;
                }
                set code(value) {
                    Object.defineProperty(this, "code", {
                        configurable: true,
                        enumerable: true,
                        value,
                        writable: true
                    });
                }
                toString() {
                    return `${this.name} [${sym}]: ${this.message}`;
                }
            };
        }
        E("ERR_BUFFER_OUT_OF_BOUNDS", (function(name) {
            if (name) {
                return `${name} is outside of buffer bounds`;
            }
            return "Attempt to access memory outside buffer bounds";
        }), RangeError);
        E("ERR_INVALID_ARG_TYPE", (function(name, actual) {
            return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        }), TypeError);
        E("ERR_OUT_OF_RANGE", (function(str, range, input) {
            let msg = `The value of "${str}" is out of range.`;
            let received = input;
            if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
                received = addNumericalSeparator(String(input));
            } else if (typeof input === "bigint") {
                received = String(input);
                if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
                    received = addNumericalSeparator(received);
                }
                received += "n";
            }
            msg += ` It must be ${range}. Received ${received}`;
            return msg;
        }), RangeError);
        function addNumericalSeparator(val) {
            let res = "";
            let i = val.length;
            const start = val[0] === "-" ? 1 : 0;
            for (;i >= start + 4; i -= 3) {
                res = `_${val.slice(i - 3, i)}${res}`;
            }
            return `${val.slice(0, i)}${res}`;
        }
        function checkBounds(buf, offset, byteLength) {
            validateNumber(offset, "offset");
            if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
                boundsError(offset, buf.length - (byteLength + 1));
            }
        }
        function checkIntBI(value, min, max, buf, offset, byteLength) {
            if (value > max || value < min) {
                const n = typeof min === "bigint" ? "n" : "";
                let range;
                if (byteLength > 3) {
                    if (min === 0 || min === BigInt(0)) {
                        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
                    } else {
                        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
                    }
                } else {
                    range = `>= ${min}${n} and <= ${max}${n}`;
                }
                throw new errors.ERR_OUT_OF_RANGE("value", range, value);
            }
            checkBounds(buf, offset, byteLength);
        }
        function validateNumber(value, name) {
            if (typeof value !== "number") {
                throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
            }
        }
        function boundsError(value, length, type) {
            if (Math.floor(value) !== value) {
                validateNumber(value, type);
                throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
            }
            if (length < 0) {
                throw new errors.ERR_BUFFER_OUT_OF_BOUNDS;
            }
            throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
        }
        const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
        function base64clean(str) {
            str = str.split("=")[0];
            str = str.trim().replace(INVALID_BASE64_RE, "");
            if (str.length < 2) return "";
            while (str.length % 4 !== 0) {
                str = str + "=";
            }
            return str;
        }
        function utf8ToBytes(string, units) {
            units = units || Infinity;
            let codePoint;
            const length = string.length;
            let leadSurrogate = null;
            const bytes = [];
            for (let i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);
                if (codePoint > 55295 && codePoint < 57344) {
                    if (!leadSurrogate) {
                        if (codePoint > 56319) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            continue;
                        } else if (i + 1 === length) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            continue;
                        }
                        leadSurrogate = codePoint;
                        continue;
                    }
                    if (codePoint < 56320) {
                        if ((units -= 3) > -1) bytes.push(239, 191, 189);
                        leadSurrogate = codePoint;
                        continue;
                    }
                    codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                } else if (leadSurrogate) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                }
                leadSurrogate = null;
                if (codePoint < 128) {
                    if ((units -= 1) < 0) break;
                    bytes.push(codePoint);
                } else if (codePoint < 2048) {
                    if ((units -= 2) < 0) break;
                    bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
                } else if (codePoint < 65536) {
                    if ((units -= 3) < 0) break;
                    bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                } else if (codePoint < 1114112) {
                    if ((units -= 4) < 0) break;
                    bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                } else {
                    throw new Error("Invalid code point");
                }
            }
            return bytes;
        }
        function asciiToBytes(str) {
            const byteArray = [];
            for (let i = 0; i < str.length; ++i) {
                byteArray.push(str.charCodeAt(i) & 255);
            }
            return byteArray;
        }
        function utf16leToBytes(str, units) {
            let c, hi, lo;
            const byteArray = [];
            for (let i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0) break;
                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
            }
            return byteArray;
        }
        function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
        }
        function blitBuffer(src, dst, offset, length) {
            let i;
            for (i = 0; i < length; ++i) {
                if (i + offset >= dst.length || i >= src.length) break;
                dst[i + offset] = src[i];
            }
            return i;
        }
        function isInstance(obj, type) {
            return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
        }
        function numberIsNaN(obj) {
            return obj !== obj;
        }
        const hexSliceLookupTable = function() {
            const alphabet = "0123456789abcdef";
            const table = new Array(256);
            for (let i = 0; i < 16; ++i) {
                const i16 = i * 16;
                for (let j = 0; j < 16; ++j) {
                    table[i16 + j] = alphabet[i] + alphabet[j];
                }
            }
            return table;
        }();
        function defineBigIntMethod(fn) {
            return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
        }
        function BufferBigIntNotDefined() {
            throw new Error("BigInt not supported");
        }
    },
    227: (module, exports, __webpack_require__) => {
        exports.formatArgs = formatArgs;
        exports.save = save;
        exports.load = load;
        exports.useColors = useColors;
        exports.storage = localstorage();
        exports.destroy = (() => {
            let warned = false;
            return () => {
                if (!warned) {
                    warned = true;
                    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
                }
            };
        })();
        exports.colors = [ "#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33" ];
        function useColors() {
            if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
                return true;
            }
            if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
                return false;
            }
            return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        function formatArgs(args) {
            args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
            if (!this.useColors) {
                return;
            }
            const c = "color: " + this.color;
            args.splice(1, 0, c, "color: inherit");
            let index = 0;
            let lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, (match => {
                if (match === "%%") {
                    return;
                }
                index++;
                if (match === "%c") {
                    lastC = index;
                }
            }));
            args.splice(lastC, 0, c);
        }
        exports.log = console.debug || console.log || (() => {});
        function save(namespaces) {
            try {
                if (namespaces) {
                    exports.storage.setItem("debug", namespaces);
                } else {
                    exports.storage.removeItem("debug");
                }
            } catch (error) {}
        }
        function load() {
            let r;
            try {
                r = exports.storage.getItem("debug");
            } catch (error) {}
            if (!r && typeof process !== "undefined" && "env" in process) {
                r = process.env.DEBUG;
            }
            return r;
        }
        function localstorage() {
            try {
                return localStorage;
            } catch (error) {}
        }
        module.exports = __webpack_require__(447)(exports);
        const {formatters} = module.exports;
        formatters.j = function(v) {
            try {
                return JSON.stringify(v);
            } catch (error) {
                return "[UnexpectedJSONParseError]: " + error.message;
            }
        };
    },
    447: (module, __unused_webpack_exports, __webpack_require__) => {
        function setup(env) {
            createDebug.debug = createDebug;
            createDebug.default = createDebug;
            createDebug.coerce = coerce;
            createDebug.disable = disable;
            createDebug.enable = enable;
            createDebug.enabled = enabled;
            createDebug.humanize = __webpack_require__(824);
            createDebug.destroy = destroy;
            Object.keys(env).forEach((key => {
                createDebug[key] = env[key];
            }));
            createDebug.names = [];
            createDebug.skips = [];
            createDebug.formatters = {};
            function selectColor(namespace) {
                let hash = 0;
                for (let i = 0; i < namespace.length; i++) {
                    hash = (hash << 5) - hash + namespace.charCodeAt(i);
                    hash |= 0;
                }
                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
            }
            createDebug.selectColor = selectColor;
            function createDebug(namespace) {
                let prevTime;
                let enableOverride = null;
                let namespacesCache;
                let enabledCache;
                function debug(...args) {
                    if (!debug.enabled) {
                        return;
                    }
                    const self = debug;
                    const curr = Number(new Date);
                    const ms = curr - (prevTime || curr);
                    self.diff = ms;
                    self.prev = prevTime;
                    self.curr = curr;
                    prevTime = curr;
                    args[0] = createDebug.coerce(args[0]);
                    if (typeof args[0] !== "string") {
                        args.unshift("%O");
                    }
                    let index = 0;
                    args[0] = args[0].replace(/%([a-zA-Z%])/g, ((match, format) => {
                        if (match === "%%") {
                            return "%";
                        }
                        index++;
                        const formatter = createDebug.formatters[format];
                        if (typeof formatter === "function") {
                            const val = args[index];
                            match = formatter.call(self, val);
                            args.splice(index, 1);
                            index--;
                        }
                        return match;
                    }));
                    createDebug.formatArgs.call(self, args);
                    const logFn = self.log || createDebug.log;
                    logFn.apply(self, args);
                }
                debug.namespace = namespace;
                debug.useColors = createDebug.useColors();
                debug.color = createDebug.selectColor(namespace);
                debug.extend = extend;
                debug.destroy = createDebug.destroy;
                Object.defineProperty(debug, "enabled", {
                    enumerable: true,
                    configurable: false,
                    get: () => {
                        if (enableOverride !== null) {
                            return enableOverride;
                        }
                        if (namespacesCache !== createDebug.namespaces) {
                            namespacesCache = createDebug.namespaces;
                            enabledCache = createDebug.enabled(namespace);
                        }
                        return enabledCache;
                    },
                    set: v => {
                        enableOverride = v;
                    }
                });
                if (typeof createDebug.init === "function") {
                    createDebug.init(debug);
                }
                return debug;
            }
            function extend(namespace, delimiter) {
                const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
                newDebug.log = this.log;
                return newDebug;
            }
            function enable(namespaces) {
                createDebug.save(namespaces);
                createDebug.namespaces = namespaces;
                createDebug.names = [];
                createDebug.skips = [];
                let i;
                const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
                const len = split.length;
                for (i = 0; i < len; i++) {
                    if (!split[i]) {
                        continue;
                    }
                    namespaces = split[i].replace(/\*/g, ".*?");
                    if (namespaces[0] === "-") {
                        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
                    } else {
                        createDebug.names.push(new RegExp("^" + namespaces + "$"));
                    }
                }
            }
            function disable() {
                const namespaces = [ ...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace => "-" + namespace)) ].join(",");
                createDebug.enable("");
                return namespaces;
            }
            function enabled(name) {
                if (name[name.length - 1] === "*") {
                    return true;
                }
                let i;
                let len;
                for (i = 0, len = createDebug.skips.length; i < len; i++) {
                    if (createDebug.skips[i].test(name)) {
                        return false;
                    }
                }
                for (i = 0, len = createDebug.names.length; i < len; i++) {
                    if (createDebug.names[i].test(name)) {
                        return true;
                    }
                }
                return false;
            }
            function toNamespace(regexp) {
                return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
            }
            function coerce(val) {
                if (val instanceof Error) {
                    return val.stack || val.message;
                }
                return val;
            }
            function destroy() {
                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
            createDebug.enable(createDebug.load());
            return createDebug;
        }
        module.exports = setup;
    },
    645: (__unused_webpack_module, exports) => {
        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e, m;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i = isLE ? nBytes - 1 : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset + i];
            i += d;
            e = s & (1 << -nBits) - 1;
            s >>= -nBits;
            nBits += eLen;
            for (;nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
            m = e & (1 << -nBits) - 1;
            e >>= -nBits;
            nBits += mLen;
            for (;nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
            if (e === 0) {
                e = 1 - eBias;
            } else if (e === eMax) {
                return m ? NaN : (s ? -1 : 1) * Infinity;
            } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            var i = isLE ? 0 : nBytes - 1;
            var d = isLE ? 1 : -1;
            var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
            value = Math.abs(value);
            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
            } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--;
                    c *= 2;
                }
                if (e + eBias >= 1) {
                    value += rt / c;
                } else {
                    value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                    e++;
                    c /= 2;
                }
                if (e + eBias >= eMax) {
                    m = 0;
                    e = eMax;
                } else if (e + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen);
                    e = e + eBias;
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                    e = 0;
                }
            }
            for (;mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {}
            e = e << mLen | m;
            eLen += mLen;
            for (;eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {}
            buffer[offset + i - d] |= s * 128;
        };
    },
    824: module => {
        var s = 1e3;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        module.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if (type === "string" && val.length > 0) {
                return parse(val);
            } else if (type === "number" && isFinite(val)) {
                return options.long ? fmtLong(val) : fmtShort(val);
            }
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
        };
        function parse(str) {
            str = String(str);
            if (str.length > 100) {
                return;
            }
            var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
            if (!match) {
                return;
            }
            var n = parseFloat(match[1]);
            var type = (match[2] || "ms").toLowerCase();
            switch (type) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return n * y;

              case "weeks":
              case "week":
              case "w":
                return n * w;

              case "days":
              case "day":
              case "d":
                return n * d;

              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return n * h;

              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return n * m;

              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return n * s;

              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return n;

              default:
                return undefined;
            }
        }
        function fmtShort(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
                return Math.round(ms / d) + "d";
            }
            if (msAbs >= h) {
                return Math.round(ms / h) + "h";
            }
            if (msAbs >= m) {
                return Math.round(ms / m) + "m";
            }
            if (msAbs >= s) {
                return Math.round(ms / s) + "s";
            }
            return ms + "ms";
        }
        function fmtLong(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
                return plural(ms, msAbs, d, "day");
            }
            if (msAbs >= h) {
                return plural(ms, msAbs, h, "hour");
            }
            if (msAbs >= m) {
                return plural(ms, msAbs, m, "minute");
            }
            if (msAbs >= s) {
                return plural(ms, msAbs, s, "second");
            }
            return ms + " ms";
        }
        function plural(ms, msAbs, n, name) {
            var isPlural = msAbs >= n * 1.5;
            return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
        }
    },
    477: module => {
        module.exports = function(content, workerConstructor, workerOptions, url) {
            var globalScope = self || window;
            try {
                try {
                    var blob;
                    try {
                        blob = new globalScope.Blob([ content ]);
                    } catch (e) {
                        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;
                        blob = new BlobBuilder;
                        blob.append(content);
                        blob = blob.getBlob();
                    }
                    var URL = globalScope.URL || globalScope.webkitURL;
                    var objectURL = URL.createObjectURL(blob);
                    var worker = new globalScope[workerConstructor](objectURL, workerOptions);
                    URL.revokeObjectURL(objectURL);
                    return worker;
                } catch (e) {
                    return new globalScope[workerConstructor]("data:application/javascript,".concat(encodeURIComponent(content)), workerOptions);
                }
            } catch (e) {
                if (!url) {
                    throw Error("Inline worker is not supported");
                }
                return new globalScope[workerConstructor](url, workerOptions);
            }
        };
    }
};

var __webpack_module_cache__ = {};

function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
        return cachedModule.exports;
    }
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    return module.exports;
}

__webpack_require__.m = __webpack_modules__;

(() => {
    __webpack_require__.n = module => {
        var getter = module && module.__esModule ? () => module["default"] : () => module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();

(() => {
    var getProto = Object.getPrototypeOf ? obj => Object.getPrototypeOf(obj) : obj => obj.__proto__;
    var leafPrototypes;
    __webpack_require__.t = function(value, mode) {
        if (mode & 1) value = this(value);
        if (mode & 8) return value;
        if (typeof value === "object" && value) {
            if (mode & 4 && value.__esModule) return value;
            if (mode & 16 && typeof value.then === "function") return value;
        }
        var ns = Object.create(null);
        __webpack_require__.r(ns);
        var def = {};
        leafPrototypes = leafPrototypes || [ null, getProto({}), getProto([]), getProto(getProto) ];
        for (var current = mode & 2 && value; typeof current == "object" && !~leafPrototypes.indexOf(current); current = getProto(current)) {
            Object.getOwnPropertyNames(current).forEach((key => def[key] = () => value[key]));
        }
        def["default"] = () => value;
        __webpack_require__.d(ns, def);
        return ns;
    };
})();

(() => {
    __webpack_require__.d = (exports, definition) => {
        for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                Object.defineProperty(exports, key, {
                    enumerable: true,
                    get: definition[key]
                });
            }
        }
    };
})();

(() => {
    __webpack_require__.f = {};
    __webpack_require__.e = chunkId => Promise.all(Object.keys(__webpack_require__.f).reduce(((promises, key) => {
        __webpack_require__.f[key](chunkId, promises);
        return promises;
    }), []));
})();

(() => {
    __webpack_require__.u = chunkId => "" + chunkId + "." + "6386c00ebfb22619e11b" + ".js";
})();

(() => {
    __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
})();

(() => {
    var inProgress = {};
    var dataWebpackPrefix = "@aztec/bb.js:";
    __webpack_require__.l = (url, done, key, chunkId) => {
        if (inProgress[url]) {
            inProgress[url].push(done);
            return;
        }
        var script, needAttach;
        if (key !== undefined) {
            var scripts = document.getElementsByTagName("script");
            for (var i = 0; i < scripts.length; i++) {
                var s = scripts[i];
                if (s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) {
                    script = s;
                    break;
                }
            }
        }
        if (!script) {
            needAttach = true;
            script = document.createElement("script");
            script.type = "module";
            script.charset = "utf-8";
            script.timeout = 120;
            if (__webpack_require__.nc) {
                script.setAttribute("nonce", __webpack_require__.nc);
            }
            script.setAttribute("data-webpack", dataWebpackPrefix + key);
            script.src = url;
        }
        inProgress[url] = [ done ];
        var onScriptComplete = (prev, event) => {
            script.onerror = script.onload = null;
            clearTimeout(timeout);
            var doneFns = inProgress[url];
            delete inProgress[url];
            script.parentNode && script.parentNode.removeChild(script);
            doneFns && doneFns.forEach((fn => fn(event)));
            if (prev) return prev(event);
        };
        var timeout = setTimeout(onScriptComplete.bind(null, undefined, {
            type: "timeout",
            target: script
        }), 12e4);
        script.onerror = onScriptComplete.bind(null, script.onerror);
        script.onload = onScriptComplete.bind(null, script.onload);
        needAttach && document.head.appendChild(script);
    };
})();

(() => {
    __webpack_require__.r = exports => {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports, Symbol.toStringTag, {
                value: "Module"
            });
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
    };
})();

(() => {
    var scriptUrl;
    if (typeof import.meta.url === "string") scriptUrl = import.meta.url;
    if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
    scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
    __webpack_require__.p = scriptUrl;
})();

(() => {
    var installedChunks = {
        826: 0
    };
    __webpack_require__.f.j = (chunkId, promises) => {
        var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
        if (installedChunkData !== 0) {
            if (installedChunkData) {
                promises.push(installedChunkData[2]);
            } else {
                if (true) {
                    var promise = new Promise(((resolve, reject) => installedChunkData = installedChunks[chunkId] = [ resolve, reject ]));
                    promises.push(installedChunkData[2] = promise);
                    var url = __webpack_require__.p + __webpack_require__.u(chunkId);
                    var error = new Error;
                    var loadingEnded = event => {
                        if (__webpack_require__.o(installedChunks, chunkId)) {
                            installedChunkData = installedChunks[chunkId];
                            if (installedChunkData !== 0) installedChunks[chunkId] = undefined;
                            if (installedChunkData) {
                                var errorType = event && (event.type === "load" ? "missing" : event.type);
                                var realSrc = event && event.target && event.target.src;
                                error.message = "Loading chunk " + chunkId + " failed.\n(" + errorType + ": " + realSrc + ")";
                                error.name = "ChunkLoadError";
                                error.type = errorType;
                                error.request = realSrc;
                                installedChunkData[1](error);
                            }
                        }
                    };
                    __webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
                }
            }
        }
    };
    var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
        var [chunkIds, moreModules, runtime] = data;
        var moduleId, chunkId, i = 0;
        if (chunkIds.some((id => installedChunks[id] !== 0))) {
            for (moduleId in moreModules) {
                if (__webpack_require__.o(moreModules, moduleId)) {
                    __webpack_require__.m[moduleId] = moreModules[moduleId];
                }
            }
            if (runtime) var result = runtime(__webpack_require__);
        }
        if (parentChunkLoadingFunction) parentChunkLoadingFunction(data);
        for (;i < chunkIds.length; i++) {
            chunkId = chunkIds[i];
            if (__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
                installedChunks[chunkId][0]();
            }
            installedChunks[chunkId] = 0;
        }
    };
    var chunkLoadingGlobal = globalThis["webpackChunk_aztec_bb_js"] = globalThis["webpackChunk_aztec_bb_js"] || [];
    chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
    chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
})();

var __webpack_exports__ = {};

(() => {
    __webpack_require__.d(__webpack_exports__, {
        Dv: () => AztecClientBackend,
        Zh: () => Barretenberg,
        AL: () => BarretenbergSync,
        tD: () => BarretenbergVerifier,
        i2: () => CachedNetCrs,
        Fr: () => Fr,
        pS: () => CachedNetGrumpkinCrs,
        ld: () => RawBuffer,
        yh: () => UltraHonkBackend,
        _7: () => UltraPlonkBackend,
        H2: () => reconstructHonkProof,
        ly: () => splitHonkProof
    });
    function* backoffGenerator() {
        const v = [ 1, 1, 1, 2, 4, 8, 16, 32, 64 ];
        let i = 0;
        while (true) {
            yield v[Math.min(i++, v.length - 1)];
        }
    }
    function* makeBackoff(retries) {
        for (const retry of retries) {
            yield retry;
        }
    }
    async function retry(fn, backoff = backoffGenerator()) {
        while (true) {
            try {
                return await fn();
            } catch (err) {
                const s = backoff.next().value;
                if (s === undefined) {
                    throw err;
                }
                await new Promise((resolve => setTimeout(resolve, s * 1e3)));
                continue;
            }
        }
    }
    class NetCrs {
        constructor(numPoints) {
            this.numPoints = numPoints;
        }
        async init() {
            await this.downloadG1Data();
            await this.downloadG2Data();
        }
        async streamG1Data() {
            const response = await this.fetchG1Data();
            return response.body;
        }
        async streamG2Data() {
            const response = await this.fetchG2Data();
            return response.body;
        }
        async downloadG1Data() {
            const response = await this.fetchG1Data();
            return this.data = new Uint8Array(await response.arrayBuffer());
        }
        async downloadG2Data() {
            const response2 = await this.fetchG2Data();
            return this.g2Data = new Uint8Array(await response2.arrayBuffer());
        }
        getG1Data() {
            return this.data;
        }
        getG2Data() {
            return this.g2Data;
        }
        async fetchG1Data() {
            if (this.numPoints === 0) {
                return new Response(new Uint8Array([]));
            }
            const g1End = this.numPoints * 64 - 1;
            return await retry((() => fetch("https://aztec-ignition.s3.amazonaws.com/MAIN%20IGNITION/flat/g1.dat", {
                headers: {
                    Range: `bytes=0-${g1End}`
                },
                cache: "force-cache"
            })), makeBackoff([ 5, 5, 5 ]));
        }
        async fetchG2Data() {
            return await retry((() => fetch("https://aztec-ignition.s3.amazonaws.com/MAIN%20IGNITION/flat/g2.dat", {
                cache: "force-cache"
            })), makeBackoff([ 5, 5, 5 ]));
        }
    }
    class NetGrumpkinCrs {
        constructor(numPoints) {
            this.numPoints = numPoints;
        }
        async init() {
            await this.downloadG1Data();
        }
        async downloadG1Data() {
            const response = await this.fetchG1Data();
            return this.data = new Uint8Array(await response.arrayBuffer());
        }
        async streamG1Data() {
            const response = await this.fetchG1Data();
            return response.body;
        }
        getG1Data() {
            return this.data;
        }
        async fetchG1Data() {
            if (this.numPoints === 0) {
                return new Response(new Uint8Array([]));
            }
            const g1Start = 28;
            const g1End = g1Start + (this.numPoints * 64 - 1);
            return await fetch("https://aztec-ignition.s3.amazonaws.com/TEST%20GRUMPKIN/monomial/transcript00.dat", {
                headers: {
                    Range: `bytes=${g1Start}-${g1End}`
                },
                cache: "force-cache"
            });
        }
    }
    function promisifyRequest(request) {
        return new Promise(((resolve, reject) => {
            request.oncomplete = request.onsuccess = () => resolve(request.result);
            request.onabort = request.onerror = () => reject(request.error);
        }));
    }
    function createStore(dbName, storeName) {
        const request = indexedDB.open(dbName);
        request.onupgradeneeded = () => request.result.createObjectStore(storeName);
        const dbp = promisifyRequest(request);
        return (txMode, callback) => dbp.then((db => callback(db.transaction(storeName, txMode).objectStore(storeName))));
    }
    let defaultGetStoreFunc;
    function defaultGetStore() {
        if (!defaultGetStoreFunc) {
            defaultGetStoreFunc = createStore("keyval-store", "keyval");
        }
        return defaultGetStoreFunc;
    }
    function get(key, customStore = defaultGetStore()) {
        return customStore("readonly", (store => promisifyRequest(store.get(key))));
    }
    function set(key, value, customStore = defaultGetStore()) {
        return customStore("readwrite", (store => {
            store.put(value, key);
            return promisifyRequest(store.transaction);
        }));
    }
    function setMany(entries, customStore = defaultGetStore()) {
        return customStore("readwrite", (store => {
            entries.forEach((entry => store.put(entry[1], entry[0])));
            return promisifyRequest(store.transaction);
        }));
    }
    function getMany(keys, customStore = defaultGetStore()) {
        return customStore("readonly", (store => Promise.all(keys.map((key => promisifyRequest(store.get(key)))))));
    }
    function update(key, updater, customStore = defaultGetStore()) {
        return customStore("readwrite", (store => new Promise(((resolve, reject) => {
            store.get(key).onsuccess = function() {
                try {
                    store.put(updater(this.result), key);
                    resolve(promisifyRequest(store.transaction));
                } catch (err) {
                    reject(err);
                }
            };
        }))));
    }
    function del(key, customStore = defaultGetStore()) {
        return customStore("readwrite", (store => {
            store.delete(key);
            return promisifyRequest(store.transaction);
        }));
    }
    function delMany(keys, customStore = defaultGetStore()) {
        return customStore("readwrite", (store => {
            keys.forEach((key => store.delete(key)));
            return promisifyRequest(store.transaction);
        }));
    }
    function clear(customStore = defaultGetStore()) {
        return customStore("readwrite", (store => {
            store.clear();
            return promisifyRequest(store.transaction);
        }));
    }
    function eachCursor(store, callback) {
        store.openCursor().onsuccess = function() {
            if (!this.result) return;
            callback(this.result);
            this.result.continue();
        };
        return promisifyRequest(store.transaction);
    }
    function keys(customStore = defaultGetStore()) {
        return customStore("readonly", (store => {
            if (store.getAllKeys) {
                return promisifyRequest(store.getAllKeys());
            }
            const items = [];
            return eachCursor(store, (cursor => items.push(cursor.key))).then((() => items));
        }));
    }
    function values(customStore = defaultGetStore()) {
        return customStore("readonly", (store => {
            if (store.getAll) {
                return promisifyRequest(store.getAll());
            }
            const items = [];
            return eachCursor(store, (cursor => items.push(cursor.value))).then((() => items));
        }));
    }
    function entries(customStore = defaultGetStore()) {
        return customStore("readonly", (store => {
            if (store.getAll && store.getAllKeys) {
                return Promise.all([ promisifyRequest(store.getAllKeys()), promisifyRequest(store.getAll()) ]).then((([keys, values]) => keys.map(((key, i) => [ key, values[i] ]))));
            }
            const items = [];
            return customStore("readonly", (store => eachCursor(store, (cursor => items.push([ cursor.key, cursor.value ]))).then((() => items))));
        }));
    }
    class CachedNetCrs {
        constructor(numPoints) {
            this.numPoints = numPoints;
        }
        static async new(numPoints) {
            const crs = new CachedNetCrs(numPoints);
            await crs.init();
            return crs;
        }
        async init() {
            const g1Data = await get("g1Data");
            const g2Data = await get("g2Data");
            const netCrs = new NetCrs(this.numPoints);
            const g1DataLength = this.numPoints * 64;
            if (!g1Data || g1Data.length < g1DataLength) {
                this.g1Data = await netCrs.downloadG1Data();
                await set("g1Data", this.g1Data);
            } else {
                this.g1Data = g1Data;
            }
            if (!g2Data) {
                this.g2Data = await netCrs.downloadG2Data();
                await set("g2Data", this.g2Data);
            } else {
                this.g2Data = g2Data;
            }
        }
        getG1Data() {
            return this.g1Data;
        }
        getG2Data() {
            return this.g2Data;
        }
    }
    class CachedNetGrumpkinCrs {
        constructor(numPoints) {
            this.numPoints = numPoints;
        }
        static async new(numPoints) {
            const crs = new CachedNetGrumpkinCrs(numPoints);
            await crs.init();
            return crs;
        }
        async init() {
            const g1Data = await get("grumpkinG1Data");
            const netGrumpkinCrs = new NetGrumpkinCrs(this.numPoints);
            const g1DataLength = this.numPoints * 64;
            if (!g1Data || g1Data.length < g1DataLength) {
                this.g1Data = await netGrumpkinCrs.downloadG1Data();
                await set("grumpkinG1Data", this.g1Data);
            } else {
                this.g1Data = g1Data;
            }
        }
        getG1Data() {
            return this.g1Data;
        }
    }
    const proxyMarker = Symbol("Comlink.proxy");
    const createEndpoint = Symbol("Comlink.endpoint");
    const releaseProxy = Symbol("Comlink.releaseProxy");
    const finalizer = Symbol("Comlink.finalizer");
    const throwMarker = Symbol("Comlink.thrown");
    const isObject = val => typeof val === "object" && val !== null || typeof val === "function";
    const proxyTransferHandler = {
        canHandle: val => isObject(val) && val[proxyMarker],
        serialize(obj) {
            const {port1, port2} = new MessageChannel;
            expose(obj, port1);
            return [ port2, [ port2 ] ];
        },
        deserialize(port) {
            port.start();
            return wrap(port);
        }
    };
    const throwTransferHandler = {
        canHandle: value => isObject(value) && throwMarker in value,
        serialize({value}) {
            let serialized;
            if (value instanceof Error) {
                serialized = {
                    isError: true,
                    value: {
                        message: value.message,
                        name: value.name,
                        stack: value.stack
                    }
                };
            } else {
                serialized = {
                    isError: false,
                    value
                };
            }
            return [ serialized, [] ];
        },
        deserialize(serialized) {
            if (serialized.isError) {
                throw Object.assign(new Error(serialized.value.message), serialized.value);
            }
            throw serialized.value;
        }
    };
    const transferHandlers = new Map([ [ "proxy", proxyTransferHandler ], [ "throw", throwTransferHandler ] ]);
    function isAllowedOrigin(allowedOrigins, origin) {
        for (const allowedOrigin of allowedOrigins) {
            if (origin === allowedOrigin || allowedOrigin === "*") {
                return true;
            }
            if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
                return true;
            }
        }
        return false;
    }
    function expose(obj, ep = globalThis, allowedOrigins = [ "*" ]) {
        ep.addEventListener("message", (function callback(ev) {
            if (!ev || !ev.data) {
                return;
            }
            if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
                console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
                return;
            }
            const {id, type, path} = Object.assign({
                path: []
            }, ev.data);
            const argumentList = (ev.data.argumentList || []).map(fromWireValue);
            let returnValue;
            try {
                const parent = path.slice(0, -1).reduce(((obj, prop) => obj[prop]), obj);
                const rawValue = path.reduce(((obj, prop) => obj[prop]), obj);
                switch (type) {
                  case "GET":
                    {
                        returnValue = rawValue;
                    }
                    break;

                  case "SET":
                    {
                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
                        returnValue = true;
                    }
                    break;

                  case "APPLY":
                    {
                        returnValue = rawValue.apply(parent, argumentList);
                    }
                    break;

                  case "CONSTRUCT":
                    {
                        const value = new rawValue(...argumentList);
                        returnValue = comlink_proxy(value);
                    }
                    break;

                  case "ENDPOINT":
                    {
                        const {port1, port2} = new MessageChannel;
                        expose(obj, port2);
                        returnValue = transfer(port1, [ port1 ]);
                    }
                    break;

                  case "RELEASE":
                    {
                        returnValue = undefined;
                    }
                    break;

                  default:
                    return;
                }
            } catch (value) {
                returnValue = {
                    value,
                    [throwMarker]: 0
                };
            }
            Promise.resolve(returnValue).catch((value => ({
                value,
                [throwMarker]: 0
            }))).then((returnValue => {
                const [wireValue, transferables] = toWireValue(returnValue);
                ep.postMessage(Object.assign(Object.assign({}, wireValue), {
                    id
                }), transferables);
                if (type === "RELEASE") {
                    ep.removeEventListener("message", callback);
                    closeEndPoint(ep);
                    if (finalizer in obj && typeof obj[finalizer] === "function") {
                        obj[finalizer]();
                    }
                }
            })).catch((error => {
                const [wireValue, transferables] = toWireValue({
                    value: new TypeError("Unserializable return value"),
                    [throwMarker]: 0
                });
                ep.postMessage(Object.assign(Object.assign({}, wireValue), {
                    id
                }), transferables);
            }));
        }));
        if (ep.start) {
            ep.start();
        }
    }
    function isMessagePort(endpoint) {
        return endpoint.constructor.name === "MessagePort";
    }
    function closeEndPoint(endpoint) {
        if (isMessagePort(endpoint)) endpoint.close();
    }
    function wrap(ep, target) {
        return createProxy(ep, [], target);
    }
    function throwIfProxyReleased(isReleased) {
        if (isReleased) {
            throw new Error("Proxy has been released and is not useable");
        }
    }
    function releaseEndpoint(ep) {
        return requestResponseMessage(ep, {
            type: "RELEASE"
        }).then((() => {
            closeEndPoint(ep);
        }));
    }
    const proxyCounter = new WeakMap;
    const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep => {
        const newCount = (proxyCounter.get(ep) || 0) - 1;
        proxyCounter.set(ep, newCount);
        if (newCount === 0) {
            releaseEndpoint(ep);
        }
    }));
    function registerProxy(proxy, ep) {
        const newCount = (proxyCounter.get(ep) || 0) + 1;
        proxyCounter.set(ep, newCount);
        if (proxyFinalizers) {
            proxyFinalizers.register(proxy, ep, proxy);
        }
    }
    function unregisterProxy(proxy) {
        if (proxyFinalizers) {
            proxyFinalizers.unregister(proxy);
        }
    }
    function createProxy(ep, path = [], target = function() {}) {
        let isProxyReleased = false;
        const proxy = new Proxy(target, {
            get(_target, prop) {
                throwIfProxyReleased(isProxyReleased);
                if (prop === releaseProxy) {
                    return () => {
                        unregisterProxy(proxy);
                        releaseEndpoint(ep);
                        isProxyReleased = true;
                    };
                }
                if (prop === "then") {
                    if (path.length === 0) {
                        return {
                            then: () => proxy
                        };
                    }
                    const r = requestResponseMessage(ep, {
                        type: "GET",
                        path: path.map((p => p.toString()))
                    }).then(fromWireValue);
                    return r.then.bind(r);
                }
                return createProxy(ep, [ ...path, prop ]);
            },
            set(_target, prop, rawValue) {
                throwIfProxyReleased(isProxyReleased);
                const [value, transferables] = toWireValue(rawValue);
                return requestResponseMessage(ep, {
                    type: "SET",
                    path: [ ...path, prop ].map((p => p.toString())),
                    value
                }, transferables).then(fromWireValue);
            },
            apply(_target, _thisArg, rawArgumentList) {
                throwIfProxyReleased(isProxyReleased);
                const last = path[path.length - 1];
                if (last === createEndpoint) {
                    return requestResponseMessage(ep, {
                        type: "ENDPOINT"
                    }).then(fromWireValue);
                }
                if (last === "bind") {
                    return createProxy(ep, path.slice(0, -1));
                }
                const [argumentList, transferables] = processArguments(rawArgumentList);
                return requestResponseMessage(ep, {
                    type: "APPLY",
                    path: path.map((p => p.toString())),
                    argumentList
                }, transferables).then(fromWireValue);
            },
            construct(_target, rawArgumentList) {
                throwIfProxyReleased(isProxyReleased);
                const [argumentList, transferables] = processArguments(rawArgumentList);
                return requestResponseMessage(ep, {
                    type: "CONSTRUCT",
                    path: path.map((p => p.toString())),
                    argumentList
                }, transferables).then(fromWireValue);
            }
        });
        registerProxy(proxy, ep);
        return proxy;
    }
    function myFlat(arr) {
        return Array.prototype.concat.apply([], arr);
    }
    function processArguments(argumentList) {
        const processed = argumentList.map(toWireValue);
        return [ processed.map((v => v[0])), myFlat(processed.map((v => v[1]))) ];
    }
    const transferCache = new WeakMap;
    function transfer(obj, transfers) {
        transferCache.set(obj, transfers);
        return obj;
    }
    function comlink_proxy(obj) {
        return Object.assign(obj, {
            [proxyMarker]: true
        });
    }
    function windowEndpoint(w, context = globalThis, targetOrigin = "*") {
        return {
            postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),
            addEventListener: context.addEventListener.bind(context),
            removeEventListener: context.removeEventListener.bind(context)
        };
    }
    function toWireValue(value) {
        for (const [name, handler] of transferHandlers) {
            if (handler.canHandle(value)) {
                const [serializedValue, transferables] = handler.serialize(value);
                return [ {
                    type: "HANDLER",
                    name,
                    value: serializedValue
                }, transferables ];
            }
        }
        return [ {
            type: "RAW",
            value
        }, transferCache.get(value) || [] ];
    }
    function fromWireValue(value) {
        switch (value.type) {
          case "HANDLER":
            return transferHandlers.get(value.name).deserialize(value.value);

          case "RAW":
            return value.value;
        }
    }
    function requestResponseMessage(ep, msg, transfers) {
        return new Promise((resolve => {
            const id = generateUUID();
            ep.addEventListener("message", (function l(ev) {
                if (!ev.data || !ev.data.id || ev.data.id !== id) {
                    return;
                }
                ep.removeEventListener("message", l);
                resolve(ev.data);
            }));
            if (ep.start) {
                ep.start();
            }
            ep.postMessage(Object.assign({
                id
            }, msg), transfers);
        }));
    }
    function generateUUID() {
        return new Array(4).fill(0).map((() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))).join("-");
    }
    class RawBuffer extends Uint8Array {}
    function boolToBuffer(b) {
        const buf = new Uint8Array(1);
        buf[0] = b ? 1 : 0;
        return buf;
    }
    function numToUInt32LE(n, bufferSize = 4) {
        const buf = new Uint8Array(bufferSize);
        new DataView(buf.buffer).setUint32(buf.byteLength - 4, n, true);
        return buf;
    }
    function numToUInt32BE(n, bufferSize = 4) {
        const buf = new Uint8Array(bufferSize);
        new DataView(buf.buffer).setUint32(buf.byteLength - 4, n, false);
        return buf;
    }
    function numToInt32BE(n, bufferSize = 4) {
        const buf = new Uint8Array(bufferSize);
        new DataView(buf.buffer).setInt32(buf.byteLength - 4, n, false);
        return buf;
    }
    function numToUInt8(n) {
        const buf = new Uint8Array(1);
        buf[0] = n;
        return buf;
    }
    function concatenateUint8Arrays(arrayOfUint8Arrays) {
        const totalLength = arrayOfUint8Arrays.reduce(((prev, curr) => prev + curr.length), 0);
        const result = new Uint8Array(totalLength);
        let length = 0;
        for (const array of arrayOfUint8Arrays) {
            result.set(array, length);
            length += array.length;
        }
        return result;
    }
    function uint8ArrayToHexString(uint8Array) {
        return uint8Array.reduce(((accumulator, byte) => accumulator + byte.toString(16).padStart(2, "0")), "");
    }
    function serializeBufferToVector(buf) {
        return concatenateUint8Arrays([ numToInt32BE(buf.length), buf ]);
    }
    function serializeBigInt(n, width = 32) {
        const buf = new Uint8Array(width);
        for (let i = 0; i < width; i++) {
            buf[width - i - 1] = Number(n >> BigInt(i * 8) & 0xffn);
        }
        return buf;
    }
    function deserializeBigInt(buf, offset = 0, width = 32) {
        let result = 0n;
        for (let i = 0; i < width; i++) {
            result = result << BigInt(8) | BigInt(buf[offset + i]);
        }
        return {
            elem: result,
            adv: width
        };
    }
    function serializeDate(date) {
        return serializeBigInt(BigInt(date.getTime()), 8);
    }
    function deserializeBufferFromVector(vector, offset = 0) {
        const length = new DataView(vector.buffer, vector.byteOffset + offset, 4).getUint32(0, false);
        const adv = 4 + length;
        const elem = vector.slice(offset + 4, offset + adv);
        return {
            elem,
            adv
        };
    }
    function deserializeBool(buf, offset = 0) {
        const adv = 1;
        const elem = buf[offset] !== 0;
        return {
            elem,
            adv
        };
    }
    function deserializeUInt32(buf, offset = 0) {
        const adv = 4;
        const elem = new DataView(buf.buffer, buf.byteOffset + offset, adv).getUint32(0, false);
        return {
            elem,
            adv
        };
    }
    function deserializeInt32(buf, offset = 0) {
        const adv = 4;
        const elem = new DataView(buf.buffer, buf.byteOffset + offset, adv).getInt32(0, false);
        return {
            elem,
            adv
        };
    }
    function deserializeField(buf, offset = 0) {
        const adv = 32;
        const elem = buf.slice(offset, offset + adv);
        return {
            elem,
            adv
        };
    }
    function serializeBufferArrayToVector(arr) {
        return concatenateUint8Arrays([ numToUInt32BE(arr.length), ...arr.flat() ]);
    }
    function deserializeArrayFromVector(deserialize, vector, offset = 0) {
        let pos = offset;
        const size = new DataView(vector.buffer, vector.byteOffset + pos, 4).getUint32(0, false);
        pos += 4;
        const arr = new Array(size);
        for (let i = 0; i < size; ++i) {
            const {elem, adv} = deserialize(vector, pos);
            pos += adv;
            arr[i] = elem;
        }
        return {
            elem: arr,
            adv: pos - offset
        };
    }
    function serializeBufferable(obj) {
        if (Array.isArray(obj)) {
            return serializeBufferArrayToVector(obj.map(serializeBufferable));
        } else if (obj instanceof RawBuffer) {
            return obj;
        } else if (obj instanceof Uint8Array) {
            return serializeBufferToVector(obj);
        } else if (typeof obj === "boolean") {
            return boolToBuffer(obj);
        } else if (typeof obj === "number") {
            return numToUInt32BE(obj);
        } else if (typeof obj === "bigint") {
            return serializeBigInt(obj);
        } else if (typeof obj === "string") {
            return serializeBufferToVector((new TextEncoder).encode(obj));
        } else {
            return obj.toBuffer();
        }
    }
    class BufferReader {
        constructor(buffer, offset = 0) {
            this.buffer = buffer;
            this.index = offset;
        }
        static asReader(bufferOrReader) {
            return bufferOrReader instanceof BufferReader ? bufferOrReader : new BufferReader(bufferOrReader);
        }
        readNumber() {
            const dataView = new DataView(this.buffer.buffer, this.buffer.byteOffset + this.index, 4);
            this.index += 4;
            return dataView.getUint32(0, false);
        }
        readBoolean() {
            this.index += 1;
            return Boolean(this.buffer.at(this.index - 1));
        }
        readBytes(n) {
            this.index += n;
            return this.buffer.slice(this.index - n, this.index);
        }
        readNumberVector() {
            return this.readVector({
                fromBuffer: reader => reader.readNumber()
            });
        }
        readVector(itemDeserializer) {
            const size = this.readNumber();
            const result = new Array(size);
            for (let i = 0; i < size; i++) {
                result[i] = itemDeserializer.fromBuffer(this);
            }
            return result;
        }
        readArray(size, itemDeserializer) {
            const result = new Array(size);
            for (let i = 0; i < size; i++) {
                result[i] = itemDeserializer.fromBuffer(this);
            }
            return result;
        }
        readObject(deserializer) {
            return deserializer.fromBuffer(this);
        }
        peekBytes(n) {
            return this.buffer.subarray(this.index, n ? this.index + n : undefined);
        }
        readString() {
            return (new TextDecoder).decode(this.readBuffer());
        }
        readBuffer() {
            const size = this.readNumber();
            return this.readBytes(size);
        }
        readMap(deserializer) {
            const numEntries = this.readNumber();
            const map = {};
            for (let i = 0; i < numEntries; i++) {
                const key = this.readString();
                const value = this.readObject(deserializer);
                map[key] = value;
            }
            return map;
        }
    }
    function BoolDeserializer() {
        return {
            SIZE_IN_BYTES: 1,
            fromBuffer: buf => {
                const reader = BufferReader.asReader(buf);
                return reader.readBoolean();
            }
        };
    }
    function NumberDeserializer() {
        return {
            SIZE_IN_BYTES: 4,
            fromBuffer: buf => {
                const reader = BufferReader.asReader(buf);
                return reader.readNumber();
            }
        };
    }
    function VectorDeserializer(t) {
        return {
            fromBuffer: buf => {
                const reader = BufferReader.asReader(buf);
                return reader.readVector(t);
            }
        };
    }
    function BufferDeserializer() {
        return {
            fromBuffer: buf => {
                const reader = BufferReader.asReader(buf);
                return reader.readBuffer();
            }
        };
    }
    function StringDeserializer() {
        return {
            fromBuffer: buf => {
                const reader = BufferReader.asReader(buf);
                return reader.readString();
            }
        };
    }
    class Ptr {
        constructor(value) {
            this.value = value;
        }
        static fromBuffer(buffer) {
            const reader = BufferReader.asReader(buffer);
            return new this(reader.readBytes(this.SIZE_IN_BYTES));
        }
        toBuffer() {
            return this.value;
        }
    }
    Ptr.SIZE_IN_BYTES = 4;
    const randomBytes = len => {
        const getWebCrypto = () => {
            if (typeof window !== "undefined" && window.crypto) return window.crypto;
            if (typeof globalThis !== "undefined" && globalThis.crypto) return globalThis.crypto;
            return undefined;
        };
        const crypto = getWebCrypto();
        if (!crypto) {
            throw new Error("randomBytes UnsupportedEnvironment");
        }
        const buf = new Uint8Array(len);
        const MAX_BYTES = 65536;
        if (len > MAX_BYTES) {
            for (let generated = 0; generated < len; generated += MAX_BYTES) {
                crypto.getRandomValues(buf.subarray(generated, generated + MAX_BYTES));
            }
        } else {
            crypto.getRandomValues(buf);
        }
        return buf;
    };
    var Buffer = __webpack_require__(764)["lW"];
    function buffer32BytesToBigIntBE(buf) {
        return (buf.readBigUInt64BE(0) << 192n) + (buf.readBigUInt64BE(8) << 128n) + (buf.readBigUInt64BE(16) << 64n) + buf.readBigUInt64BE(24);
    }
    function uint8ArrayToBigIntBE(bytes) {
        const buffer = Buffer.from(bytes);
        return buffer32BytesToBigIntBE(buffer);
    }
    function bigIntToBufferBE(value, byteLength = 32) {
        if (byteLength != 32) {
            throw new Error(`Only 32 bytes supported for conversion from bigint to buffer, attempted byte length: ${byteLength}`);
        }
        const buf = Buffer.alloc(byteLength);
        buf.writeBigUInt64BE(value >> 192n, 0);
        buf.writeBigUInt64BE(value >> 128n & 0xffffffffffffffffn, 8);
        buf.writeBigUInt64BE(value >> 64n & 0xffffffffffffffffn, 16);
        buf.writeBigUInt64BE(value & 0xffffffffffffffffn, 24);
        return buf;
    }
    function bigIntToUint8ArrayBE(value, byteLength = 32) {
        return new Uint8Array(bigIntToBufferBE(value, byteLength));
    }
    var fields_Buffer = __webpack_require__(764)["lW"];
    var _a, _b;
    class Fr {
        constructor(value) {
            const valueBigInt = typeof value === "bigint" ? value : value instanceof fields_Buffer ? buffer32BytesToBigIntBE(value) : uint8ArrayToBigIntBE(value);
            if (valueBigInt > _a.MAX_VALUE) {
                throw new Error(`Value 0x${valueBigInt.toString(16)} is greater or equal to field modulus.`);
            }
            this.value = typeof value === "bigint" ? bigIntToUint8ArrayBE(value) : value instanceof fields_Buffer ? new Uint8Array(value) : value;
        }
        static random() {
            const r = uint8ArrayToBigIntBE(randomBytes(64)) % _a.MODULUS;
            return new this(r);
        }
        static fromBuffer(buffer) {
            const reader = BufferReader.asReader(buffer);
            return new this(reader.readBytes(this.SIZE_IN_BYTES));
        }
        static fromBufferReduce(buffer) {
            const reader = BufferReader.asReader(buffer);
            return new this(uint8ArrayToBigIntBE(reader.readBytes(this.SIZE_IN_BYTES)) % _a.MODULUS);
        }
        static fromString(str) {
            return this.fromBuffer(fields_Buffer.from(str.replace(/^0x/i, ""), "hex"));
        }
        toBuffer() {
            return this.value;
        }
        toString() {
            return "0x" + uint8ArrayToHexString(this.toBuffer());
        }
        equals(rhs) {
            return this.value.every(((v, i) => v === rhs.value[i]));
        }
        isZero() {
            return this.value.every((v => v === 0));
        }
    }
    _a = Fr;
    Fr.ZERO = new _a(0n);
    Fr.MODULUS = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001n;
    Fr.MAX_VALUE = _a.MODULUS - 1n;
    Fr.SIZE_IN_BYTES = 32;
    class Fq {
        constructor(value) {
            this.value = value;
            if (value > _b.MAX_VALUE) {
                throw new Error(`Fq out of range ${value}.`);
            }
        }
        static random() {
            const r = uint8ArrayToBigIntBE(randomBytes(64)) % _b.MODULUS;
            return new this(r);
        }
        static fromBuffer(buffer) {
            const reader = BufferReader.asReader(buffer);
            return new this(uint8ArrayToBigIntBE(reader.readBytes(this.SIZE_IN_BYTES)));
        }
        static fromBufferReduce(buffer) {
            const reader = BufferReader.asReader(buffer);
            return new this(uint8ArrayToBigIntBE(reader.readBytes(this.SIZE_IN_BYTES)) % Fr.MODULUS);
        }
        static fromString(str) {
            return this.fromBuffer(fields_Buffer.from(str.replace(/^0x/i, ""), "hex"));
        }
        toBuffer() {
            return bigIntToBufferBE(this.value, _b.SIZE_IN_BYTES);
        }
        toString() {
            return "0x" + this.value.toString(16);
        }
        equals(rhs) {
            return this.value === rhs.value;
        }
        isZero() {
            return this.value === 0n;
        }
    }
    _b = Fq;
    Fq.MODULUS = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47n;
    Fq.MAX_VALUE = _b.MODULUS - 1n;
    Fq.SIZE_IN_BYTES = 32;
    var point_Buffer = __webpack_require__(764)["lW"];
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        static random() {
            return new Point(Fr.random(), Fr.random());
        }
        static fromBuffer(buffer) {
            const reader = BufferReader.asReader(buffer);
            return new this(Fr.fromBuffer(reader), Fr.fromBuffer(reader));
        }
        static fromString(address) {
            return Point.fromBuffer(point_Buffer.from(address.replace(/^0x/i, ""), "hex"));
        }
        toBuffer() {
            return point_Buffer.concat([ this.x.toBuffer(), this.y.toBuffer() ]);
        }
        toString() {
            return "0x" + this.toBuffer().toString("hex");
        }
        equals(rhs) {
            return this.x.equals(rhs.x) && this.y.equals(rhs.y);
        }
    }
    Point.SIZE_IN_BYTES = 64;
    Point.EMPTY = new Point(Fr.ZERO, Fr.ZERO);
    class Buffer32 {
        constructor(buffer) {
            this.buffer = buffer;
        }
        static fromBuffer(buffer) {
            const reader = BufferReader.asReader(buffer);
            return new Buffer32(reader.readBytes(this.SIZE_IN_BYTES));
        }
        static random() {
            return new Buffer32(randomBytes(this.SIZE_IN_BYTES));
        }
        toBuffer() {
            return this.buffer;
        }
    }
    Buffer32.SIZE_IN_BYTES = 32;
    class Buffer64 {
        constructor(buffer) {
            this.buffer = buffer;
        }
        static fromBuffer(buffer) {
            const reader = BufferReader.asReader(buffer);
            return new Buffer64(reader.readBytes(this.SIZE_IN_BYTES));
        }
        static random() {
            return new Buffer64(randomBytes(this.SIZE_IN_BYTES));
        }
        toBuffer() {
            return this.buffer;
        }
    }
    Buffer64.SIZE_IN_BYTES = 64;
    class Buffer128 {
        constructor(buffer) {
            this.buffer = buffer;
        }
        static fromBuffer(buffer) {
            const reader = BufferReader.asReader(buffer);
            return new Buffer128(reader.readBytes(this.SIZE_IN_BYTES));
        }
        static random() {
            return new Buffer128(randomBytes(this.SIZE_IN_BYTES));
        }
        toBuffer() {
            return this.buffer;
        }
    }
    Buffer128.SIZE_IN_BYTES = 128;
    function parseBigEndianU32Array(buffer, hasSizePrefix = false) {
        const dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        let offset = 0;
        let count = buffer.byteLength >>> 2;
        if (hasSizePrefix) {
            count = dv.getUint32(0, false);
            offset = 4;
        }
        const out = new Array(count);
        for (let i = 0; i < count; i++) {
            out[i] = dv.getUint32(offset, false);
            offset += 4;
        }
        return out;
    }
    class BarretenbergApi {
        constructor(wasm) {
            this.wasm = wasm;
        }
        async pedersenCommit(inputsBuffer, ctxIndex) {
            const inArgs = [ inputsBuffer, ctxIndex ].map(serializeBufferable);
            const outTypes = [ Point ];
            const result = await this.wasm.callWasmExport("pedersen_commit", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async pedersenHash(inputsBuffer, hashIndex) {
            const inArgs = [ inputsBuffer, hashIndex ].map(serializeBufferable);
            const outTypes = [ Fr ];
            const result = await this.wasm.callWasmExport("pedersen_hash", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async pedersenHashes(inputsBuffer, hashIndex) {
            const inArgs = [ inputsBuffer, hashIndex ].map(serializeBufferable);
            const outTypes = [ Fr ];
            const result = await this.wasm.callWasmExport("pedersen_hashes", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async pedersenHashBuffer(inputBuffer, hashIndex) {
            const inArgs = [ inputBuffer, hashIndex ].map(serializeBufferable);
            const outTypes = [ Fr ];
            const result = await this.wasm.callWasmExport("pedersen_hash_buffer", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async poseidon2Hash(inputsBuffer) {
            const inArgs = [ inputsBuffer ].map(serializeBufferable);
            const outTypes = [ Fr ];
            const result = await this.wasm.callWasmExport("poseidon2_hash", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async poseidon2HashAccumulate(inputsBuffer) {
            const inArgs = [ inputsBuffer ].map(serializeBufferable);
            const outTypes = [ Fr ];
            const result = await this.wasm.callWasmExport("poseidon2_hash_accumulate", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async poseidon2Hashes(inputsBuffer) {
            const inArgs = [ inputsBuffer ].map(serializeBufferable);
            const outTypes = [ Fr ];
            const result = await this.wasm.callWasmExport("poseidon2_hashes", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async poseidon2Permutation(inputsBuffer) {
            const inArgs = [ inputsBuffer ].map(serializeBufferable);
            const outTypes = [ VectorDeserializer(Fr) ];
            const result = await this.wasm.callWasmExport("poseidon2_permutation", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async blake2s(data) {
            const inArgs = [ data ].map(serializeBufferable);
            const outTypes = [ Buffer32 ];
            const result = await this.wasm.callWasmExport("blake2s", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async blake2sToField(data) {
            const inArgs = [ data ].map(serializeBufferable);
            const outTypes = [ Fr ];
            const result = await this.wasm.callWasmExport("blake2s_to_field_", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async schnorrComputePublicKey(privateKey) {
            const inArgs = [ privateKey ].map(serializeBufferable);
            const outTypes = [ Point ];
            const result = await this.wasm.callWasmExport("schnorr_compute_public_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async schnorrNegatePublicKey(publicKeyBuffer) {
            const inArgs = [ publicKeyBuffer ].map(serializeBufferable);
            const outTypes = [ Point ];
            const result = await this.wasm.callWasmExport("schnorr_negate_public_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async schnorrConstructSignature(message, privateKey) {
            const inArgs = [ message, privateKey ].map(serializeBufferable);
            const outTypes = [ Buffer32, Buffer32 ];
            const result = await this.wasm.callWasmExport("schnorr_construct_signature", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out;
        }
        async schnorrVerifySignature(message, pubKey, sigS, sigE) {
            const inArgs = [ message, pubKey, sigS, sigE ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = await this.wasm.callWasmExport("schnorr_verify_signature", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async schnorrMultisigCreateMultisigPublicKey(privateKey) {
            const inArgs = [ privateKey ].map(serializeBufferable);
            const outTypes = [ Buffer128 ];
            const result = await this.wasm.callWasmExport("schnorr_multisig_create_multisig_public_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async schnorrMultisigValidateAndCombineSignerPubkeys(signerPubkeyBuf) {
            const inArgs = [ signerPubkeyBuf ].map(serializeBufferable);
            const outTypes = [ Point, BoolDeserializer() ];
            const result = await this.wasm.callWasmExport("schnorr_multisig_validate_and_combine_signer_pubkeys", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out;
        }
        async schnorrMultisigConstructSignatureRound1() {
            const inArgs = [].map(serializeBufferable);
            const outTypes = [ Buffer128, Buffer128 ];
            const result = await this.wasm.callWasmExport("schnorr_multisig_construct_signature_round_1", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out;
        }
        async schnorrMultisigConstructSignatureRound2(message, privateKey, signerRoundOnePrivateBuf, signerPubkeysBuf, roundOnePublicBuf) {
            const inArgs = [ message, privateKey, signerRoundOnePrivateBuf, signerPubkeysBuf, roundOnePublicBuf ].map(serializeBufferable);
            const outTypes = [ Fq, BoolDeserializer() ];
            const result = await this.wasm.callWasmExport("schnorr_multisig_construct_signature_round_2", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out;
        }
        async schnorrMultisigCombineSignatures(message, signerPubkeysBuf, roundOneBuf, roundTwoBuf) {
            const inArgs = [ message, signerPubkeysBuf, roundOneBuf, roundTwoBuf ].map(serializeBufferable);
            const outTypes = [ Buffer32, Buffer32, BoolDeserializer() ];
            const result = await this.wasm.callWasmExport("schnorr_multisig_combine_signatures", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out;
        }
        async aesEncryptBufferCbc(input, iv, key, length) {
            const inArgs = [ input, iv, key, length ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = await this.wasm.callWasmExport("aes_encrypt_buffer_cbc", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async aesDecryptBufferCbc(input, iv, key, length) {
            const inArgs = [ input, iv, key, length ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = await this.wasm.callWasmExport("aes_decrypt_buffer_cbc", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async srsInitSrs(pointsBuf, numPoints, g2PointBuf) {
            const inArgs = [ pointsBuf, numPoints, g2PointBuf ].map(serializeBufferable);
            const outTypes = [];
            const result = await this.wasm.callWasmExport("srs_init_srs", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return;
        }
        async srsInitGrumpkinSrs(pointsBuf, numPoints) {
            const inArgs = [ pointsBuf, numPoints ].map(serializeBufferable);
            const outTypes = [];
            const result = await this.wasm.callWasmExport("srs_init_grumpkin_srs", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return;
        }
        async examplesSimpleCreateAndVerifyProof() {
            const inArgs = [].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = await this.wasm.callWasmExport("examples_simple_create_and_verify_proof", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async testThreads(threads, iterations) {
            const inArgs = [ threads, iterations ].map(serializeBufferable);
            const outTypes = [ NumberDeserializer() ];
            const result = await this.wasm.callWasmExport("test_threads", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async commonInitSlabAllocator(circuitSize) {
            const inArgs = [ circuitSize ].map(serializeBufferable);
            const outTypes = [];
            const result = await this.wasm.callWasmExport("common_init_slab_allocator", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return;
        }
        async acirGetCircuitSizes(constraintSystemBuf, recursive, honkRecursion) {
            const inArgs = [ constraintSystemBuf, recursive, honkRecursion ].map(serializeBufferable);
            const outTypes = [ NumberDeserializer(), NumberDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_get_circuit_sizes", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out;
        }
        async acirGatesAztecClient(acirVec) {
            const inArgs = [ acirVec ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const resultBuffer = await this.wasm.callWasmExport("acir_gates_aztec_client", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            return parseBigEndianU32Array(resultBuffer[0], true);
        }
        async acirNewAcirComposer(sizeHint) {
            const inArgs = [ sizeHint ].map(serializeBufferable);
            const outTypes = [ Ptr ];
            const result = await this.wasm.callWasmExport("acir_new_acir_composer", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirDeleteAcirComposer(acirComposerPtr) {
            const inArgs = [ acirComposerPtr ].map(serializeBufferable);
            const outTypes = [];
            const result = await this.wasm.callWasmExport("acir_delete_acir_composer", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return;
        }
        async acirInitProvingKey(acirComposerPtr, constraintSystemBuf, recursive) {
            const inArgs = [ acirComposerPtr, constraintSystemBuf, recursive ].map(serializeBufferable);
            const outTypes = [];
            const result = await this.wasm.callWasmExport("acir_init_proving_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return;
        }
        async acirCreateProof(acirComposerPtr, constraintSystemBuf, recursive, witnessBuf) {
            const inArgs = [ acirComposerPtr, constraintSystemBuf, recursive, witnessBuf ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_create_proof", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirProveAndVerifyUltraHonk(constraintSystemBuf, recursive, witnessBuf) {
            const inArgs = [ constraintSystemBuf, recursive, witnessBuf ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_prove_and_verify_ultra_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirProveAndVerifyMegaHonk(constraintSystemBuf, recursive, witnessBuf) {
            const inArgs = [ constraintSystemBuf, recursive, witnessBuf ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_prove_and_verify_mega_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirFoldAndVerifyProgramStack(constraintSystemBuf, recursive, witnessBuf) {
            const inArgs = [ constraintSystemBuf, recursive, witnessBuf ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_fold_and_verify_program_stack", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirLoadVerificationKey(acirComposerPtr, vkBuf) {
            const inArgs = [ acirComposerPtr, vkBuf ].map(serializeBufferable);
            const outTypes = [];
            const result = await this.wasm.callWasmExport("acir_load_verification_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return;
        }
        async acirInitVerificationKey(acirComposerPtr) {
            const inArgs = [ acirComposerPtr ].map(serializeBufferable);
            const outTypes = [];
            const result = await this.wasm.callWasmExport("acir_init_verification_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return;
        }
        async acirGetVerificationKey(acirComposerPtr) {
            const inArgs = [ acirComposerPtr ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_get_verification_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirGetProvingKey(acirComposerPtr, acirVec, recursive) {
            const inArgs = [ acirComposerPtr, acirVec, recursive ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_get_proving_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirVerifyProof(acirComposerPtr, proofBuf) {
            const inArgs = [ acirComposerPtr, proofBuf ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_verify_proof", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirGetSolidityVerifier(acirComposerPtr) {
            const inArgs = [ acirComposerPtr ].map(serializeBufferable);
            const outTypes = [ StringDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_get_solidity_verifier", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirSerializeProofIntoFields(acirComposerPtr, proofBuf, numInnerPublicInputs) {
            const inArgs = [ acirComposerPtr, proofBuf, numInnerPublicInputs ].map(serializeBufferable);
            const outTypes = [ VectorDeserializer(Fr) ];
            const result = await this.wasm.callWasmExport("acir_serialize_proof_into_fields", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirSerializeVerificationKeyIntoFields(acirComposerPtr) {
            const inArgs = [ acirComposerPtr ].map(serializeBufferable);
            const outTypes = [ VectorDeserializer(Fr), Fr ];
            const result = await this.wasm.callWasmExport("acir_serialize_verification_key_into_fields", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out;
        }
        async acirProveAndVerifyAztecClient(acirVec, witnessVec) {
            const inArgs = [ acirVec, witnessVec ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_prove_and_verify_aztec_client", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirProveAztecClient(acirVec, witnessVec) {
            const inArgs = [ acirVec, witnessVec ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer(), BufferDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_prove_aztec_client", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return [ out[0], out[1] ];
        }
        async acirVerifyAztecClient(proofBuf, vkBuf) {
            const inArgs = [ proofBuf, vkBuf ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_verify_aztec_client", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirProveUltraHonk(acirVec, recursive, witnessVec) {
            const inArgs = [ acirVec, recursive, witnessVec ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_prove_ultra_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirProveUltraKeccakHonk(acirVec, recursive, witnessVec) {
            const inArgs = [ acirVec, recursive, witnessVec ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_prove_ultra_keccak_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirVerifyUltraHonk(proofBuf, vkBuf) {
            const inArgs = [ proofBuf, vkBuf ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_verify_ultra_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirVerifyUltraKeccakHonk(proofBuf, vkBuf) {
            const inArgs = [ proofBuf, vkBuf ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_verify_ultra_keccak_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirWriteVkUltraHonk(acirVec, recursive) {
            const inArgs = [ acirVec, recursive ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_write_vk_ultra_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirWriteVkUltraKeccakHonk(acirVec, recursive) {
            const inArgs = [ acirVec, recursive ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_write_vk_ultra_keccak_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirHonkSolidityVerifier(acirVec, vkBuf) {
            const inArgs = [ acirVec, vkBuf ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = await this.wasm.callWasmExport("acir_honk_solidity_verifier", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirProofAsFieldsUltraHonk(proofBuf) {
            const inArgs = [ proofBuf ].map(serializeBufferable);
            const outTypes = [ VectorDeserializer(Fr) ];
            const result = await this.wasm.callWasmExport("acir_proof_as_fields_ultra_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirVkAsFieldsUltraHonk(vkBuf) {
            const inArgs = [ vkBuf ].map(serializeBufferable);
            const outTypes = [ VectorDeserializer(Fr) ];
            const result = await this.wasm.callWasmExport("acir_vk_as_fields_ultra_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        async acirVkAsFieldsMegaHonk(vkBuf) {
            const inArgs = [ vkBuf ].map(serializeBufferable);
            const outTypes = [ VectorDeserializer(Fr) ];
            const result = await this.wasm.callWasmExport("acir_vk_as_fields_mega_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
    }
    class BarretenbergApiSync {
        constructor(wasm) {
            this.wasm = wasm;
        }
        pedersenCommit(inputsBuffer, ctxIndex) {
            const inArgs = [ inputsBuffer, ctxIndex ].map(serializeBufferable);
            const outTypes = [ Point ];
            const result = this.wasm.callWasmExport("pedersen_commit", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        pedersenHash(inputsBuffer, hashIndex) {
            const inArgs = [ inputsBuffer, hashIndex ].map(serializeBufferable);
            const outTypes = [ Fr ];
            const result = this.wasm.callWasmExport("pedersen_hash", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        pedersenHashes(inputsBuffer, hashIndex) {
            const inArgs = [ inputsBuffer, hashIndex ].map(serializeBufferable);
            const outTypes = [ Fr ];
            const result = this.wasm.callWasmExport("pedersen_hashes", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        pedersenHashBuffer(inputBuffer, hashIndex) {
            const inArgs = [ inputBuffer, hashIndex ].map(serializeBufferable);
            const outTypes = [ Fr ];
            const result = this.wasm.callWasmExport("pedersen_hash_buffer", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        poseidon2Hash(inputsBuffer) {
            const inArgs = [ inputsBuffer ].map(serializeBufferable);
            const outTypes = [ Fr ];
            const result = this.wasm.callWasmExport("poseidon2_hash", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        poseidon2HashAccumulate(inputsBuffer) {
            const inArgs = [ inputsBuffer ].map(serializeBufferable);
            const outTypes = [ Fr ];
            const result = this.wasm.callWasmExport("poseidon2_hash_accumulate", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        poseidon2Hashes(inputsBuffer) {
            const inArgs = [ inputsBuffer ].map(serializeBufferable);
            const outTypes = [ Fr ];
            const result = this.wasm.callWasmExport("poseidon2_hashes", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        poseidon2Permutation(inputsBuffer) {
            const inArgs = [ inputsBuffer ].map(serializeBufferable);
            const outTypes = [ VectorDeserializer(Fr) ];
            const result = this.wasm.callWasmExport("poseidon2_permutation", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        blake2s(data) {
            const inArgs = [ data ].map(serializeBufferable);
            const outTypes = [ Buffer32 ];
            const result = this.wasm.callWasmExport("blake2s", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        blake2sToField(data) {
            const inArgs = [ data ].map(serializeBufferable);
            const outTypes = [ Fr ];
            const result = this.wasm.callWasmExport("blake2s_to_field_", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        schnorrComputePublicKey(privateKey) {
            const inArgs = [ privateKey ].map(serializeBufferable);
            const outTypes = [ Point ];
            const result = this.wasm.callWasmExport("schnorr_compute_public_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        schnorrNegatePublicKey(publicKeyBuffer) {
            const inArgs = [ publicKeyBuffer ].map(serializeBufferable);
            const outTypes = [ Point ];
            const result = this.wasm.callWasmExport("schnorr_negate_public_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        schnorrConstructSignature(message, privateKey) {
            const inArgs = [ message, privateKey ].map(serializeBufferable);
            const outTypes = [ Buffer32, Buffer32 ];
            const result = this.wasm.callWasmExport("schnorr_construct_signature", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out;
        }
        schnorrVerifySignature(message, pubKey, sigS, sigE) {
            const inArgs = [ message, pubKey, sigS, sigE ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = this.wasm.callWasmExport("schnorr_verify_signature", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        schnorrMultisigCreateMultisigPublicKey(privateKey) {
            const inArgs = [ privateKey ].map(serializeBufferable);
            const outTypes = [ Buffer128 ];
            const result = this.wasm.callWasmExport("schnorr_multisig_create_multisig_public_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        schnorrMultisigValidateAndCombineSignerPubkeys(signerPubkeyBuf) {
            const inArgs = [ signerPubkeyBuf ].map(serializeBufferable);
            const outTypes = [ Point, BoolDeserializer() ];
            const result = this.wasm.callWasmExport("schnorr_multisig_validate_and_combine_signer_pubkeys", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out;
        }
        schnorrMultisigConstructSignatureRound1() {
            const inArgs = [].map(serializeBufferable);
            const outTypes = [ Buffer128, Buffer128 ];
            const result = this.wasm.callWasmExport("schnorr_multisig_construct_signature_round_1", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out;
        }
        schnorrMultisigConstructSignatureRound2(message, privateKey, signerRoundOnePrivateBuf, signerPubkeysBuf, roundOnePublicBuf) {
            const inArgs = [ message, privateKey, signerRoundOnePrivateBuf, signerPubkeysBuf, roundOnePublicBuf ].map(serializeBufferable);
            const outTypes = [ Fq, BoolDeserializer() ];
            const result = this.wasm.callWasmExport("schnorr_multisig_construct_signature_round_2", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out;
        }
        schnorrMultisigCombineSignatures(message, signerPubkeysBuf, roundOneBuf, roundTwoBuf) {
            const inArgs = [ message, signerPubkeysBuf, roundOneBuf, roundTwoBuf ].map(serializeBufferable);
            const outTypes = [ Buffer32, Buffer32, BoolDeserializer() ];
            const result = this.wasm.callWasmExport("schnorr_multisig_combine_signatures", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out;
        }
        aesEncryptBufferCbc(input, iv, key, length) {
            const inArgs = [ input, iv, key, length ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = this.wasm.callWasmExport("aes_encrypt_buffer_cbc", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        aesDecryptBufferCbc(input, iv, key, length) {
            const inArgs = [ input, iv, key, length ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = this.wasm.callWasmExport("aes_decrypt_buffer_cbc", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        srsInitSrs(pointsBuf, numPoints, g2PointBuf) {
            const inArgs = [ pointsBuf, numPoints, g2PointBuf ].map(serializeBufferable);
            const outTypes = [];
            const result = this.wasm.callWasmExport("srs_init_srs", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return;
        }
        srsInitGrumpkinSrs(pointsBuf, numPoints) {
            const inArgs = [ pointsBuf, numPoints ].map(serializeBufferable);
            const outTypes = [];
            const result = this.wasm.callWasmExport("srs_init_grumpkin_srs", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return;
        }
        examplesSimpleCreateAndVerifyProof() {
            const inArgs = [].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = this.wasm.callWasmExport("examples_simple_create_and_verify_proof", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        testThreads(threads, iterations) {
            const inArgs = [ threads, iterations ].map(serializeBufferable);
            const outTypes = [ NumberDeserializer() ];
            const result = this.wasm.callWasmExport("test_threads", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        commonInitSlabAllocator(circuitSize) {
            const inArgs = [ circuitSize ].map(serializeBufferable);
            const outTypes = [];
            const result = this.wasm.callWasmExport("common_init_slab_allocator", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return;
        }
        acirGetCircuitSizes(constraintSystemBuf, recursive, honkRecursion) {
            const inArgs = [ constraintSystemBuf, recursive, honkRecursion ].map(serializeBufferable);
            const outTypes = [ NumberDeserializer(), NumberDeserializer() ];
            const result = this.wasm.callWasmExport("acir_get_circuit_sizes", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out;
        }
        acirNewAcirComposer(sizeHint) {
            const inArgs = [ sizeHint ].map(serializeBufferable);
            const outTypes = [ Ptr ];
            const result = this.wasm.callWasmExport("acir_new_acir_composer", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirDeleteAcirComposer(acirComposerPtr) {
            const inArgs = [ acirComposerPtr ].map(serializeBufferable);
            const outTypes = [];
            const result = this.wasm.callWasmExport("acir_delete_acir_composer", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return;
        }
        acirInitProvingKey(acirComposerPtr, constraintSystemBuf, recursive) {
            const inArgs = [ acirComposerPtr, constraintSystemBuf, recursive ].map(serializeBufferable);
            const outTypes = [];
            const result = this.wasm.callWasmExport("acir_init_proving_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return;
        }
        acirCreateProof(acirComposerPtr, constraintSystemBuf, recursive, witnessBuf) {
            const inArgs = [ acirComposerPtr, constraintSystemBuf, recursive, witnessBuf ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = this.wasm.callWasmExport("acir_create_proof", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirProveAndVerifyUltraHonk(constraintSystemBuf, recursive, witnessBuf) {
            const inArgs = [ constraintSystemBuf, recursive, witnessBuf ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = this.wasm.callWasmExport("acir_prove_and_verify_ultra_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirProveAndVerifyMegaHonk(constraintSystemBuf, recursive, witnessBuf) {
            const inArgs = [ constraintSystemBuf, recursive, witnessBuf ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = this.wasm.callWasmExport("acir_prove_and_verify_mega_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirFoldAndVerifyProgramStack(constraintSystemBuf, recursive, witnessBuf) {
            const inArgs = [ constraintSystemBuf, recursive, witnessBuf ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = this.wasm.callWasmExport("acir_fold_and_verify_program_stack", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirLoadVerificationKey(acirComposerPtr, vkBuf) {
            const inArgs = [ acirComposerPtr, vkBuf ].map(serializeBufferable);
            const outTypes = [];
            const result = this.wasm.callWasmExport("acir_load_verification_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return;
        }
        acirInitVerificationKey(acirComposerPtr) {
            const inArgs = [ acirComposerPtr ].map(serializeBufferable);
            const outTypes = [];
            const result = this.wasm.callWasmExport("acir_init_verification_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return;
        }
        acirGetVerificationKey(acirComposerPtr) {
            const inArgs = [ acirComposerPtr ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = this.wasm.callWasmExport("acir_get_verification_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirGetProvingKey(acirComposerPtr, acirVec, recursive) {
            const inArgs = [ acirComposerPtr, acirVec, recursive ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = this.wasm.callWasmExport("acir_get_proving_key", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirVerifyProof(acirComposerPtr, proofBuf) {
            const inArgs = [ acirComposerPtr, proofBuf ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = this.wasm.callWasmExport("acir_verify_proof", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirGetSolidityVerifier(acirComposerPtr) {
            const inArgs = [ acirComposerPtr ].map(serializeBufferable);
            const outTypes = [ StringDeserializer() ];
            const result = this.wasm.callWasmExport("acir_get_solidity_verifier", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirSerializeProofIntoFields(acirComposerPtr, proofBuf, numInnerPublicInputs) {
            const inArgs = [ acirComposerPtr, proofBuf, numInnerPublicInputs ].map(serializeBufferable);
            const outTypes = [ VectorDeserializer(Fr) ];
            const result = this.wasm.callWasmExport("acir_serialize_proof_into_fields", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirSerializeVerificationKeyIntoFields(acirComposerPtr) {
            const inArgs = [ acirComposerPtr ].map(serializeBufferable);
            const outTypes = [ VectorDeserializer(Fr), Fr ];
            const result = this.wasm.callWasmExport("acir_serialize_verification_key_into_fields", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out;
        }
        acirProveUltraHonk(acirVec, recursive, witnessVec) {
            const inArgs = [ acirVec, recursive, witnessVec ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = this.wasm.callWasmExport("acir_prove_ultra_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirVerifyUltraHonk(proofBuf, vkBuf) {
            const inArgs = [ proofBuf, vkBuf ].map(serializeBufferable);
            const outTypes = [ BoolDeserializer() ];
            const result = this.wasm.callWasmExport("acir_verify_ultra_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirWriteVkUltraHonk(acirVec, recursive) {
            const inArgs = [ acirVec, recursive ].map(serializeBufferable);
            const outTypes = [ BufferDeserializer() ];
            const result = this.wasm.callWasmExport("acir_write_vk_ultra_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirProofAsFieldsUltraHonk(proofBuf) {
            const inArgs = [ proofBuf ].map(serializeBufferable);
            const outTypes = [ VectorDeserializer(Fr) ];
            const result = this.wasm.callWasmExport("acir_proof_as_fields_ultra_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirVkAsFieldsUltraHonk(vkBuf) {
            const inArgs = [ vkBuf ].map(serializeBufferable);
            const outTypes = [ VectorDeserializer(Fr) ];
            const result = this.wasm.callWasmExport("acir_vk_as_fields_ultra_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
        acirVkAsFieldsMegaHonk(vkBuf) {
            const inArgs = [ vkBuf ].map(serializeBufferable);
            const outTypes = [ VectorDeserializer(Fr) ];
            const result = this.wasm.callWasmExport("acir_vk_as_fields_mega_honk", inArgs, outTypes.map((t => t.SIZE_IN_BYTES)));
            const out = result.map(((r, i) => outTypes[i].fromBuffer(r)));
            return out[0];
        }
    }
    var browser = __webpack_require__(227);
    var browser_default = __webpack_require__.n(browser);
    var inline = __webpack_require__(477);
    var inline_default = __webpack_require__.n(inline);
    function Worker_fn() {
        return inline_default()('/*! For license information please see main.worker.worker.js.LICENSE.txt */\nvar __webpack_modules__ = {\n    227: (module, exports, __webpack_require__) => {\n        exports.formatArgs = formatArgs;\n        exports.save = save;\n        exports.load = load;\n        exports.useColors = useColors;\n        exports.storage = localstorage();\n        exports.destroy = (() => {\n            let warned = false;\n            return () => {\n                if (!warned) {\n                    warned = true;\n                    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");\n                }\n            };\n        })();\n        exports.colors = [ "#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33" ];\n        function useColors() {\n            if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {\n                return true;\n            }\n            if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n                return false;\n            }\n            return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n        }\n        function formatArgs(args) {\n            args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);\n            if (!this.useColors) {\n                return;\n            }\n            const c = "color: " + this.color;\n            args.splice(1, 0, c, "color: inherit");\n            let index = 0;\n            let lastC = 0;\n            args[0].replace(/%[a-zA-Z%]/g, (match => {\n                if (match === "%%") {\n                    return;\n                }\n                index++;\n                if (match === "%c") {\n                    lastC = index;\n                }\n            }));\n            args.splice(lastC, 0, c);\n        }\n        exports.log = console.debug || console.log || (() => {});\n        function save(namespaces) {\n            try {\n                if (namespaces) {\n                    exports.storage.setItem("debug", namespaces);\n                } else {\n                    exports.storage.removeItem("debug");\n                }\n            } catch (error) {}\n        }\n        function load() {\n            let r;\n            try {\n                r = exports.storage.getItem("debug");\n            } catch (error) {}\n            if (!r && typeof process !== "undefined" && "env" in process) {\n                r = process.env.DEBUG;\n            }\n            return r;\n        }\n        function localstorage() {\n            try {\n                return localStorage;\n            } catch (error) {}\n        }\n        module.exports = __webpack_require__(447)(exports);\n        const {formatters} = module.exports;\n        formatters.j = function(v) {\n            try {\n                return JSON.stringify(v);\n            } catch (error) {\n                return "[UnexpectedJSONParseError]: " + error.message;\n            }\n        };\n    },\n    447: (module, __unused_webpack_exports, __webpack_require__) => {\n        function setup(env) {\n            createDebug.debug = createDebug;\n            createDebug.default = createDebug;\n            createDebug.coerce = coerce;\n            createDebug.disable = disable;\n            createDebug.enable = enable;\n            createDebug.enabled = enabled;\n            createDebug.humanize = __webpack_require__(824);\n            createDebug.destroy = destroy;\n            Object.keys(env).forEach((key => {\n                createDebug[key] = env[key];\n            }));\n            createDebug.names = [];\n            createDebug.skips = [];\n            createDebug.formatters = {};\n            function selectColor(namespace) {\n                let hash = 0;\n                for (let i = 0; i < namespace.length; i++) {\n                    hash = (hash << 5) - hash + namespace.charCodeAt(i);\n                    hash |= 0;\n                }\n                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n            }\n            createDebug.selectColor = selectColor;\n            function createDebug(namespace) {\n                let prevTime;\n                let enableOverride = null;\n                let namespacesCache;\n                let enabledCache;\n                function debug(...args) {\n                    if (!debug.enabled) {\n                        return;\n                    }\n                    const self = debug;\n                    const curr = Number(new Date);\n                    const ms = curr - (prevTime || curr);\n                    self.diff = ms;\n                    self.prev = prevTime;\n                    self.curr = curr;\n                    prevTime = curr;\n                    args[0] = createDebug.coerce(args[0]);\n                    if (typeof args[0] !== "string") {\n                        args.unshift("%O");\n                    }\n                    let index = 0;\n                    args[0] = args[0].replace(/%([a-zA-Z%])/g, ((match, format) => {\n                        if (match === "%%") {\n                            return "%";\n                        }\n                        index++;\n                        const formatter = createDebug.formatters[format];\n                        if (typeof formatter === "function") {\n                            const val = args[index];\n                            match = formatter.call(self, val);\n                            args.splice(index, 1);\n                            index--;\n                        }\n                        return match;\n                    }));\n                    createDebug.formatArgs.call(self, args);\n                    const logFn = self.log || createDebug.log;\n                    logFn.apply(self, args);\n                }\n                debug.namespace = namespace;\n                debug.useColors = createDebug.useColors();\n                debug.color = createDebug.selectColor(namespace);\n                debug.extend = extend;\n                debug.destroy = createDebug.destroy;\n                Object.defineProperty(debug, "enabled", {\n                    enumerable: true,\n                    configurable: false,\n                    get: () => {\n                        if (enableOverride !== null) {\n                            return enableOverride;\n                        }\n                        if (namespacesCache !== createDebug.namespaces) {\n                            namespacesCache = createDebug.namespaces;\n                            enabledCache = createDebug.enabled(namespace);\n                        }\n                        return enabledCache;\n                    },\n                    set: v => {\n                        enableOverride = v;\n                    }\n                });\n                if (typeof createDebug.init === "function") {\n                    createDebug.init(debug);\n                }\n                return debug;\n            }\n            function extend(namespace, delimiter) {\n                const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);\n                newDebug.log = this.log;\n                return newDebug;\n            }\n            function enable(namespaces) {\n                createDebug.save(namespaces);\n                createDebug.namespaces = namespaces;\n                createDebug.names = [];\n                createDebug.skips = [];\n                let i;\n                const split = (typeof namespaces === "string" ? namespaces : "").split(/[\\s,]+/);\n                const len = split.length;\n                for (i = 0; i < len; i++) {\n                    if (!split[i]) {\n                        continue;\n                    }\n                    namespaces = split[i].replace(/\\*/g, ".*?");\n                    if (namespaces[0] === "-") {\n                        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));\n                    } else {\n                        createDebug.names.push(new RegExp("^" + namespaces + "$"));\n                    }\n                }\n            }\n            function disable() {\n                const namespaces = [ ...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace => "-" + namespace)) ].join(",");\n                createDebug.enable("");\n                return namespaces;\n            }\n            function enabled(name) {\n                if (name[name.length - 1] === "*") {\n                    return true;\n                }\n                let i;\n                let len;\n                for (i = 0, len = createDebug.skips.length; i < len; i++) {\n                    if (createDebug.skips[i].test(name)) {\n                        return false;\n                    }\n                }\n                for (i = 0, len = createDebug.names.length; i < len; i++) {\n                    if (createDebug.names[i].test(name)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            function toNamespace(regexp) {\n                return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, "*");\n            }\n            function coerce(val) {\n                if (val instanceof Error) {\n                    return val.stack || val.message;\n                }\n                return val;\n            }\n            function destroy() {\n                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");\n            }\n            createDebug.enable(createDebug.load());\n            return createDebug;\n        }\n        module.exports = setup;\n    },\n    824: module => {\n        var s = 1e3;\n        var m = s * 60;\n        var h = m * 60;\n        var d = h * 24;\n        var w = d * 7;\n        var y = d * 365.25;\n        module.exports = function(val, options) {\n            options = options || {};\n            var type = typeof val;\n            if (type === "string" && val.length > 0) {\n                return parse(val);\n            } else if (type === "number" && isFinite(val)) {\n                return options.long ? fmtLong(val) : fmtShort(val);\n            }\n            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));\n        };\n        function parse(str) {\n            str = String(str);\n            if (str.length > 100) {\n                return;\n            }\n            var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n            if (!match) {\n                return;\n            }\n            var n = parseFloat(match[1]);\n            var type = (match[2] || "ms").toLowerCase();\n            switch (type) {\n              case "years":\n              case "year":\n              case "yrs":\n              case "yr":\n              case "y":\n                return n * y;\n\n              case "weeks":\n              case "week":\n              case "w":\n                return n * w;\n\n              case "days":\n              case "day":\n              case "d":\n                return n * d;\n\n              case "hours":\n              case "hour":\n              case "hrs":\n              case "hr":\n              case "h":\n                return n * h;\n\n              case "minutes":\n              case "minute":\n              case "mins":\n              case "min":\n              case "m":\n                return n * m;\n\n              case "seconds":\n              case "second":\n              case "secs":\n              case "sec":\n              case "s":\n                return n * s;\n\n              case "milliseconds":\n              case "millisecond":\n              case "msecs":\n              case "msec":\n              case "ms":\n                return n;\n\n              default:\n                return undefined;\n            }\n        }\n        function fmtShort(ms) {\n            var msAbs = Math.abs(ms);\n            if (msAbs >= d) {\n                return Math.round(ms / d) + "d";\n            }\n            if (msAbs >= h) {\n                return Math.round(ms / h) + "h";\n            }\n            if (msAbs >= m) {\n                return Math.round(ms / m) + "m";\n            }\n            if (msAbs >= s) {\n                return Math.round(ms / s) + "s";\n            }\n            return ms + "ms";\n        }\n        function fmtLong(ms) {\n            var msAbs = Math.abs(ms);\n            if (msAbs >= d) {\n                return plural(ms, msAbs, d, "day");\n            }\n            if (msAbs >= h) {\n                return plural(ms, msAbs, h, "hour");\n            }\n            if (msAbs >= m) {\n                return plural(ms, msAbs, m, "minute");\n            }\n            if (msAbs >= s) {\n                return plural(ms, msAbs, s, "second");\n            }\n            return ms + " ms";\n        }\n        function plural(ms, msAbs, n, name) {\n            var isPlural = msAbs >= n * 1.5;\n            return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");\n        }\n    },\n    477: module => {\n        module.exports = function(content, workerConstructor, workerOptions, url) {\n            var globalScope = self || window;\n            try {\n                try {\n                    var blob;\n                    try {\n                        blob = new globalScope.Blob([ content ]);\n                    } catch (e) {\n                        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n                        blob = new BlobBuilder;\n                        blob.append(content);\n                        blob = blob.getBlob();\n                    }\n                    var URL = globalScope.URL || globalScope.webkitURL;\n                    var objectURL = URL.createObjectURL(blob);\n                    var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n                    URL.revokeObjectURL(objectURL);\n                    return worker;\n                } catch (e) {\n                    return new globalScope[workerConstructor]("data:application/javascript,".concat(encodeURIComponent(content)), workerOptions);\n                }\n            } catch (e) {\n                if (!url) {\n                    throw Error("Inline worker is not supported");\n                }\n                return new globalScope[workerConstructor](url, workerOptions);\n            }\n        };\n    }\n};\n\nvar __webpack_module_cache__ = {};\n\nfunction __webpack_require__(moduleId) {\n    var cachedModule = __webpack_module_cache__[moduleId];\n    if (cachedModule !== undefined) {\n        return cachedModule.exports;\n    }\n    var module = __webpack_module_cache__[moduleId] = {\n        exports: {}\n    };\n    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n    return module.exports;\n}\n\n(() => {\n    __webpack_require__.n = module => {\n        var getter = module && module.__esModule ? () => module["default"] : () => module;\n        __webpack_require__.d(getter, {\n            a: getter\n        });\n        return getter;\n    };\n})();\n\n(() => {\n    __webpack_require__.d = (exports, definition) => {\n        for (var key in definition) {\n            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n                Object.defineProperty(exports, key, {\n                    enumerable: true,\n                    get: definition[key]\n                });\n            }\n        }\n    };\n})();\n\n(() => {\n    __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n})();\n\nvar __webpack_exports__ = {};\n\n(() => {\n    const proxyMarker = Symbol("Comlink.proxy");\n    const createEndpoint = Symbol("Comlink.endpoint");\n    const releaseProxy = Symbol("Comlink.releaseProxy");\n    const finalizer = Symbol("Comlink.finalizer");\n    const throwMarker = Symbol("Comlink.thrown");\n    const isObject = val => typeof val === "object" && val !== null || typeof val === "function";\n    const proxyTransferHandler = {\n        canHandle: val => isObject(val) && val[proxyMarker],\n        serialize(obj) {\n            const {port1, port2} = new MessageChannel;\n            expose(obj, port1);\n            return [ port2, [ port2 ] ];\n        },\n        deserialize(port) {\n            port.start();\n            return wrap(port);\n        }\n    };\n    const throwTransferHandler = {\n        canHandle: value => isObject(value) && throwMarker in value,\n        serialize({value}) {\n            let serialized;\n            if (value instanceof Error) {\n                serialized = {\n                    isError: true,\n                    value: {\n                        message: value.message,\n                        name: value.name,\n                        stack: value.stack\n                    }\n                };\n            } else {\n                serialized = {\n                    isError: false,\n                    value\n                };\n            }\n            return [ serialized, [] ];\n        },\n        deserialize(serialized) {\n            if (serialized.isError) {\n                throw Object.assign(new Error(serialized.value.message), serialized.value);\n            }\n            throw serialized.value;\n        }\n    };\n    const transferHandlers = new Map([ [ "proxy", proxyTransferHandler ], [ "throw", throwTransferHandler ] ]);\n    function isAllowedOrigin(allowedOrigins, origin) {\n        for (const allowedOrigin of allowedOrigins) {\n            if (origin === allowedOrigin || allowedOrigin === "*") {\n                return true;\n            }\n            if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function expose(obj, ep = globalThis, allowedOrigins = [ "*" ]) {\n        ep.addEventListener("message", (function callback(ev) {\n            if (!ev || !ev.data) {\n                return;\n            }\n            if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n                console.warn(`Invalid origin \'${ev.origin}\' for comlink proxy`);\n                return;\n            }\n            const {id, type, path} = Object.assign({\n                path: []\n            }, ev.data);\n            const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n            let returnValue;\n            try {\n                const parent = path.slice(0, -1).reduce(((obj, prop) => obj[prop]), obj);\n                const rawValue = path.reduce(((obj, prop) => obj[prop]), obj);\n                switch (type) {\n                  case "GET":\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n\n                  case "SET":\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n\n                  case "APPLY":\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n\n                  case "CONSTRUCT":\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n\n                  case "ENDPOINT":\n                    {\n                        const {port1, port2} = new MessageChannel;\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [ port1 ]);\n                    }\n                    break;\n\n                  case "RELEASE":\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n\n                  default:\n                    return;\n                }\n            } catch (value) {\n                returnValue = {\n                    value,\n                    [throwMarker]: 0\n                };\n            }\n            Promise.resolve(returnValue).catch((value => ({\n                value,\n                [throwMarker]: 0\n            }))).then((returnValue => {\n                const [wireValue, transferables] = toWireValue(returnValue);\n                ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n                    id\n                }), transferables);\n                if (type === "RELEASE") {\n                    ep.removeEventListener("message", callback);\n                    closeEndPoint(ep);\n                    if (finalizer in obj && typeof obj[finalizer] === "function") {\n                        obj[finalizer]();\n                    }\n                }\n            })).catch((error => {\n                const [wireValue, transferables] = toWireValue({\n                    value: new TypeError("Unserializable return value"),\n                    [throwMarker]: 0\n                });\n                ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n                    id\n                }), transferables);\n            }));\n        }));\n        if (ep.start) {\n            ep.start();\n        }\n    }\n    function isMessagePort(endpoint) {\n        return endpoint.constructor.name === "MessagePort";\n    }\n    function closeEndPoint(endpoint) {\n        if (isMessagePort(endpoint)) endpoint.close();\n    }\n    function wrap(ep, target) {\n        return createProxy(ep, [], target);\n    }\n    function throwIfProxyReleased(isReleased) {\n        if (isReleased) {\n            throw new Error("Proxy has been released and is not useable");\n        }\n    }\n    function releaseEndpoint(ep) {\n        return requestResponseMessage(ep, {\n            type: "RELEASE"\n        }).then((() => {\n            closeEndPoint(ep);\n        }));\n    }\n    const proxyCounter = new WeakMap;\n    const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    }));\n    function registerProxy(proxy, ep) {\n        const newCount = (proxyCounter.get(ep) || 0) + 1;\n        proxyCounter.set(ep, newCount);\n        if (proxyFinalizers) {\n            proxyFinalizers.register(proxy, ep, proxy);\n        }\n    }\n    function unregisterProxy(proxy) {\n        if (proxyFinalizers) {\n            proxyFinalizers.unregister(proxy);\n        }\n    }\n    function createProxy(ep, path = [], target = function() {}) {\n        let isProxyReleased = false;\n        const proxy = new Proxy(target, {\n            get(_target, prop) {\n                throwIfProxyReleased(isProxyReleased);\n                if (prop === releaseProxy) {\n                    return () => {\n                        unregisterProxy(proxy);\n                        releaseEndpoint(ep);\n                        isProxyReleased = true;\n                    };\n                }\n                if (prop === "then") {\n                    if (path.length === 0) {\n                        return {\n                            then: () => proxy\n                        };\n                    }\n                    const r = requestResponseMessage(ep, {\n                        type: "GET",\n                        path: path.map((p => p.toString()))\n                    }).then(fromWireValue);\n                    return r.then.bind(r);\n                }\n                return createProxy(ep, [ ...path, prop ]);\n            },\n            set(_target, prop, rawValue) {\n                throwIfProxyReleased(isProxyReleased);\n                const [value, transferables] = toWireValue(rawValue);\n                return requestResponseMessage(ep, {\n                    type: "SET",\n                    path: [ ...path, prop ].map((p => p.toString())),\n                    value\n                }, transferables).then(fromWireValue);\n            },\n            apply(_target, _thisArg, rawArgumentList) {\n                throwIfProxyReleased(isProxyReleased);\n                const last = path[path.length - 1];\n                if (last === createEndpoint) {\n                    return requestResponseMessage(ep, {\n                        type: "ENDPOINT"\n                    }).then(fromWireValue);\n                }\n                if (last === "bind") {\n                    return createProxy(ep, path.slice(0, -1));\n                }\n                const [argumentList, transferables] = processArguments(rawArgumentList);\n                return requestResponseMessage(ep, {\n                    type: "APPLY",\n                    path: path.map((p => p.toString())),\n                    argumentList\n                }, transferables).then(fromWireValue);\n            },\n            construct(_target, rawArgumentList) {\n                throwIfProxyReleased(isProxyReleased);\n                const [argumentList, transferables] = processArguments(rawArgumentList);\n                return requestResponseMessage(ep, {\n                    type: "CONSTRUCT",\n                    path: path.map((p => p.toString())),\n                    argumentList\n                }, transferables).then(fromWireValue);\n            }\n        });\n        registerProxy(proxy, ep);\n        return proxy;\n    }\n    function myFlat(arr) {\n        return Array.prototype.concat.apply([], arr);\n    }\n    function processArguments(argumentList) {\n        const processed = argumentList.map(toWireValue);\n        return [ processed.map((v => v[0])), myFlat(processed.map((v => v[1]))) ];\n    }\n    const transferCache = new WeakMap;\n    function transfer(obj, transfers) {\n        transferCache.set(obj, transfers);\n        return obj;\n    }\n    function proxy(obj) {\n        return Object.assign(obj, {\n            [proxyMarker]: true\n        });\n    }\n    function windowEndpoint(w, context = globalThis, targetOrigin = "*") {\n        return {\n            postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n            addEventListener: context.addEventListener.bind(context),\n            removeEventListener: context.removeEventListener.bind(context)\n        };\n    }\n    function toWireValue(value) {\n        for (const [name, handler] of transferHandlers) {\n            if (handler.canHandle(value)) {\n                const [serializedValue, transferables] = handler.serialize(value);\n                return [ {\n                    type: "HANDLER",\n                    name,\n                    value: serializedValue\n                }, transferables ];\n            }\n        }\n        return [ {\n            type: "RAW",\n            value\n        }, transferCache.get(value) || [] ];\n    }\n    function fromWireValue(value) {\n        switch (value.type) {\n          case "HANDLER":\n            return transferHandlers.get(value.name).deserialize(value.value);\n\n          case "RAW":\n            return value.value;\n        }\n    }\n    function requestResponseMessage(ep, msg, transfers) {\n        return new Promise((resolve => {\n            const id = generateUUID();\n            ep.addEventListener("message", (function l(ev) {\n                if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                    return;\n                }\n                ep.removeEventListener("message", l);\n                resolve(ev.data);\n            }));\n            if (ep.start) {\n                ep.start();\n            }\n            ep.postMessage(Object.assign({\n                id\n            }, msg), transfers);\n        }));\n    }\n    function generateUUID() {\n        return new Array(4).fill(0).map((() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))).join("-");\n    }\n    var browser = __webpack_require__(227);\n    var browser_default = __webpack_require__.n(browser);\n    function getSharedMemoryAvailable() {\n        const globalScope = typeof window !== "undefined" ? window : globalThis;\n        return typeof SharedArrayBuffer !== "undefined" && globalScope.crossOriginIsolated;\n    }\n    function getRemoteBarretenbergWasm(worker) {\n        return wrap(worker);\n    }\n    function getNumCpu() {\n        return navigator.hardwareConcurrency;\n    }\n    function threadLogger() {\n        return undefined;\n    }\n    function killSelf() {\n        self.close();\n    }\n    var inline = __webpack_require__(477);\n    var inline_default = __webpack_require__.n(inline);\n    function Worker_fn() {\n        return inline_default()(\'/*! For license information please see thread.worker.worker.worker.js.LICENSE.txt */\\nvar __webpack_modules__ = {\\n    227: (module, exports, __webpack_require__) => {\\n        exports.formatArgs = formatArgs;\\n        exports.save = save;\\n        exports.load = load;\\n        exports.useColors = useColors;\\n        exports.storage = localstorage();\\n        exports.destroy = (() => {\\n            let warned = false;\\n            return () => {\\n                if (!warned) {\\n                    warned = true;\\n                    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");\\n                }\\n            };\\n        })();\\n        exports.colors = [ "#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33" ];\\n        function useColors() {\\n            if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {\\n                return true;\\n            }\\n            if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\\\/(\\\\d+)/)) {\\n                return false;\\n            }\\n            return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\\\/(\\\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\\\/(\\\\d+)/);\\n        }\\n        function formatArgs(args) {\\n            args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);\\n            if (!this.useColors) {\\n                return;\\n            }\\n            const c = "color: " + this.color;\\n            args.splice(1, 0, c, "color: inherit");\\n            let index = 0;\\n            let lastC = 0;\\n            args[0].replace(/%[a-zA-Z%]/g, (match => {\\n                if (match === "%%") {\\n                    return;\\n                }\\n                index++;\\n                if (match === "%c") {\\n                    lastC = index;\\n                }\\n            }));\\n            args.splice(lastC, 0, c);\\n        }\\n        exports.log = console.debug || console.log || (() => {});\\n        function save(namespaces) {\\n            try {\\n                if (namespaces) {\\n                    exports.storage.setItem("debug", namespaces);\\n                } else {\\n                    exports.storage.removeItem("debug");\\n                }\\n            } catch (error) {}\\n        }\\n        function load() {\\n            let r;\\n            try {\\n                r = exports.storage.getItem("debug");\\n            } catch (error) {}\\n            if (!r && typeof process !== "undefined" && "env" in process) {\\n                r = process.env.DEBUG;\\n            }\\n            return r;\\n        }\\n        function localstorage() {\\n            try {\\n                return localStorage;\\n            } catch (error) {}\\n        }\\n        module.exports = __webpack_require__(447)(exports);\\n        const {formatters} = module.exports;\\n        formatters.j = function(v) {\\n            try {\\n                return JSON.stringify(v);\\n            } catch (error) {\\n                return "[UnexpectedJSONParseError]: " + error.message;\\n            }\\n        };\\n    },\\n    447: (module, __unused_webpack_exports, __webpack_require__) => {\\n        function setup(env) {\\n            createDebug.debug = createDebug;\\n            createDebug.default = createDebug;\\n            createDebug.coerce = coerce;\\n            createDebug.disable = disable;\\n            createDebug.enable = enable;\\n            createDebug.enabled = enabled;\\n            createDebug.humanize = __webpack_require__(824);\\n            createDebug.destroy = destroy;\\n            Object.keys(env).forEach((key => {\\n                createDebug[key] = env[key];\\n            }));\\n            createDebug.names = [];\\n            createDebug.skips = [];\\n            createDebug.formatters = {};\\n            function selectColor(namespace) {\\n                let hash = 0;\\n                for (let i = 0; i < namespace.length; i++) {\\n                    hash = (hash << 5) - hash + namespace.charCodeAt(i);\\n                    hash |= 0;\\n                }\\n                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\\n            }\\n            createDebug.selectColor = selectColor;\\n            function createDebug(namespace) {\\n                let prevTime;\\n                let enableOverride = null;\\n                let namespacesCache;\\n                let enabledCache;\\n                function debug(...args) {\\n                    if (!debug.enabled) {\\n                        return;\\n                    }\\n                    const self = debug;\\n                    const curr = Number(new Date);\\n                    const ms = curr - (prevTime || curr);\\n                    self.diff = ms;\\n                    self.prev = prevTime;\\n                    self.curr = curr;\\n                    prevTime = curr;\\n                    args[0] = createDebug.coerce(args[0]);\\n                    if (typeof args[0] !== "string") {\\n                        args.unshift("%O");\\n                    }\\n                    let index = 0;\\n                    args[0] = args[0].replace(/%([a-zA-Z%])/g, ((match, format) => {\\n                        if (match === "%%") {\\n                            return "%";\\n                        }\\n                        index++;\\n                        const formatter = createDebug.formatters[format];\\n                        if (typeof formatter === "function") {\\n                            const val = args[index];\\n                            match = formatter.call(self, val);\\n                            args.splice(index, 1);\\n                            index--;\\n                        }\\n                        return match;\\n                    }));\\n                    createDebug.formatArgs.call(self, args);\\n                    const logFn = self.log || createDebug.log;\\n                    logFn.apply(self, args);\\n                }\\n                debug.namespace = namespace;\\n                debug.useColors = createDebug.useColors();\\n                debug.color = createDebug.selectColor(namespace);\\n                debug.extend = extend;\\n                debug.destroy = createDebug.destroy;\\n                Object.defineProperty(debug, "enabled", {\\n                    enumerable: true,\\n                    configurable: false,\\n                    get: () => {\\n                        if (enableOverride !== null) {\\n                            return enableOverride;\\n                        }\\n                        if (namespacesCache !== createDebug.namespaces) {\\n                            namespacesCache = createDebug.namespaces;\\n                            enabledCache = createDebug.enabled(namespace);\\n                        }\\n                        return enabledCache;\\n                    },\\n                    set: v => {\\n                        enableOverride = v;\\n                    }\\n                });\\n                if (typeof createDebug.init === "function") {\\n                    createDebug.init(debug);\\n                }\\n                return debug;\\n            }\\n            function extend(namespace, delimiter) {\\n                const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);\\n                newDebug.log = this.log;\\n                return newDebug;\\n            }\\n            function enable(namespaces) {\\n                createDebug.save(namespaces);\\n                createDebug.namespaces = namespaces;\\n                createDebug.names = [];\\n                createDebug.skips = [];\\n                let i;\\n                const split = (typeof namespaces === "string" ? namespaces : "").split(/[\\\\s,]+/);\\n                const len = split.length;\\n                for (i = 0; i < len; i++) {\\n                    if (!split[i]) {\\n                        continue;\\n                    }\\n                    namespaces = split[i].replace(/\\\\*/g, ".*?");\\n                    if (namespaces[0] === "-") {\\n                        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));\\n                    } else {\\n                        createDebug.names.push(new RegExp("^" + namespaces + "$"));\\n                    }\\n                }\\n            }\\n            function disable() {\\n                const namespaces = [ ...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace => "-" + namespace)) ].join(",");\\n                createDebug.enable("");\\n                return namespaces;\\n            }\\n            function enabled(name) {\\n                if (name[name.length - 1] === "*") {\\n                    return true;\\n                }\\n                let i;\\n                let len;\\n                for (i = 0, len = createDebug.skips.length; i < len; i++) {\\n                    if (createDebug.skips[i].test(name)) {\\n                        return false;\\n                    }\\n                }\\n                for (i = 0, len = createDebug.names.length; i < len; i++) {\\n                    if (createDebug.names[i].test(name)) {\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            function toNamespace(regexp) {\\n                return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\\\.\\\\*\\\\?$/, "*");\\n            }\\n            function coerce(val) {\\n                if (val instanceof Error) {\\n                    return val.stack || val.message;\\n                }\\n                return val;\\n            }\\n            function destroy() {\\n                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");\\n            }\\n            createDebug.enable(createDebug.load());\\n            return createDebug;\\n        }\\n        module.exports = setup;\\n    },\\n    824: module => {\\n        var s = 1e3;\\n        var m = s * 60;\\n        var h = m * 60;\\n        var d = h * 24;\\n        var w = d * 7;\\n        var y = d * 365.25;\\n        module.exports = function(val, options) {\\n            options = options || {};\\n            var type = typeof val;\\n            if (type === "string" && val.length > 0) {\\n                return parse(val);\\n            } else if (type === "number" && isFinite(val)) {\\n                return options.long ? fmtLong(val) : fmtShort(val);\\n            }\\n            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));\\n        };\\n        function parse(str) {\\n            str = String(str);\\n            if (str.length > 100) {\\n                return;\\n            }\\n            var match = /^(-?(?:\\\\d+)?\\\\.?\\\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\\n            if (!match) {\\n                return;\\n            }\\n            var n = parseFloat(match[1]);\\n            var type = (match[2] || "ms").toLowerCase();\\n            switch (type) {\\n              case "years":\\n              case "year":\\n              case "yrs":\\n              case "yr":\\n              case "y":\\n                return n * y;\\n\\n              case "weeks":\\n              case "week":\\n              case "w":\\n                return n * w;\\n\\n              case "days":\\n              case "day":\\n              case "d":\\n                return n * d;\\n\\n              case "hours":\\n              case "hour":\\n              case "hrs":\\n              case "hr":\\n              case "h":\\n                return n * h;\\n\\n              case "minutes":\\n              case "minute":\\n              case "mins":\\n              case "min":\\n              case "m":\\n                return n * m;\\n\\n              case "seconds":\\n              case "second":\\n              case "secs":\\n              case "sec":\\n              case "s":\\n                return n * s;\\n\\n              case "milliseconds":\\n              case "millisecond":\\n              case "msecs":\\n              case "msec":\\n              case "ms":\\n                return n;\\n\\n              default:\\n                return undefined;\\n            }\\n        }\\n        function fmtShort(ms) {\\n            var msAbs = Math.abs(ms);\\n            if (msAbs >= d) {\\n                return Math.round(ms / d) + "d";\\n            }\\n            if (msAbs >= h) {\\n                return Math.round(ms / h) + "h";\\n            }\\n            if (msAbs >= m) {\\n                return Math.round(ms / m) + "m";\\n            }\\n            if (msAbs >= s) {\\n                return Math.round(ms / s) + "s";\\n            }\\n            return ms + "ms";\\n        }\\n        function fmtLong(ms) {\\n            var msAbs = Math.abs(ms);\\n            if (msAbs >= d) {\\n                return plural(ms, msAbs, d, "day");\\n            }\\n            if (msAbs >= h) {\\n                return plural(ms, msAbs, h, "hour");\\n            }\\n            if (msAbs >= m) {\\n                return plural(ms, msAbs, m, "minute");\\n            }\\n            if (msAbs >= s) {\\n                return plural(ms, msAbs, s, "second");\\n            }\\n            return ms + " ms";\\n        }\\n        function plural(ms, msAbs, n, name) {\\n            var isPlural = msAbs >= n * 1.5;\\n            return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");\\n        }\\n    }\\n};\\n\\nvar __webpack_module_cache__ = {};\\n\\nfunction __webpack_require__(moduleId) {\\n    var cachedModule = __webpack_module_cache__[moduleId];\\n    if (cachedModule !== undefined) {\\n        return cachedModule.exports;\\n    }\\n    var module = __webpack_module_cache__[moduleId] = {\\n        exports: {}\\n    };\\n    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\\n    return module.exports;\\n}\\n\\n(() => {\\n    __webpack_require__.n = module => {\\n        var getter = module && module.__esModule ? () => module["default"] : () => module;\\n        __webpack_require__.d(getter, {\\n            a: getter\\n        });\\n        return getter;\\n    };\\n})();\\n\\n(() => {\\n    __webpack_require__.d = (exports, definition) => {\\n        for (var key in definition) {\\n            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\\n                Object.defineProperty(exports, key, {\\n                    enumerable: true,\\n                    get: definition[key]\\n                });\\n            }\\n        }\\n    };\\n})();\\n\\n(() => {\\n    __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\\n})();\\n\\nvar __webpack_exports__ = {};\\n\\n(() => {\\n    const proxyMarker = Symbol("Comlink.proxy");\\n    const createEndpoint = Symbol("Comlink.endpoint");\\n    const releaseProxy = Symbol("Comlink.releaseProxy");\\n    const finalizer = Symbol("Comlink.finalizer");\\n    const throwMarker = Symbol("Comlink.thrown");\\n    const isObject = val => typeof val === "object" && val !== null || typeof val === "function";\\n    const proxyTransferHandler = {\\n        canHandle: val => isObject(val) && val[proxyMarker],\\n        serialize(obj) {\\n            const {port1, port2} = new MessageChannel;\\n            expose(obj, port1);\\n            return [ port2, [ port2 ] ];\\n        },\\n        deserialize(port) {\\n            port.start();\\n            return comlink_wrap(port);\\n        }\\n    };\\n    const throwTransferHandler = {\\n        canHandle: value => isObject(value) && throwMarker in value,\\n        serialize({value}) {\\n            let serialized;\\n            if (value instanceof Error) {\\n                serialized = {\\n                    isError: true,\\n                    value: {\\n                        message: value.message,\\n                        name: value.name,\\n                        stack: value.stack\\n                    }\\n                };\\n            } else {\\n                serialized = {\\n                    isError: false,\\n                    value\\n                };\\n            }\\n            return [ serialized, [] ];\\n        },\\n        deserialize(serialized) {\\n            if (serialized.isError) {\\n                throw Object.assign(new Error(serialized.value.message), serialized.value);\\n            }\\n            throw serialized.value;\\n        }\\n    };\\n    const transferHandlers = new Map([ [ "proxy", proxyTransferHandler ], [ "throw", throwTransferHandler ] ]);\\n    function isAllowedOrigin(allowedOrigins, origin) {\\n        for (const allowedOrigin of allowedOrigins) {\\n            if (origin === allowedOrigin || allowedOrigin === "*") {\\n                return true;\\n            }\\n            if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    function expose(obj, ep = globalThis, allowedOrigins = [ "*" ]) {\\n        ep.addEventListener("message", (function callback(ev) {\\n            if (!ev || !ev.data) {\\n                return;\\n            }\\n            if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\\n                console.warn(`Invalid origin \\\'${ev.origin}\\\' for comlink proxy`);\\n                return;\\n            }\\n            const {id, type, path} = Object.assign({\\n                path: []\\n            }, ev.data);\\n            const argumentList = (ev.data.argumentList || []).map(fromWireValue);\\n            let returnValue;\\n            try {\\n                const parent = path.slice(0, -1).reduce(((obj, prop) => obj[prop]), obj);\\n                const rawValue = path.reduce(((obj, prop) => obj[prop]), obj);\\n                switch (type) {\\n                  case "GET":\\n                    {\\n                        returnValue = rawValue;\\n                    }\\n                    break;\\n\\n                  case "SET":\\n                    {\\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\\n                        returnValue = true;\\n                    }\\n                    break;\\n\\n                  case "APPLY":\\n                    {\\n                        returnValue = rawValue.apply(parent, argumentList);\\n                    }\\n                    break;\\n\\n                  case "CONSTRUCT":\\n                    {\\n                        const value = new rawValue(...argumentList);\\n                        returnValue = proxy(value);\\n                    }\\n                    break;\\n\\n                  case "ENDPOINT":\\n                    {\\n                        const {port1, port2} = new MessageChannel;\\n                        expose(obj, port2);\\n                        returnValue = transfer(port1, [ port1 ]);\\n                    }\\n                    break;\\n\\n                  case "RELEASE":\\n                    {\\n                        returnValue = undefined;\\n                    }\\n                    break;\\n\\n                  default:\\n                    return;\\n                }\\n            } catch (value) {\\n                returnValue = {\\n                    value,\\n                    [throwMarker]: 0\\n                };\\n            }\\n            Promise.resolve(returnValue).catch((value => ({\\n                value,\\n                [throwMarker]: 0\\n            }))).then((returnValue => {\\n                const [wireValue, transferables] = toWireValue(returnValue);\\n                ep.postMessage(Object.assign(Object.assign({}, wireValue), {\\n                    id\\n                }), transferables);\\n                if (type === "RELEASE") {\\n                    ep.removeEventListener("message", callback);\\n                    closeEndPoint(ep);\\n                    if (finalizer in obj && typeof obj[finalizer] === "function") {\\n                        obj[finalizer]();\\n                    }\\n                }\\n            })).catch((error => {\\n                const [wireValue, transferables] = toWireValue({\\n                    value: new TypeError("Unserializable return value"),\\n                    [throwMarker]: 0\\n                });\\n                ep.postMessage(Object.assign(Object.assign({}, wireValue), {\\n                    id\\n                }), transferables);\\n            }));\\n        }));\\n        if (ep.start) {\\n            ep.start();\\n        }\\n    }\\n    function isMessagePort(endpoint) {\\n        return endpoint.constructor.name === "MessagePort";\\n    }\\n    function closeEndPoint(endpoint) {\\n        if (isMessagePort(endpoint)) endpoint.close();\\n    }\\n    function comlink_wrap(ep, target) {\\n        return createProxy(ep, [], target);\\n    }\\n    function throwIfProxyReleased(isReleased) {\\n        if (isReleased) {\\n            throw new Error("Proxy has been released and is not useable");\\n        }\\n    }\\n    function releaseEndpoint(ep) {\\n        return requestResponseMessage(ep, {\\n            type: "RELEASE"\\n        }).then((() => {\\n            closeEndPoint(ep);\\n        }));\\n    }\\n    const proxyCounter = new WeakMap;\\n    const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep => {\\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\\n        proxyCounter.set(ep, newCount);\\n        if (newCount === 0) {\\n            releaseEndpoint(ep);\\n        }\\n    }));\\n    function registerProxy(proxy, ep) {\\n        const newCount = (proxyCounter.get(ep) || 0) + 1;\\n        proxyCounter.set(ep, newCount);\\n        if (proxyFinalizers) {\\n            proxyFinalizers.register(proxy, ep, proxy);\\n        }\\n    }\\n    function unregisterProxy(proxy) {\\n        if (proxyFinalizers) {\\n            proxyFinalizers.unregister(proxy);\\n        }\\n    }\\n    function createProxy(ep, path = [], target = function() {}) {\\n        let isProxyReleased = false;\\n        const proxy = new Proxy(target, {\\n            get(_target, prop) {\\n                throwIfProxyReleased(isProxyReleased);\\n                if (prop === releaseProxy) {\\n                    return () => {\\n                        unregisterProxy(proxy);\\n                        releaseEndpoint(ep);\\n                        isProxyReleased = true;\\n                    };\\n                }\\n                if (prop === "then") {\\n                    if (path.length === 0) {\\n                        return {\\n                            then: () => proxy\\n                        };\\n                    }\\n                    const r = requestResponseMessage(ep, {\\n                        type: "GET",\\n                        path: path.map((p => p.toString()))\\n                    }).then(fromWireValue);\\n                    return r.then.bind(r);\\n                }\\n                return createProxy(ep, [ ...path, prop ]);\\n            },\\n            set(_target, prop, rawValue) {\\n                throwIfProxyReleased(isProxyReleased);\\n                const [value, transferables] = toWireValue(rawValue);\\n                return requestResponseMessage(ep, {\\n                    type: "SET",\\n                    path: [ ...path, prop ].map((p => p.toString())),\\n                    value\\n                }, transferables).then(fromWireValue);\\n            },\\n            apply(_target, _thisArg, rawArgumentList) {\\n                throwIfProxyReleased(isProxyReleased);\\n                const last = path[path.length - 1];\\n                if (last === createEndpoint) {\\n                    return requestResponseMessage(ep, {\\n                        type: "ENDPOINT"\\n                    }).then(fromWireValue);\\n                }\\n                if (last === "bind") {\\n                    return createProxy(ep, path.slice(0, -1));\\n                }\\n                const [argumentList, transferables] = processArguments(rawArgumentList);\\n                return requestResponseMessage(ep, {\\n                    type: "APPLY",\\n                    path: path.map((p => p.toString())),\\n                    argumentList\\n                }, transferables).then(fromWireValue);\\n            },\\n            construct(_target, rawArgumentList) {\\n                throwIfProxyReleased(isProxyReleased);\\n                const [argumentList, transferables] = processArguments(rawArgumentList);\\n                return requestResponseMessage(ep, {\\n                    type: "CONSTRUCT",\\n                    path: path.map((p => p.toString())),\\n                    argumentList\\n                }, transferables).then(fromWireValue);\\n            }\\n        });\\n        registerProxy(proxy, ep);\\n        return proxy;\\n    }\\n    function myFlat(arr) {\\n        return Array.prototype.concat.apply([], arr);\\n    }\\n    function processArguments(argumentList) {\\n        const processed = argumentList.map(toWireValue);\\n        return [ processed.map((v => v[0])), myFlat(processed.map((v => v[1]))) ];\\n    }\\n    const transferCache = new WeakMap;\\n    function transfer(obj, transfers) {\\n        transferCache.set(obj, transfers);\\n        return obj;\\n    }\\n    function proxy(obj) {\\n        return Object.assign(obj, {\\n            [proxyMarker]: true\\n        });\\n    }\\n    function windowEndpoint(w, context = globalThis, targetOrigin = "*") {\\n        return {\\n            postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\\n            addEventListener: context.addEventListener.bind(context),\\n            removeEventListener: context.removeEventListener.bind(context)\\n        };\\n    }\\n    function toWireValue(value) {\\n        for (const [name, handler] of transferHandlers) {\\n            if (handler.canHandle(value)) {\\n                const [serializedValue, transferables] = handler.serialize(value);\\n                return [ {\\n                    type: "HANDLER",\\n                    name,\\n                    value: serializedValue\\n                }, transferables ];\\n            }\\n        }\\n        return [ {\\n            type: "RAW",\\n            value\\n        }, transferCache.get(value) || [] ];\\n    }\\n    function fromWireValue(value) {\\n        switch (value.type) {\\n          case "HANDLER":\\n            return transferHandlers.get(value.name).deserialize(value.value);\\n\\n          case "RAW":\\n            return value.value;\\n        }\\n    }\\n    function requestResponseMessage(ep, msg, transfers) {\\n        return new Promise((resolve => {\\n            const id = generateUUID();\\n            ep.addEventListener("message", (function l(ev) {\\n                if (!ev.data || !ev.data.id || ev.data.id !== id) {\\n                    return;\\n                }\\n                ep.removeEventListener("message", l);\\n                resolve(ev.data);\\n            }));\\n            if (ep.start) {\\n                ep.start();\\n            }\\n            ep.postMessage(Object.assign({\\n                id\\n            }, msg), transfers);\\n        }));\\n    }\\n    function generateUUID() {\\n        return new Array(4).fill(0).map((() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))).join("-");\\n    }\\n    function getSharedMemoryAvailable() {\\n        const globalScope = typeof window !== "undefined" ? window : globalThis;\\n        return typeof SharedArrayBuffer !== "undefined" && globalScope.crossOriginIsolated;\\n    }\\n    function getRemoteBarretenbergWasm(worker) {\\n        return wrap(worker);\\n    }\\n    function getNumCpu() {\\n        return navigator.hardwareConcurrency;\\n    }\\n    function threadLogger() {\\n        return undefined;\\n    }\\n    function killSelf() {\\n        self.close();\\n    }\\n    var browser = __webpack_require__(227);\\n    var browser_default = __webpack_require__.n(browser);\\n    const randomBytes = len => {\\n        const getWebCrypto = () => {\\n            if (typeof window !== "undefined" && window.crypto) return window.crypto;\\n            if (typeof globalThis !== "undefined" && globalThis.crypto) return globalThis.crypto;\\n            return undefined;\\n        };\\n        const crypto = getWebCrypto();\\n        if (!crypto) {\\n            throw new Error("randomBytes UnsupportedEnvironment");\\n        }\\n        const buf = new Uint8Array(len);\\n        const MAX_BYTES = 65536;\\n        if (len > MAX_BYTES) {\\n            for (let generated = 0; generated < len; generated += MAX_BYTES) {\\n                crypto.getRandomValues(buf.subarray(generated, generated + MAX_BYTES));\\n            }\\n        } else {\\n            crypto.getRandomValues(buf);\\n        }\\n        return buf;\\n    };\\n    class BarretenbergWasmBase {\\n        constructor() {\\n            this.memStore = {};\\n            this.logger = browser_default()("bb.js:bb_wasm_base");\\n        }\\n        getImportObj(memory) {\\n            const importObj = {\\n                wasi_snapshot_preview1: {\\n                    random_get: (out, length) => {\\n                        out = out >>> 0;\\n                        const randomData = randomBytes(length);\\n                        const mem = this.getMemory();\\n                        mem.set(randomData, out);\\n                    },\\n                    clock_time_get: (a1, a2, out) => {\\n                        out = out >>> 0;\\n                        const ts = BigInt((new Date).getTime()) * 1000000n;\\n                        const view = new DataView(this.getMemory().buffer);\\n                        view.setBigUint64(out, ts, true);\\n                    },\\n                    proc_exit: () => {\\n                        this.logger("PANIC: proc_exit was called.");\\n                        throw new Error;\\n                    }\\n                },\\n                env: {\\n                    logstr: addr => {\\n                        const str = this.stringFromAddress(addr);\\n                        const m = this.getMemory();\\n                        const str2 = `${str} (mem: ${(m.length / (1024 * 1024)).toFixed(2)}MiB)`;\\n                        this.logger(str2);\\n                    },\\n                    get_data: (keyAddr, outBufAddr) => {\\n                        const key = this.stringFromAddress(keyAddr);\\n                        outBufAddr = outBufAddr >>> 0;\\n                        const data = this.memStore[key];\\n                        if (!data) {\\n                            this.logger(`get_data miss ${key}`);\\n                            return;\\n                        }\\n                        this.writeMemory(outBufAddr, data);\\n                    },\\n                    set_data: (keyAddr, dataAddr, dataLength) => {\\n                        const key = this.stringFromAddress(keyAddr);\\n                        dataAddr = dataAddr >>> 0;\\n                        this.memStore[key] = this.getMemorySlice(dataAddr, dataAddr + dataLength);\\n                    },\\n                    memory\\n                }\\n            };\\n            return importObj;\\n        }\\n        exports() {\\n            return this.instance.exports;\\n        }\\n        call(name, ...args) {\\n            if (!this.exports()[name]) {\\n                throw new Error(`WASM function ${name} not found.`);\\n            }\\n            try {\\n                return this.exports()[name](...args) >>> 0;\\n            } catch (err) {\\n                const message = `WASM function ${name} aborted, error: ${err}`;\\n                this.logger(message);\\n                this.logger(err.stack);\\n                throw err;\\n            }\\n        }\\n        memSize() {\\n            return this.getMemory().length;\\n        }\\n        getMemorySlice(start, end) {\\n            return this.getMemory().subarray(start, end).slice();\\n        }\\n        writeMemory(offset, arr) {\\n            const mem = this.getMemory();\\n            mem.set(arr, offset);\\n        }\\n        getMemory() {\\n            return new Uint8Array(this.memory.buffer);\\n        }\\n        stringFromAddress(addr) {\\n            addr = addr >>> 0;\\n            const m = this.getMemory();\\n            let i = addr;\\n            for (;m[i] !== 0; ++i) ;\\n            const textDecoder = new TextDecoder("ascii");\\n            return textDecoder.decode(m.slice(addr, i));\\n        }\\n    }\\n    class BarretenbergWasmThread extends BarretenbergWasmBase {\\n        async initThread(module, memory) {\\n            this.logger = threadLogger() || this.logger;\\n            this.memory = memory;\\n            this.instance = await WebAssembly.instantiate(module, this.getImportObj(this.memory));\\n        }\\n        destroy() {\\n            killSelf();\\n        }\\n        getImportObj(memory) {\\n            const baseImports = super.getImportObj(memory);\\n            return {\\n                ...baseImports,\\n                wasi: {\\n                    "thread-spawn": () => {\\n                        this.logger("PANIC: threads cannot spawn threads!");\\n                        this.logger((new Error).stack);\\n                        killSelf();\\n                    }\\n                },\\n                env: {\\n                    ...baseImports.env,\\n                    env_hardware_concurrency: () => 1\\n                }\\n            };\\n        }\\n    }\\n    self.onmessage = function(e) {\\n        if (e.data.debug) {\\n            browser_default().enable(e.data.debug);\\n        }\\n    };\\n    expose(new BarretenbergWasmThread);\\n    self.postMessage({\\n        ready: true\\n    });\\n    const thread_worker = null;\\n})();\', "Worker", undefined, undefined);\n    }\n    function createThreadWorker() {\n        const worker = new Worker_fn;\n        const debugStr = browser_default().disable();\n        browser_default().enable(debugStr);\n        worker.postMessage({\n            debug: debugStr\n        });\n        return worker;\n    }\n    const randomBytes = len => {\n        const getWebCrypto = () => {\n            if (typeof window !== "undefined" && window.crypto) return window.crypto;\n            if (typeof globalThis !== "undefined" && globalThis.crypto) return globalThis.crypto;\n            return undefined;\n        };\n        const crypto = getWebCrypto();\n        if (!crypto) {\n            throw new Error("randomBytes UnsupportedEnvironment");\n        }\n        const buf = new Uint8Array(len);\n        const MAX_BYTES = 65536;\n        if (len > MAX_BYTES) {\n            for (let generated = 0; generated < len; generated += MAX_BYTES) {\n                crypto.getRandomValues(buf.subarray(generated, generated + MAX_BYTES));\n            }\n        } else {\n            crypto.getRandomValues(buf);\n        }\n        return buf;\n    };\n    class BarretenbergWasmBase {\n        constructor() {\n            this.memStore = {};\n            this.logger = browser_default()("bb.js:bb_wasm_base");\n        }\n        getImportObj(memory) {\n            const importObj = {\n                wasi_snapshot_preview1: {\n                    random_get: (out, length) => {\n                        out = out >>> 0;\n                        const randomData = randomBytes(length);\n                        const mem = this.getMemory();\n                        mem.set(randomData, out);\n                    },\n                    clock_time_get: (a1, a2, out) => {\n                        out = out >>> 0;\n                        const ts = BigInt((new Date).getTime()) * 1000000n;\n                        const view = new DataView(this.getMemory().buffer);\n                        view.setBigUint64(out, ts, true);\n                    },\n                    proc_exit: () => {\n                        this.logger("PANIC: proc_exit was called.");\n                        throw new Error;\n                    }\n                },\n                env: {\n                    logstr: addr => {\n                        const str = this.stringFromAddress(addr);\n                        const m = this.getMemory();\n                        const str2 = `${str} (mem: ${(m.length / (1024 * 1024)).toFixed(2)}MiB)`;\n                        this.logger(str2);\n                    },\n                    get_data: (keyAddr, outBufAddr) => {\n                        const key = this.stringFromAddress(keyAddr);\n                        outBufAddr = outBufAddr >>> 0;\n                        const data = this.memStore[key];\n                        if (!data) {\n                            this.logger(`get_data miss ${key}`);\n                            return;\n                        }\n                        this.writeMemory(outBufAddr, data);\n                    },\n                    set_data: (keyAddr, dataAddr, dataLength) => {\n                        const key = this.stringFromAddress(keyAddr);\n                        dataAddr = dataAddr >>> 0;\n                        this.memStore[key] = this.getMemorySlice(dataAddr, dataAddr + dataLength);\n                    },\n                    memory\n                }\n            };\n            return importObj;\n        }\n        exports() {\n            return this.instance.exports;\n        }\n        call(name, ...args) {\n            if (!this.exports()[name]) {\n                throw new Error(`WASM function ${name} not found.`);\n            }\n            try {\n                return this.exports()[name](...args) >>> 0;\n            } catch (err) {\n                const message = `WASM function ${name} aborted, error: ${err}`;\n                this.logger(message);\n                this.logger(err.stack);\n                throw err;\n            }\n        }\n        memSize() {\n            return this.getMemory().length;\n        }\n        getMemorySlice(start, end) {\n            return this.getMemory().subarray(start, end).slice();\n        }\n        writeMemory(offset, arr) {\n            const mem = this.getMemory();\n            mem.set(arr, offset);\n        }\n        getMemory() {\n            return new Uint8Array(this.memory.buffer);\n        }\n        stringFromAddress(addr) {\n            addr = addr >>> 0;\n            const m = this.getMemory();\n            let i = addr;\n            for (;m[i] !== 0; ++i) ;\n            const textDecoder = new TextDecoder("ascii");\n            return textDecoder.decode(m.slice(addr, i));\n        }\n    }\n    class HeapAllocator {\n        constructor(wasm) {\n            this.wasm = wasm;\n            this.allocs = [];\n            this.inScratchRemaining = 1024;\n            this.outScratchRemaining = 1024;\n        }\n        getInputs(buffers) {\n            return buffers.map((bufOrNum => {\n                if (typeof bufOrNum === "object") {\n                    if (bufOrNum.length <= this.inScratchRemaining) {\n                        const ptr = this.inScratchRemaining -= bufOrNum.length;\n                        this.wasm.writeMemory(ptr, bufOrNum);\n                        return ptr;\n                    } else {\n                        const ptr = this.wasm.call("bbmalloc", bufOrNum.length);\n                        this.wasm.writeMemory(ptr, bufOrNum);\n                        this.allocs.push(ptr);\n                        return ptr;\n                    }\n                } else {\n                    return bufOrNum;\n                }\n            }));\n        }\n        getOutputPtrs(outLens) {\n            return outLens.map((len => {\n                const size = len || 4;\n                if (size <= this.outScratchRemaining) {\n                    return this.outScratchRemaining -= size;\n                } else {\n                    const ptr = this.wasm.call("bbmalloc", size);\n                    this.allocs.push(ptr);\n                    return ptr;\n                }\n            }));\n        }\n        addOutputPtr(ptr) {\n            if (ptr >= 1024) {\n                this.allocs.push(ptr);\n            }\n        }\n        freeAll() {\n            for (const ptr of this.allocs) {\n                this.wasm.call("bbfree", ptr);\n            }\n        }\n    }\n    class BarretenbergWasmMain extends BarretenbergWasmBase {\n        constructor() {\n            super(...arguments);\n            this.workers = [];\n            this.remoteWasms = [];\n            this.nextWorker = 0;\n            this.nextThreadId = 1;\n        }\n        getNumThreads() {\n            return this.workers.length + 1;\n        }\n        async init(module, threads = Math.min(getNumCpu(), BarretenbergWasmMain.MAX_THREADS), logger = browser_default()("bb.js:bb_wasm"), initial = 32, maximum = 2 ** 16) {\n            this.logger = logger;\n            const initialMb = initial * 2 ** 16 / (1024 * 1024);\n            const maxMb = maximum * 2 ** 16 / (1024 * 1024);\n            const shared = getSharedMemoryAvailable();\n            this.logger(`Initializing bb wasm: initial memory ${initial} pages ${initialMb}MiB; ` + `max memory: ${maximum} pages, ${maxMb}MiB; ` + `threads: ${threads}; shared memory: ${shared}`);\n            this.memory = new WebAssembly.Memory({\n                initial,\n                maximum,\n                shared\n            });\n            const instance = await WebAssembly.instantiate(module, this.getImportObj(this.memory));\n            this.instance = instance;\n            this.call("_initialize");\n            if (threads > 1) {\n                this.logger(`Creating ${threads} worker threads`);\n                this.workers = await Promise.all(Array.from({\n                    length: threads - 1\n                }).map(createThreadWorker));\n                this.remoteWasms = await Promise.all(this.workers.map(getRemoteBarretenbergWasm));\n                await Promise.all(this.remoteWasms.map((w => w.initThread(module, this.memory))));\n            }\n        }\n        async destroy() {\n            await Promise.all(this.workers.map((w => w.terminate())));\n        }\n        getImportObj(memory) {\n            const baseImports = super.getImportObj(memory);\n            return {\n                ...baseImports,\n                wasi: {\n                    "thread-spawn": arg => {\n                        arg = arg >>> 0;\n                        const id = this.nextThreadId++;\n                        const worker = this.nextWorker++ % this.remoteWasms.length;\n                        this.remoteWasms[worker].call("wasi_thread_start", id, arg).catch(this.logger);\n                        return id;\n                    }\n                },\n                env: {\n                    ...baseImports.env,\n                    env_hardware_concurrency: () => this.remoteWasms.length + 1\n                }\n            };\n        }\n        callWasmExport(funcName, inArgs, outLens) {\n            const alloc = new HeapAllocator(this);\n            const inPtrs = alloc.getInputs(inArgs);\n            const outPtrs = alloc.getOutputPtrs(outLens);\n            this.call(funcName, ...inPtrs, ...outPtrs);\n            const outArgs = this.getOutputArgs(outLens, outPtrs, alloc);\n            alloc.freeAll();\n            return outArgs;\n        }\n        getOutputArgs(outLens, outPtrs, alloc) {\n            return outLens.map(((len, i) => {\n                if (len) {\n                    return this.getMemorySlice(outPtrs[i], outPtrs[i] + len);\n                }\n                const slice = this.getMemorySlice(outPtrs[i], outPtrs[i] + 4);\n                const ptr = new DataView(slice.buffer, slice.byteOffset, slice.byteLength).getUint32(0, true);\n                alloc.addOutputPtr(ptr);\n                const lslice = this.getMemorySlice(ptr, ptr + 4);\n                const length = new DataView(lslice.buffer, lslice.byteOffset, lslice.byteLength).getUint32(0, false);\n                return this.getMemorySlice(ptr + 4, ptr + 4 + length);\n            }));\n        }\n    }\n    BarretenbergWasmMain.MAX_THREADS = 32;\n    self.onmessage = function(e) {\n        if (e.data.debug) {\n            browser_default().enable(e.data.debug);\n        }\n    };\n    expose(new BarretenbergWasmMain);\n    self.postMessage({\n        ready: true\n    });\n    const main_worker = null;\n})();', "Worker", undefined, undefined);
    }
    function browser_createMainWorker() {
        const worker = new Worker_fn;
        const debugStr = browser_default().disable();
        browser_default().enable(debugStr);
        worker.postMessage({
            debug: debugStr
        });
        return worker;
    }
    function getSharedMemoryAvailable() {
        const globalScope = typeof window !== "undefined" ? window : globalThis;
        return typeof SharedArrayBuffer !== "undefined" && globalScope.crossOriginIsolated;
    }
    function browser_getRemoteBarretenbergWasm(worker) {
        return wrap(worker);
    }
    function getNumCpu() {
        return navigator.hardwareConcurrency;
    }
    function threadLogger() {
        return undefined;
    }
    function killSelf() {
        self.close();
    }
    function thread_worker_Worker_fn() {
        return inline_default()('/*! For license information please see thread.worker.worker.js.LICENSE.txt */\nvar __webpack_modules__ = {\n    227: (module, exports, __webpack_require__) => {\n        exports.formatArgs = formatArgs;\n        exports.save = save;\n        exports.load = load;\n        exports.useColors = useColors;\n        exports.storage = localstorage();\n        exports.destroy = (() => {\n            let warned = false;\n            return () => {\n                if (!warned) {\n                    warned = true;\n                    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");\n                }\n            };\n        })();\n        exports.colors = [ "#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33" ];\n        function useColors() {\n            if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {\n                return true;\n            }\n            if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n                return false;\n            }\n            return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n        }\n        function formatArgs(args) {\n            args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);\n            if (!this.useColors) {\n                return;\n            }\n            const c = "color: " + this.color;\n            args.splice(1, 0, c, "color: inherit");\n            let index = 0;\n            let lastC = 0;\n            args[0].replace(/%[a-zA-Z%]/g, (match => {\n                if (match === "%%") {\n                    return;\n                }\n                index++;\n                if (match === "%c") {\n                    lastC = index;\n                }\n            }));\n            args.splice(lastC, 0, c);\n        }\n        exports.log = console.debug || console.log || (() => {});\n        function save(namespaces) {\n            try {\n                if (namespaces) {\n                    exports.storage.setItem("debug", namespaces);\n                } else {\n                    exports.storage.removeItem("debug");\n                }\n            } catch (error) {}\n        }\n        function load() {\n            let r;\n            try {\n                r = exports.storage.getItem("debug");\n            } catch (error) {}\n            if (!r && typeof process !== "undefined" && "env" in process) {\n                r = process.env.DEBUG;\n            }\n            return r;\n        }\n        function localstorage() {\n            try {\n                return localStorage;\n            } catch (error) {}\n        }\n        module.exports = __webpack_require__(447)(exports);\n        const {formatters} = module.exports;\n        formatters.j = function(v) {\n            try {\n                return JSON.stringify(v);\n            } catch (error) {\n                return "[UnexpectedJSONParseError]: " + error.message;\n            }\n        };\n    },\n    447: (module, __unused_webpack_exports, __webpack_require__) => {\n        function setup(env) {\n            createDebug.debug = createDebug;\n            createDebug.default = createDebug;\n            createDebug.coerce = coerce;\n            createDebug.disable = disable;\n            createDebug.enable = enable;\n            createDebug.enabled = enabled;\n            createDebug.humanize = __webpack_require__(824);\n            createDebug.destroy = destroy;\n            Object.keys(env).forEach((key => {\n                createDebug[key] = env[key];\n            }));\n            createDebug.names = [];\n            createDebug.skips = [];\n            createDebug.formatters = {};\n            function selectColor(namespace) {\n                let hash = 0;\n                for (let i = 0; i < namespace.length; i++) {\n                    hash = (hash << 5) - hash + namespace.charCodeAt(i);\n                    hash |= 0;\n                }\n                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n            }\n            createDebug.selectColor = selectColor;\n            function createDebug(namespace) {\n                let prevTime;\n                let enableOverride = null;\n                let namespacesCache;\n                let enabledCache;\n                function debug(...args) {\n                    if (!debug.enabled) {\n                        return;\n                    }\n                    const self = debug;\n                    const curr = Number(new Date);\n                    const ms = curr - (prevTime || curr);\n                    self.diff = ms;\n                    self.prev = prevTime;\n                    self.curr = curr;\n                    prevTime = curr;\n                    args[0] = createDebug.coerce(args[0]);\n                    if (typeof args[0] !== "string") {\n                        args.unshift("%O");\n                    }\n                    let index = 0;\n                    args[0] = args[0].replace(/%([a-zA-Z%])/g, ((match, format) => {\n                        if (match === "%%") {\n                            return "%";\n                        }\n                        index++;\n                        const formatter = createDebug.formatters[format];\n                        if (typeof formatter === "function") {\n                            const val = args[index];\n                            match = formatter.call(self, val);\n                            args.splice(index, 1);\n                            index--;\n                        }\n                        return match;\n                    }));\n                    createDebug.formatArgs.call(self, args);\n                    const logFn = self.log || createDebug.log;\n                    logFn.apply(self, args);\n                }\n                debug.namespace = namespace;\n                debug.useColors = createDebug.useColors();\n                debug.color = createDebug.selectColor(namespace);\n                debug.extend = extend;\n                debug.destroy = createDebug.destroy;\n                Object.defineProperty(debug, "enabled", {\n                    enumerable: true,\n                    configurable: false,\n                    get: () => {\n                        if (enableOverride !== null) {\n                            return enableOverride;\n                        }\n                        if (namespacesCache !== createDebug.namespaces) {\n                            namespacesCache = createDebug.namespaces;\n                            enabledCache = createDebug.enabled(namespace);\n                        }\n                        return enabledCache;\n                    },\n                    set: v => {\n                        enableOverride = v;\n                    }\n                });\n                if (typeof createDebug.init === "function") {\n                    createDebug.init(debug);\n                }\n                return debug;\n            }\n            function extend(namespace, delimiter) {\n                const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);\n                newDebug.log = this.log;\n                return newDebug;\n            }\n            function enable(namespaces) {\n                createDebug.save(namespaces);\n                createDebug.namespaces = namespaces;\n                createDebug.names = [];\n                createDebug.skips = [];\n                let i;\n                const split = (typeof namespaces === "string" ? namespaces : "").split(/[\\s,]+/);\n                const len = split.length;\n                for (i = 0; i < len; i++) {\n                    if (!split[i]) {\n                        continue;\n                    }\n                    namespaces = split[i].replace(/\\*/g, ".*?");\n                    if (namespaces[0] === "-") {\n                        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));\n                    } else {\n                        createDebug.names.push(new RegExp("^" + namespaces + "$"));\n                    }\n                }\n            }\n            function disable() {\n                const namespaces = [ ...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace => "-" + namespace)) ].join(",");\n                createDebug.enable("");\n                return namespaces;\n            }\n            function enabled(name) {\n                if (name[name.length - 1] === "*") {\n                    return true;\n                }\n                let i;\n                let len;\n                for (i = 0, len = createDebug.skips.length; i < len; i++) {\n                    if (createDebug.skips[i].test(name)) {\n                        return false;\n                    }\n                }\n                for (i = 0, len = createDebug.names.length; i < len; i++) {\n                    if (createDebug.names[i].test(name)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            function toNamespace(regexp) {\n                return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, "*");\n            }\n            function coerce(val) {\n                if (val instanceof Error) {\n                    return val.stack || val.message;\n                }\n                return val;\n            }\n            function destroy() {\n                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");\n            }\n            createDebug.enable(createDebug.load());\n            return createDebug;\n        }\n        module.exports = setup;\n    },\n    824: module => {\n        var s = 1e3;\n        var m = s * 60;\n        var h = m * 60;\n        var d = h * 24;\n        var w = d * 7;\n        var y = d * 365.25;\n        module.exports = function(val, options) {\n            options = options || {};\n            var type = typeof val;\n            if (type === "string" && val.length > 0) {\n                return parse(val);\n            } else if (type === "number" && isFinite(val)) {\n                return options.long ? fmtLong(val) : fmtShort(val);\n            }\n            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));\n        };\n        function parse(str) {\n            str = String(str);\n            if (str.length > 100) {\n                return;\n            }\n            var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n            if (!match) {\n                return;\n            }\n            var n = parseFloat(match[1]);\n            var type = (match[2] || "ms").toLowerCase();\n            switch (type) {\n              case "years":\n              case "year":\n              case "yrs":\n              case "yr":\n              case "y":\n                return n * y;\n\n              case "weeks":\n              case "week":\n              case "w":\n                return n * w;\n\n              case "days":\n              case "day":\n              case "d":\n                return n * d;\n\n              case "hours":\n              case "hour":\n              case "hrs":\n              case "hr":\n              case "h":\n                return n * h;\n\n              case "minutes":\n              case "minute":\n              case "mins":\n              case "min":\n              case "m":\n                return n * m;\n\n              case "seconds":\n              case "second":\n              case "secs":\n              case "sec":\n              case "s":\n                return n * s;\n\n              case "milliseconds":\n              case "millisecond":\n              case "msecs":\n              case "msec":\n              case "ms":\n                return n;\n\n              default:\n                return undefined;\n            }\n        }\n        function fmtShort(ms) {\n            var msAbs = Math.abs(ms);\n            if (msAbs >= d) {\n                return Math.round(ms / d) + "d";\n            }\n            if (msAbs >= h) {\n                return Math.round(ms / h) + "h";\n            }\n            if (msAbs >= m) {\n                return Math.round(ms / m) + "m";\n            }\n            if (msAbs >= s) {\n                return Math.round(ms / s) + "s";\n            }\n            return ms + "ms";\n        }\n        function fmtLong(ms) {\n            var msAbs = Math.abs(ms);\n            if (msAbs >= d) {\n                return plural(ms, msAbs, d, "day");\n            }\n            if (msAbs >= h) {\n                return plural(ms, msAbs, h, "hour");\n            }\n            if (msAbs >= m) {\n                return plural(ms, msAbs, m, "minute");\n            }\n            if (msAbs >= s) {\n                return plural(ms, msAbs, s, "second");\n            }\n            return ms + " ms";\n        }\n        function plural(ms, msAbs, n, name) {\n            var isPlural = msAbs >= n * 1.5;\n            return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");\n        }\n    }\n};\n\nvar __webpack_module_cache__ = {};\n\nfunction __webpack_require__(moduleId) {\n    var cachedModule = __webpack_module_cache__[moduleId];\n    if (cachedModule !== undefined) {\n        return cachedModule.exports;\n    }\n    var module = __webpack_module_cache__[moduleId] = {\n        exports: {}\n    };\n    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n    return module.exports;\n}\n\n(() => {\n    __webpack_require__.n = module => {\n        var getter = module && module.__esModule ? () => module["default"] : () => module;\n        __webpack_require__.d(getter, {\n            a: getter\n        });\n        return getter;\n    };\n})();\n\n(() => {\n    __webpack_require__.d = (exports, definition) => {\n        for (var key in definition) {\n            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n                Object.defineProperty(exports, key, {\n                    enumerable: true,\n                    get: definition[key]\n                });\n            }\n        }\n    };\n})();\n\n(() => {\n    __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n})();\n\nvar __webpack_exports__ = {};\n\n(() => {\n    const proxyMarker = Symbol("Comlink.proxy");\n    const createEndpoint = Symbol("Comlink.endpoint");\n    const releaseProxy = Symbol("Comlink.releaseProxy");\n    const finalizer = Symbol("Comlink.finalizer");\n    const throwMarker = Symbol("Comlink.thrown");\n    const isObject = val => typeof val === "object" && val !== null || typeof val === "function";\n    const proxyTransferHandler = {\n        canHandle: val => isObject(val) && val[proxyMarker],\n        serialize(obj) {\n            const {port1, port2} = new MessageChannel;\n            expose(obj, port1);\n            return [ port2, [ port2 ] ];\n        },\n        deserialize(port) {\n            port.start();\n            return comlink_wrap(port);\n        }\n    };\n    const throwTransferHandler = {\n        canHandle: value => isObject(value) && throwMarker in value,\n        serialize({value}) {\n            let serialized;\n            if (value instanceof Error) {\n                serialized = {\n                    isError: true,\n                    value: {\n                        message: value.message,\n                        name: value.name,\n                        stack: value.stack\n                    }\n                };\n            } else {\n                serialized = {\n                    isError: false,\n                    value\n                };\n            }\n            return [ serialized, [] ];\n        },\n        deserialize(serialized) {\n            if (serialized.isError) {\n                throw Object.assign(new Error(serialized.value.message), serialized.value);\n            }\n            throw serialized.value;\n        }\n    };\n    const transferHandlers = new Map([ [ "proxy", proxyTransferHandler ], [ "throw", throwTransferHandler ] ]);\n    function isAllowedOrigin(allowedOrigins, origin) {\n        for (const allowedOrigin of allowedOrigins) {\n            if (origin === allowedOrigin || allowedOrigin === "*") {\n                return true;\n            }\n            if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function expose(obj, ep = globalThis, allowedOrigins = [ "*" ]) {\n        ep.addEventListener("message", (function callback(ev) {\n            if (!ev || !ev.data) {\n                return;\n            }\n            if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n                console.warn(`Invalid origin \'${ev.origin}\' for comlink proxy`);\n                return;\n            }\n            const {id, type, path} = Object.assign({\n                path: []\n            }, ev.data);\n            const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n            let returnValue;\n            try {\n                const parent = path.slice(0, -1).reduce(((obj, prop) => obj[prop]), obj);\n                const rawValue = path.reduce(((obj, prop) => obj[prop]), obj);\n                switch (type) {\n                  case "GET":\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n\n                  case "SET":\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n\n                  case "APPLY":\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n\n                  case "CONSTRUCT":\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n\n                  case "ENDPOINT":\n                    {\n                        const {port1, port2} = new MessageChannel;\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [ port1 ]);\n                    }\n                    break;\n\n                  case "RELEASE":\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n\n                  default:\n                    return;\n                }\n            } catch (value) {\n                returnValue = {\n                    value,\n                    [throwMarker]: 0\n                };\n            }\n            Promise.resolve(returnValue).catch((value => ({\n                value,\n                [throwMarker]: 0\n            }))).then((returnValue => {\n                const [wireValue, transferables] = toWireValue(returnValue);\n                ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n                    id\n                }), transferables);\n                if (type === "RELEASE") {\n                    ep.removeEventListener("message", callback);\n                    closeEndPoint(ep);\n                    if (finalizer in obj && typeof obj[finalizer] === "function") {\n                        obj[finalizer]();\n                    }\n                }\n            })).catch((error => {\n                const [wireValue, transferables] = toWireValue({\n                    value: new TypeError("Unserializable return value"),\n                    [throwMarker]: 0\n                });\n                ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n                    id\n                }), transferables);\n            }));\n        }));\n        if (ep.start) {\n            ep.start();\n        }\n    }\n    function isMessagePort(endpoint) {\n        return endpoint.constructor.name === "MessagePort";\n    }\n    function closeEndPoint(endpoint) {\n        if (isMessagePort(endpoint)) endpoint.close();\n    }\n    function comlink_wrap(ep, target) {\n        return createProxy(ep, [], target);\n    }\n    function throwIfProxyReleased(isReleased) {\n        if (isReleased) {\n            throw new Error("Proxy has been released and is not useable");\n        }\n    }\n    function releaseEndpoint(ep) {\n        return requestResponseMessage(ep, {\n            type: "RELEASE"\n        }).then((() => {\n            closeEndPoint(ep);\n        }));\n    }\n    const proxyCounter = new WeakMap;\n    const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    }));\n    function registerProxy(proxy, ep) {\n        const newCount = (proxyCounter.get(ep) || 0) + 1;\n        proxyCounter.set(ep, newCount);\n        if (proxyFinalizers) {\n            proxyFinalizers.register(proxy, ep, proxy);\n        }\n    }\n    function unregisterProxy(proxy) {\n        if (proxyFinalizers) {\n            proxyFinalizers.unregister(proxy);\n        }\n    }\n    function createProxy(ep, path = [], target = function() {}) {\n        let isProxyReleased = false;\n        const proxy = new Proxy(target, {\n            get(_target, prop) {\n                throwIfProxyReleased(isProxyReleased);\n                if (prop === releaseProxy) {\n                    return () => {\n                        unregisterProxy(proxy);\n                        releaseEndpoint(ep);\n                        isProxyReleased = true;\n                    };\n                }\n                if (prop === "then") {\n                    if (path.length === 0) {\n                        return {\n                            then: () => proxy\n                        };\n                    }\n                    const r = requestResponseMessage(ep, {\n                        type: "GET",\n                        path: path.map((p => p.toString()))\n                    }).then(fromWireValue);\n                    return r.then.bind(r);\n                }\n                return createProxy(ep, [ ...path, prop ]);\n            },\n            set(_target, prop, rawValue) {\n                throwIfProxyReleased(isProxyReleased);\n                const [value, transferables] = toWireValue(rawValue);\n                return requestResponseMessage(ep, {\n                    type: "SET",\n                    path: [ ...path, prop ].map((p => p.toString())),\n                    value\n                }, transferables).then(fromWireValue);\n            },\n            apply(_target, _thisArg, rawArgumentList) {\n                throwIfProxyReleased(isProxyReleased);\n                const last = path[path.length - 1];\n                if (last === createEndpoint) {\n                    return requestResponseMessage(ep, {\n                        type: "ENDPOINT"\n                    }).then(fromWireValue);\n                }\n                if (last === "bind") {\n                    return createProxy(ep, path.slice(0, -1));\n                }\n                const [argumentList, transferables] = processArguments(rawArgumentList);\n                return requestResponseMessage(ep, {\n                    type: "APPLY",\n                    path: path.map((p => p.toString())),\n                    argumentList\n                }, transferables).then(fromWireValue);\n            },\n            construct(_target, rawArgumentList) {\n                throwIfProxyReleased(isProxyReleased);\n                const [argumentList, transferables] = processArguments(rawArgumentList);\n                return requestResponseMessage(ep, {\n                    type: "CONSTRUCT",\n                    path: path.map((p => p.toString())),\n                    argumentList\n                }, transferables).then(fromWireValue);\n            }\n        });\n        registerProxy(proxy, ep);\n        return proxy;\n    }\n    function myFlat(arr) {\n        return Array.prototype.concat.apply([], arr);\n    }\n    function processArguments(argumentList) {\n        const processed = argumentList.map(toWireValue);\n        return [ processed.map((v => v[0])), myFlat(processed.map((v => v[1]))) ];\n    }\n    const transferCache = new WeakMap;\n    function transfer(obj, transfers) {\n        transferCache.set(obj, transfers);\n        return obj;\n    }\n    function proxy(obj) {\n        return Object.assign(obj, {\n            [proxyMarker]: true\n        });\n    }\n    function windowEndpoint(w, context = globalThis, targetOrigin = "*") {\n        return {\n            postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n            addEventListener: context.addEventListener.bind(context),\n            removeEventListener: context.removeEventListener.bind(context)\n        };\n    }\n    function toWireValue(value) {\n        for (const [name, handler] of transferHandlers) {\n            if (handler.canHandle(value)) {\n                const [serializedValue, transferables] = handler.serialize(value);\n                return [ {\n                    type: "HANDLER",\n                    name,\n                    value: serializedValue\n                }, transferables ];\n            }\n        }\n        return [ {\n            type: "RAW",\n            value\n        }, transferCache.get(value) || [] ];\n    }\n    function fromWireValue(value) {\n        switch (value.type) {\n          case "HANDLER":\n            return transferHandlers.get(value.name).deserialize(value.value);\n\n          case "RAW":\n            return value.value;\n        }\n    }\n    function requestResponseMessage(ep, msg, transfers) {\n        return new Promise((resolve => {\n            const id = generateUUID();\n            ep.addEventListener("message", (function l(ev) {\n                if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                    return;\n                }\n                ep.removeEventListener("message", l);\n                resolve(ev.data);\n            }));\n            if (ep.start) {\n                ep.start();\n            }\n            ep.postMessage(Object.assign({\n                id\n            }, msg), transfers);\n        }));\n    }\n    function generateUUID() {\n        return new Array(4).fill(0).map((() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))).join("-");\n    }\n    function getSharedMemoryAvailable() {\n        const globalScope = typeof window !== "undefined" ? window : globalThis;\n        return typeof SharedArrayBuffer !== "undefined" && globalScope.crossOriginIsolated;\n    }\n    function getRemoteBarretenbergWasm(worker) {\n        return wrap(worker);\n    }\n    function getNumCpu() {\n        return navigator.hardwareConcurrency;\n    }\n    function threadLogger() {\n        return undefined;\n    }\n    function killSelf() {\n        self.close();\n    }\n    var browser = __webpack_require__(227);\n    var browser_default = __webpack_require__.n(browser);\n    const randomBytes = len => {\n        const getWebCrypto = () => {\n            if (typeof window !== "undefined" && window.crypto) return window.crypto;\n            if (typeof globalThis !== "undefined" && globalThis.crypto) return globalThis.crypto;\n            return undefined;\n        };\n        const crypto = getWebCrypto();\n        if (!crypto) {\n            throw new Error("randomBytes UnsupportedEnvironment");\n        }\n        const buf = new Uint8Array(len);\n        const MAX_BYTES = 65536;\n        if (len > MAX_BYTES) {\n            for (let generated = 0; generated < len; generated += MAX_BYTES) {\n                crypto.getRandomValues(buf.subarray(generated, generated + MAX_BYTES));\n            }\n        } else {\n            crypto.getRandomValues(buf);\n        }\n        return buf;\n    };\n    class BarretenbergWasmBase {\n        constructor() {\n            this.memStore = {};\n            this.logger = browser_default()("bb.js:bb_wasm_base");\n        }\n        getImportObj(memory) {\n            const importObj = {\n                wasi_snapshot_preview1: {\n                    random_get: (out, length) => {\n                        out = out >>> 0;\n                        const randomData = randomBytes(length);\n                        const mem = this.getMemory();\n                        mem.set(randomData, out);\n                    },\n                    clock_time_get: (a1, a2, out) => {\n                        out = out >>> 0;\n                        const ts = BigInt((new Date).getTime()) * 1000000n;\n                        const view = new DataView(this.getMemory().buffer);\n                        view.setBigUint64(out, ts, true);\n                    },\n                    proc_exit: () => {\n                        this.logger("PANIC: proc_exit was called.");\n                        throw new Error;\n                    }\n                },\n                env: {\n                    logstr: addr => {\n                        const str = this.stringFromAddress(addr);\n                        const m = this.getMemory();\n                        const str2 = `${str} (mem: ${(m.length / (1024 * 1024)).toFixed(2)}MiB)`;\n                        this.logger(str2);\n                    },\n                    get_data: (keyAddr, outBufAddr) => {\n                        const key = this.stringFromAddress(keyAddr);\n                        outBufAddr = outBufAddr >>> 0;\n                        const data = this.memStore[key];\n                        if (!data) {\n                            this.logger(`get_data miss ${key}`);\n                            return;\n                        }\n                        this.writeMemory(outBufAddr, data);\n                    },\n                    set_data: (keyAddr, dataAddr, dataLength) => {\n                        const key = this.stringFromAddress(keyAddr);\n                        dataAddr = dataAddr >>> 0;\n                        this.memStore[key] = this.getMemorySlice(dataAddr, dataAddr + dataLength);\n                    },\n                    memory\n                }\n            };\n            return importObj;\n        }\n        exports() {\n            return this.instance.exports;\n        }\n        call(name, ...args) {\n            if (!this.exports()[name]) {\n                throw new Error(`WASM function ${name} not found.`);\n            }\n            try {\n                return this.exports()[name](...args) >>> 0;\n            } catch (err) {\n                const message = `WASM function ${name} aborted, error: ${err}`;\n                this.logger(message);\n                this.logger(err.stack);\n                throw err;\n            }\n        }\n        memSize() {\n            return this.getMemory().length;\n        }\n        getMemorySlice(start, end) {\n            return this.getMemory().subarray(start, end).slice();\n        }\n        writeMemory(offset, arr) {\n            const mem = this.getMemory();\n            mem.set(arr, offset);\n        }\n        getMemory() {\n            return new Uint8Array(this.memory.buffer);\n        }\n        stringFromAddress(addr) {\n            addr = addr >>> 0;\n            const m = this.getMemory();\n            let i = addr;\n            for (;m[i] !== 0; ++i) ;\n            const textDecoder = new TextDecoder("ascii");\n            return textDecoder.decode(m.slice(addr, i));\n        }\n    }\n    class BarretenbergWasmThread extends BarretenbergWasmBase {\n        async initThread(module, memory) {\n            this.logger = threadLogger() || this.logger;\n            this.memory = memory;\n            this.instance = await WebAssembly.instantiate(module, this.getImportObj(this.memory));\n        }\n        destroy() {\n            killSelf();\n        }\n        getImportObj(memory) {\n            const baseImports = super.getImportObj(memory);\n            return {\n                ...baseImports,\n                wasi: {\n                    "thread-spawn": () => {\n                        this.logger("PANIC: threads cannot spawn threads!");\n                        this.logger((new Error).stack);\n                        killSelf();\n                    }\n                },\n                env: {\n                    ...baseImports.env,\n                    env_hardware_concurrency: () => 1\n                }\n            };\n        }\n    }\n    self.onmessage = function(e) {\n        if (e.data.debug) {\n            browser_default().enable(e.data.debug);\n        }\n    };\n    expose(new BarretenbergWasmThread);\n    self.postMessage({\n        ready: true\n    });\n    const thread_worker = null;\n})();', "Worker", undefined, undefined);
    }
    function createThreadWorker() {
        const worker = new thread_worker_Worker_fn;
        const debugStr = browser_default().disable();
        browser_default().enable(debugStr);
        worker.postMessage({
            debug: debugStr
        });
        return worker;
    }
    class BarretenbergWasmBase {
        constructor() {
            this.memStore = {};
            this.logger = browser_default()("bb.js:bb_wasm_base");
        }
        getImportObj(memory) {
            const importObj = {
                wasi_snapshot_preview1: {
                    random_get: (out, length) => {
                        out = out >>> 0;
                        const randomData = randomBytes(length);
                        const mem = this.getMemory();
                        mem.set(randomData, out);
                    },
                    clock_time_get: (a1, a2, out) => {
                        out = out >>> 0;
                        const ts = BigInt((new Date).getTime()) * 1000000n;
                        const view = new DataView(this.getMemory().buffer);
                        view.setBigUint64(out, ts, true);
                    },
                    proc_exit: () => {
                        this.logger("PANIC: proc_exit was called.");
                        throw new Error;
                    }
                },
                env: {
                    logstr: addr => {
                        const str = this.stringFromAddress(addr);
                        const m = this.getMemory();
                        const str2 = `${str} (mem: ${(m.length / (1024 * 1024)).toFixed(2)}MiB)`;
                        this.logger(str2);
                    },
                    get_data: (keyAddr, outBufAddr) => {
                        const key = this.stringFromAddress(keyAddr);
                        outBufAddr = outBufAddr >>> 0;
                        const data = this.memStore[key];
                        if (!data) {
                            this.logger(`get_data miss ${key}`);
                            return;
                        }
                        this.writeMemory(outBufAddr, data);
                    },
                    set_data: (keyAddr, dataAddr, dataLength) => {
                        const key = this.stringFromAddress(keyAddr);
                        dataAddr = dataAddr >>> 0;
                        this.memStore[key] = this.getMemorySlice(dataAddr, dataAddr + dataLength);
                    },
                    memory
                }
            };
            return importObj;
        }
        exports() {
            return this.instance.exports;
        }
        call(name, ...args) {
            if (!this.exports()[name]) {
                throw new Error(`WASM function ${name} not found.`);
            }
            try {
                return this.exports()[name](...args) >>> 0;
            } catch (err) {
                const message = `WASM function ${name} aborted, error: ${err}`;
                this.logger(message);
                this.logger(err.stack);
                throw err;
            }
        }
        memSize() {
            return this.getMemory().length;
        }
        getMemorySlice(start, end) {
            return this.getMemory().subarray(start, end).slice();
        }
        writeMemory(offset, arr) {
            const mem = this.getMemory();
            mem.set(arr, offset);
        }
        getMemory() {
            return new Uint8Array(this.memory.buffer);
        }
        stringFromAddress(addr) {
            addr = addr >>> 0;
            const m = this.getMemory();
            let i = addr;
            for (;m[i] !== 0; ++i) ;
            const textDecoder = new TextDecoder("ascii");
            return textDecoder.decode(m.slice(addr, i));
        }
    }
    class HeapAllocator {
        constructor(wasm) {
            this.wasm = wasm;
            this.allocs = [];
            this.inScratchRemaining = 1024;
            this.outScratchRemaining = 1024;
        }
        getInputs(buffers) {
            return buffers.map((bufOrNum => {
                if (typeof bufOrNum === "object") {
                    if (bufOrNum.length <= this.inScratchRemaining) {
                        const ptr = this.inScratchRemaining -= bufOrNum.length;
                        this.wasm.writeMemory(ptr, bufOrNum);
                        return ptr;
                    } else {
                        const ptr = this.wasm.call("bbmalloc", bufOrNum.length);
                        this.wasm.writeMemory(ptr, bufOrNum);
                        this.allocs.push(ptr);
                        return ptr;
                    }
                } else {
                    return bufOrNum;
                }
            }));
        }
        getOutputPtrs(outLens) {
            return outLens.map((len => {
                const size = len || 4;
                if (size <= this.outScratchRemaining) {
                    return this.outScratchRemaining -= size;
                } else {
                    const ptr = this.wasm.call("bbmalloc", size);
                    this.allocs.push(ptr);
                    return ptr;
                }
            }));
        }
        addOutputPtr(ptr) {
            if (ptr >= 1024) {
                this.allocs.push(ptr);
            }
        }
        freeAll() {
            for (const ptr of this.allocs) {
                this.wasm.call("bbfree", ptr);
            }
        }
    }
    class barretenberg_wasm_main_BarretenbergWasmMain extends BarretenbergWasmBase {
        constructor() {
            super(...arguments);
            this.workers = [];
            this.remoteWasms = [];
            this.nextWorker = 0;
            this.nextThreadId = 1;
        }
        getNumThreads() {
            return this.workers.length + 1;
        }
        async init(module, threads = Math.min(getNumCpu(), barretenberg_wasm_main_BarretenbergWasmMain.MAX_THREADS), logger = browser_default()("bb.js:bb_wasm"), initial = 32, maximum = 2 ** 16) {
            this.logger = logger;
            const initialMb = initial * 2 ** 16 / (1024 * 1024);
            const maxMb = maximum * 2 ** 16 / (1024 * 1024);
            const shared = getSharedMemoryAvailable();
            this.logger(`Initializing bb wasm: initial memory ${initial} pages ${initialMb}MiB; ` + `max memory: ${maximum} pages, ${maxMb}MiB; ` + `threads: ${threads}; shared memory: ${shared}`);
            this.memory = new WebAssembly.Memory({
                initial,
                maximum,
                shared
            });
            const instance = await WebAssembly.instantiate(module, this.getImportObj(this.memory));
            this.instance = instance;
            this.call("_initialize");
            if (threads > 1) {
                this.logger(`Creating ${threads} worker threads`);
                this.workers = await Promise.all(Array.from({
                    length: threads - 1
                }).map(createThreadWorker));
                this.remoteWasms = await Promise.all(this.workers.map(browser_getRemoteBarretenbergWasm));
                await Promise.all(this.remoteWasms.map((w => w.initThread(module, this.memory))));
            }
        }
        async destroy() {
            await Promise.all(this.workers.map((w => w.terminate())));
        }
        getImportObj(memory) {
            const baseImports = super.getImportObj(memory);
            return {
                ...baseImports,
                wasi: {
                    "thread-spawn": arg => {
                        arg = arg >>> 0;
                        const id = this.nextThreadId++;
                        const worker = this.nextWorker++ % this.remoteWasms.length;
                        this.remoteWasms[worker].call("wasi_thread_start", id, arg).catch(this.logger);
                        return id;
                    }
                },
                env: {
                    ...baseImports.env,
                    env_hardware_concurrency: () => this.remoteWasms.length + 1
                }
            };
        }
        callWasmExport(funcName, inArgs, outLens) {
            const alloc = new HeapAllocator(this);
            const inPtrs = alloc.getInputs(inArgs);
            const outPtrs = alloc.getOutputPtrs(outLens);
            this.call(funcName, ...inPtrs, ...outPtrs);
            const outArgs = this.getOutputArgs(outLens, outPtrs, alloc);
            alloc.freeAll();
            return outArgs;
        }
        getOutputArgs(outLens, outPtrs, alloc) {
            return outLens.map(((len, i) => {
                if (len) {
                    return this.getMemorySlice(outPtrs[i], outPtrs[i] + len);
                }
                const slice = this.getMemorySlice(outPtrs[i], outPtrs[i] + 4);
                const ptr = new DataView(slice.buffer, slice.byteOffset, slice.byteLength).getUint32(0, true);
                alloc.addOutputPtr(ptr);
                const lslice = this.getMemorySlice(ptr, ptr + 4);
                const length = new DataView(lslice.buffer, lslice.byteOffset, lslice.byteLength).getUint32(0, false);
                return this.getMemorySlice(ptr + 4, ptr + 4 + length);
            }));
        }
    }
    barretenberg_wasm_main_BarretenbergWasmMain.MAX_THREADS = 32;
    const Z_FIXED$1 = 4;
    const Z_BINARY = 0;
    const Z_TEXT = 1;
    const Z_UNKNOWN$1 = 2;
    function zero$1(buf) {
        let len = buf.length;
        while (--len >= 0) {
            buf[len] = 0;
        }
    }
    const STORED_BLOCK = 0;
    const STATIC_TREES = 1;
    const DYN_TREES = 2;
    const MIN_MATCH$1 = 3;
    const MAX_MATCH$1 = 258;
    const LENGTH_CODES$1 = 29;
    const LITERALS$1 = 256;
    const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
    const D_CODES$1 = 30;
    const BL_CODES$1 = 19;
    const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
    const MAX_BITS$1 = 15;
    const Buf_size = 16;
    const MAX_BL_BITS = 7;
    const END_BLOCK = 256;
    const REP_3_6 = 16;
    const REPZ_3_10 = 17;
    const REPZ_11_138 = 18;
    const extra_lbits = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ]);
    const extra_dbits = new Uint8Array([ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ]);
    const extra_blbits = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ]);
    const bl_order = new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);
    const DIST_CODE_LEN = 512;
    const static_ltree = new Array((L_CODES$1 + 2) * 2);
    zero$1(static_ltree);
    const static_dtree = new Array(D_CODES$1 * 2);
    zero$1(static_dtree);
    const _dist_code = new Array(DIST_CODE_LEN);
    zero$1(_dist_code);
    const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
    zero$1(_length_code);
    const base_length = new Array(LENGTH_CODES$1);
    zero$1(base_length);
    const base_dist = new Array(D_CODES$1);
    zero$1(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
    }
    let static_l_desc;
    let static_d_desc;
    let static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
    }
    const d_code = dist => dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    const put_short = (s, w) => {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255;
    };
    const send_bits = (s, value, length) => {
        if (s.bi_valid > Buf_size - length) {
            s.bi_buf |= value << s.bi_valid & 65535;
            put_short(s, s.bi_buf);
            s.bi_buf = value >> Buf_size - s.bi_valid;
            s.bi_valid += length - Buf_size;
        } else {
            s.bi_buf |= value << s.bi_valid & 65535;
            s.bi_valid += length;
        }
    };
    const send_code = (s, c, tree) => {
        send_bits(s, tree[c * 2], tree[c * 2 + 1]);
    };
    const bi_reverse = (code, len) => {
        let res = 0;
        do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
        } while (--len > 0);
        return res >>> 1;
    };
    const bi_flush = s => {
        if (s.bi_valid === 16) {
            put_short(s, s.bi_buf);
            s.bi_buf = 0;
            s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
            s.pending_buf[s.pending++] = s.bi_buf & 255;
            s.bi_buf >>= 8;
            s.bi_valid -= 8;
        }
    };
    const gen_bitlen = (s, desc) => {
        const tree = desc.dyn_tree;
        const max_code = desc.max_code;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const extra = desc.stat_desc.extra_bits;
        const base = desc.stat_desc.extra_base;
        const max_length = desc.stat_desc.max_length;
        let h;
        let n, m;
        let bits;
        let xbits;
        let f;
        let overflow = 0;
        for (bits = 0; bits <= MAX_BITS$1; bits++) {
            s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
            n = s.heap[h];
            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
                bits = max_length;
                overflow++;
            }
            tree[n * 2 + 1] = bits;
            if (n > max_code) {
                continue;
            }
            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base) {
                xbits = extra[n - base];
            }
            f = tree[n * 2];
            s.opt_len += f * (bits + xbits);
            if (has_stree) {
                s.static_len += f * (stree[n * 2 + 1] + xbits);
            }
        }
        if (overflow === 0) {
            return;
        }
        do {
            bits = max_length - 1;
            while (s.bl_count[bits] === 0) {
                bits--;
            }
            s.bl_count[bits]--;
            s.bl_count[bits + 1] += 2;
            s.bl_count[max_length]--;
            overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
            n = s.bl_count[bits];
            while (n !== 0) {
                m = s.heap[--h];
                if (m > max_code) {
                    continue;
                }
                if (tree[m * 2 + 1] !== bits) {
                    s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                    tree[m * 2 + 1] = bits;
                }
                n--;
            }
        }
    };
    const gen_codes = (tree, max_code, bl_count) => {
        const next_code = new Array(MAX_BITS$1 + 1);
        let code = 0;
        let bits;
        let n;
        for (bits = 1; bits <= MAX_BITS$1; bits++) {
            code = code + bl_count[bits - 1] << 1;
            next_code[bits] = code;
        }
        for (n = 0; n <= max_code; n++) {
            let len = tree[n * 2 + 1];
            if (len === 0) {
                continue;
            }
            tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
    };
    const tr_static_init = () => {
        let n;
        let bits;
        let length;
        let code;
        let dist;
        const bl_count = new Array(MAX_BITS$1 + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
            base_length[code] = length;
            for (n = 0; n < 1 << extra_lbits[code]; n++) {
                _length_code[length++] = code;
            }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
            base_dist[code] = dist;
            for (n = 0; n < 1 << extra_dbits[code]; n++) {
                _dist_code[dist++] = code;
            }
        }
        dist >>= 7;
        for (;code < D_CODES$1; code++) {
            base_dist[code] = dist << 7;
            for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
                _dist_code[256 + dist++] = code;
            }
        }
        for (bits = 0; bits <= MAX_BITS$1; bits++) {
            bl_count[bits] = 0;
        }
        n = 0;
        while (n <= 143) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
        }
        while (n <= 255) {
            static_ltree[n * 2 + 1] = 9;
            n++;
            bl_count[9]++;
        }
        while (n <= 279) {
            static_ltree[n * 2 + 1] = 7;
            n++;
            bl_count[7]++;
        }
        while (n <= 287) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
        for (n = 0; n < D_CODES$1; n++) {
            static_dtree[n * 2 + 1] = 5;
            static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
    };
    const init_block = s => {
        let n;
        for (n = 0; n < L_CODES$1; n++) {
            s.dyn_ltree[n * 2] = 0;
        }
        for (n = 0; n < D_CODES$1; n++) {
            s.dyn_dtree[n * 2] = 0;
        }
        for (n = 0; n < BL_CODES$1; n++) {
            s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.sym_next = s.matches = 0;
    };
    const bi_windup = s => {
        if (s.bi_valid > 8) {
            put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
            s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
    };
    const smaller = (tree, n, m, depth) => {
        const _n2 = n * 2;
        const _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    };
    const pqdownheap = (s, tree, k) => {
        const v = s.heap[k];
        let j = k << 1;
        while (j <= s.heap_len) {
            if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                j++;
            }
            if (smaller(tree, v, s.heap[j], s.depth)) {
                break;
            }
            s.heap[k] = s.heap[j];
            k = j;
            j <<= 1;
        }
        s.heap[k] = v;
    };
    const compress_block = (s, ltree, dtree) => {
        let dist;
        let lc;
        let sx = 0;
        let code;
        let extra;
        if (s.sym_next !== 0) {
            do {
                dist = s.pending_buf[s.sym_buf + sx++] & 255;
                dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
                lc = s.pending_buf[s.sym_buf + sx++];
                if (dist === 0) {
                    send_code(s, lc, ltree);
                } else {
                    code = _length_code[lc];
                    send_code(s, code + LITERALS$1 + 1, ltree);
                    extra = extra_lbits[code];
                    if (extra !== 0) {
                        lc -= base_length[code];
                        send_bits(s, lc, extra);
                    }
                    dist--;
                    code = d_code(dist);
                    send_code(s, code, dtree);
                    extra = extra_dbits[code];
                    if (extra !== 0) {
                        dist -= base_dist[code];
                        send_bits(s, dist, extra);
                    }
                }
            } while (sx < s.sym_next);
        }
        send_code(s, END_BLOCK, ltree);
    };
    const build_tree = (s, desc) => {
        const tree = desc.dyn_tree;
        const stree = desc.stat_desc.static_tree;
        const has_stree = desc.stat_desc.has_stree;
        const elems = desc.stat_desc.elems;
        let n, m;
        let max_code = -1;
        let node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE$1;
        for (n = 0; n < elems; n++) {
            if (tree[n * 2] !== 0) {
                s.heap[++s.heap_len] = max_code = n;
                s.depth[n] = 0;
            } else {
                tree[n * 2 + 1] = 0;
            }
        }
        while (s.heap_len < 2) {
            node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node * 2] = 1;
            s.depth[node] = 0;
            s.opt_len--;
            if (has_stree) {
                s.static_len -= stree[node * 2 + 1];
            }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
            pqdownheap(s, tree, n);
        }
        node = elems;
        do {
            n = s.heap[1];
            s.heap[1] = s.heap[s.heap_len--];
            pqdownheap(s, tree, 1);
            m = s.heap[1];
            s.heap[--s.heap_max] = n;
            s.heap[--s.heap_max] = m;
            tree[node * 2] = tree[n * 2] + tree[m * 2];
            s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
            tree[n * 2 + 1] = tree[m * 2 + 1] = node;
            s.heap[1] = node++;
            pqdownheap(s, tree, 1);
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[1];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
    };
    const scan_tree = (s, tree, max_code) => {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
                continue;
            } else if (count < min_count) {
                s.bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                    s.bl_tree[curlen * 2]++;
                }
                s.bl_tree[REP_3_6 * 2]++;
            } else if (count <= 10) {
                s.bl_tree[REPZ_3_10 * 2]++;
            } else {
                s.bl_tree[REPZ_11_138 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    };
    const send_tree = (s, tree, max_code) => {
        let n;
        let prevlen = -1;
        let curlen;
        let nextlen = tree[0 * 2 + 1];
        let count = 0;
        let max_count = 7;
        let min_count = 4;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        }
        for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
                continue;
            } else if (count < min_count) {
                do {
                    send_code(s, curlen, s.bl_tree);
                } while (--count !== 0);
            } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                    send_code(s, curlen, s.bl_tree);
                    count--;
                }
                send_code(s, REP_3_6, s.bl_tree);
                send_bits(s, count - 3, 2);
            } else if (count <= 10) {
                send_code(s, REPZ_3_10, s.bl_tree);
                send_bits(s, count - 3, 3);
            } else {
                send_code(s, REPZ_11_138, s.bl_tree);
                send_bits(s, count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
            } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
            } else {
                max_count = 7;
                min_count = 4;
            }
        }
    };
    const build_bl_tree = s => {
        let max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
            if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
                break;
            }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
    };
    const send_all_trees = (s, lcodes, dcodes, blcodes) => {
        let rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
            send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
    };
    const detect_data_type = s => {
        let block_mask = 4093624447;
        let n;
        for (n = 0; n <= 31; n++, block_mask >>>= 1) {
            if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
                return Z_BINARY;
            }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
            return Z_TEXT;
        }
        for (n = 32; n < LITERALS$1; n++) {
            if (s.dyn_ltree[n * 2] !== 0) {
                return Z_TEXT;
            }
        }
        return Z_BINARY;
    };
    let static_init_done = false;
    const _tr_init$1 = s => {
        if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
    };
    const _tr_stored_block$1 = (s, buf, stored_len, last) => {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        bi_windup(s);
        put_short(s, stored_len);
        put_short(s, ~stored_len);
        if (stored_len) {
            s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
        }
        s.pending += stored_len;
    };
    const _tr_align$1 = s => {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
    };
    const _tr_flush_block$1 = (s, buf, stored_len, last) => {
        let opt_lenb, static_lenb;
        let max_blindex = 0;
        if (s.level > 0) {
            if (s.strm.data_type === Z_UNKNOWN$1) {
                s.strm.data_type = detect_data_type(s);
            }
            build_tree(s, s.l_desc);
            build_tree(s, s.d_desc);
            max_blindex = build_bl_tree(s);
            opt_lenb = s.opt_len + 3 + 7 >>> 3;
            static_lenb = s.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) {
                opt_lenb = static_lenb;
            }
        } else {
            opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
            _tr_stored_block$1(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
            send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
            compress_block(s, static_ltree, static_dtree);
        } else {
            send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
            send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
            compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last) {
            bi_windup(s);
        }
    };
    const _tr_tally$1 = (s, dist, lc) => {
        s.pending_buf[s.sym_buf + s.sym_next++] = dist;
        s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
        s.pending_buf[s.sym_buf + s.sym_next++] = lc;
        if (dist === 0) {
            s.dyn_ltree[lc * 2]++;
        } else {
            s.matches++;
            dist--;
            s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
            s.dyn_dtree[d_code(dist) * 2]++;
        }
        return s.sym_next === s.sym_end;
    };
    var _tr_init_1 = _tr_init$1;
    var _tr_stored_block_1 = _tr_stored_block$1;
    var _tr_flush_block_1 = _tr_flush_block$1;
    var _tr_tally_1 = _tr_tally$1;
    var _tr_align_1 = _tr_align$1;
    var trees = {
        _tr_init: _tr_init_1,
        _tr_stored_block: _tr_stored_block_1,
        _tr_flush_block: _tr_flush_block_1,
        _tr_tally: _tr_tally_1,
        _tr_align: _tr_align_1
    };
    const adler32 = (adler, buf, len, pos) => {
        let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
        while (len !== 0) {
            n = len > 2e3 ? 2e3 : len;
            len -= n;
            do {
                s1 = s1 + buf[pos++] | 0;
                s2 = s2 + s1 | 0;
            } while (--n);
            s1 %= 65521;
            s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
    };
    var adler32_1 = adler32;
    const makeTable = () => {
        let c, table = [];
        for (var n = 0; n < 256; n++) {
            c = n;
            for (var k = 0; k < 8; k++) {
                c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
            }
            table[n] = c;
        }
        return table;
    };
    const crcTable = new Uint32Array(makeTable());
    const crc32 = (crc, buf, len, pos) => {
        const t = crcTable;
        const end = pos + len;
        crc ^= -1;
        for (let i = pos; i < end; i++) {
            crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
    };
    var crc32_1 = crc32;
    var messages = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
    };
    var constants$2 = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
    };
    const {_tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align} = trees;
    const {Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1, Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1, Z_UNKNOWN, Z_DEFLATED: Z_DEFLATED$2} = constants$2;
    const MAX_MEM_LEVEL = 9;
    const MAX_WBITS$1 = 15;
    const DEF_MEM_LEVEL = 8;
    const LENGTH_CODES = 29;
    const LITERALS = 256;
    const L_CODES = LITERALS + 1 + LENGTH_CODES;
    const D_CODES = 30;
    const BL_CODES = 19;
    const HEAP_SIZE = 2 * L_CODES + 1;
    const MAX_BITS = 15;
    const MIN_MATCH = 3;
    const MAX_MATCH = 258;
    const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    const PRESET_DICT = 32;
    const INIT_STATE = 42;
    const GZIP_STATE = 57;
    const EXTRA_STATE = 69;
    const NAME_STATE = 73;
    const COMMENT_STATE = 91;
    const HCRC_STATE = 103;
    const BUSY_STATE = 113;
    const FINISH_STATE = 666;
    const BS_NEED_MORE = 1;
    const BS_BLOCK_DONE = 2;
    const BS_FINISH_STARTED = 3;
    const BS_FINISH_DONE = 4;
    const OS_CODE = 3;
    const err = (strm, errorCode) => {
        strm.msg = messages[errorCode];
        return errorCode;
    };
    const rank = f => f * 2 - (f > 4 ? 9 : 0);
    const zero = buf => {
        let len = buf.length;
        while (--len >= 0) {
            buf[len] = 0;
        }
    };
    const slide_hash = s => {
        let n, m;
        let p;
        let wsize = s.w_size;
        n = s.hash_size;
        p = n;
        do {
            m = s.head[--p];
            s.head[p] = m >= wsize ? m - wsize : 0;
        } while (--n);
        n = wsize;
        p = n;
        do {
            m = s.prev[--p];
            s.prev[p] = m >= wsize ? m - wsize : 0;
        } while (--n);
    };
    let HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
    let HASH = HASH_ZLIB;
    const flush_pending = strm => {
        const s = strm.state;
        let len = s.pending;
        if (len > strm.avail_out) {
            len = strm.avail_out;
        }
        if (len === 0) {
            return;
        }
        strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
            s.pending_out = 0;
        }
    };
    const flush_block_only = (s, last) => {
        _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
    };
    const put_byte = (s, b) => {
        s.pending_buf[s.pending++] = b;
    };
    const putShortMSB = (s, b) => {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255;
    };
    const read_buf = (strm, buf, start, size) => {
        let len = strm.avail_in;
        if (len > size) {
            len = size;
        }
        if (len === 0) {
            return 0;
        }
        strm.avail_in -= len;
        buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
        if (strm.state.wrap === 1) {
            strm.adler = adler32_1(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
            strm.adler = crc32_1(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
    };
    const longest_match = (s, cur_match) => {
        let chain_length = s.max_chain_length;
        let scan = s.strstart;
        let match;
        let len;
        let best_len = s.prev_length;
        let nice_match = s.nice_match;
        const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        const _win = s.window;
        const wmask = s.w_mask;
        const prev = s.prev;
        const strend = s.strstart + MAX_MATCH;
        let scan_end1 = _win[scan + best_len - 1];
        let scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
            chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
            nice_match = s.lookahead;
        }
        do {
            match = cur_match;
            if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
                continue;
            }
            scan += 2;
            match++;
            do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
                s.match_start = cur_match;
                best_len = len;
                if (len >= nice_match) {
                    break;
                }
                scan_end1 = _win[scan + best_len - 1];
                scan_end = _win[scan + best_len];
            }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
            return best_len;
        }
        return s.lookahead;
    };
    const fill_window = s => {
        const _w_size = s.w_size;
        let n, more, str;
        do {
            more = s.window_size - s.lookahead - s.strstart;
            if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
                s.match_start -= _w_size;
                s.strstart -= _w_size;
                s.block_start -= _w_size;
                if (s.insert > s.strstart) {
                    s.insert = s.strstart;
                }
                slide_hash(s);
                more += _w_size;
            }
            if (s.strm.avail_in === 0) {
                break;
            }
            n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
            s.lookahead += n;
            if (s.lookahead + s.insert >= MIN_MATCH) {
                str = s.strstart - s.insert;
                s.ins_h = s.window[str];
                s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
                while (s.insert) {
                    s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
                    s.prev[str & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = str;
                    str++;
                    s.insert--;
                    if (s.lookahead + s.insert < MIN_MATCH) {
                        break;
                    }
                }
            }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    };
    const deflate_stored = (s, flush) => {
        let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
        let len, left, have, last = 0;
        let used = s.strm.avail_in;
        do {
            len = 65535;
            have = s.bi_valid + 42 >> 3;
            if (s.strm.avail_out < have) {
                break;
            }
            have = s.strm.avail_out - have;
            left = s.strstart - s.block_start;
            if (len > left + s.strm.avail_in) {
                len = left + s.strm.avail_in;
            }
            if (len > have) {
                len = have;
            }
            if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
                break;
            }
            last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
            _tr_stored_block(s, 0, 0, last);
            s.pending_buf[s.pending - 4] = len;
            s.pending_buf[s.pending - 3] = len >> 8;
            s.pending_buf[s.pending - 2] = ~len;
            s.pending_buf[s.pending - 1] = ~len >> 8;
            flush_pending(s.strm);
            if (left) {
                if (left > len) {
                    left = len;
                }
                s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
                s.strm.next_out += left;
                s.strm.avail_out -= left;
                s.strm.total_out += left;
                s.block_start += left;
                len -= left;
            }
            if (len) {
                read_buf(s.strm, s.strm.output, s.strm.next_out, len);
                s.strm.next_out += len;
                s.strm.avail_out -= len;
                s.strm.total_out += len;
            }
        } while (last === 0);
        used -= s.strm.avail_in;
        if (used) {
            if (used >= s.w_size) {
                s.matches = 2;
                s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
                s.strstart = s.w_size;
                s.insert = s.strstart;
            } else {
                if (s.window_size - s.strstart <= used) {
                    s.strstart -= s.w_size;
                    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
                    if (s.matches < 2) {
                        s.matches++;
                    }
                    if (s.insert > s.strstart) {
                        s.insert = s.strstart;
                    }
                }
                s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
                s.strstart += used;
                s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
            }
            s.block_start = s.strstart;
        }
        if (s.high_water < s.strstart) {
            s.high_water = s.strstart;
        }
        if (last) {
            return BS_FINISH_DONE;
        }
        if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
            return BS_BLOCK_DONE;
        }
        have = s.window_size - s.strstart;
        if (s.strm.avail_in > have && s.block_start >= s.w_size) {
            s.block_start -= s.w_size;
            s.strstart -= s.w_size;
            s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
            if (s.matches < 2) {
                s.matches++;
            }
            have += s.w_size;
            if (s.insert > s.strstart) {
                s.insert = s.strstart;
            }
        }
        if (have > s.strm.avail_in) {
            have = s.strm.avail_in;
        }
        if (have) {
            read_buf(s.strm, s.window, s.strstart, have);
            s.strstart += have;
            s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
        }
        if (s.high_water < s.strstart) {
            s.high_water = s.strstart;
        }
        have = s.bi_valid + 42 >> 3;
        have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
        min_block = have > s.w_size ? s.w_size : have;
        left = s.strstart - s.block_start;
        if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
            len = left > have ? have : left;
            last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
            _tr_stored_block(s, s.block_start, len, last);
            s.block_start += len;
            flush_pending(s.strm);
        }
        return last ? BS_FINISH_STARTED : BS_NEED_MORE;
    };
    const deflate_fast = (s, flush) => {
        let hash_head;
        let bflush;
        for (;;) {
            if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break;
                }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
            }
            if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                s.match_length = longest_match(s, hash_head);
            }
            if (s.match_length >= MIN_MATCH) {
                bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                s.lookahead -= s.match_length;
                if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                    s.match_length--;
                    do {
                        s.strstart++;
                        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                    } while (--s.match_length !== 0);
                    s.strstart++;
                } else {
                    s.strstart += s.match_length;
                    s.match_length = 0;
                    s.ins_h = s.window[s.strstart];
                    s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
                }
            } else {
                bflush = _tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
            }
            if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH$3) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    };
    const deflate_slow = (s, flush) => {
        let hash_head;
        let bflush;
        let max_insert;
        for (;;) {
            if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break;
                }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
                s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
            }
            s.prev_length = s.match_length;
            s.prev_match = s.match_start;
            s.match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                s.match_length = longest_match(s, hash_head);
                if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                    s.match_length = MIN_MATCH - 1;
                }
            }
            if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                max_insert = s.strstart + s.lookahead - MIN_MATCH;
                bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                s.lookahead -= s.prev_length - 1;
                s.prev_length -= 2;
                do {
                    if (++s.strstart <= max_insert) {
                        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = s.strstart;
                    }
                } while (--s.prev_length !== 0);
                s.match_available = 0;
                s.match_length = MIN_MATCH - 1;
                s.strstart++;
                if (bflush) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                    }
                }
            } else if (s.match_available) {
                bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
                if (bflush) {
                    flush_block_only(s, false);
                }
                s.strstart++;
                s.lookahead--;
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            } else {
                s.match_available = 1;
                s.strstart++;
                s.lookahead--;
            }
        }
        if (s.match_available) {
            bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
            s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH$3) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    };
    const deflate_rle = (s, flush) => {
        let bflush;
        let prev;
        let scan, strend;
        const _win = s.window;
        for (;;) {
            if (s.lookahead <= MAX_MATCH) {
                fill_window(s);
                if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
                    return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                    break;
                }
            }
            s.match_length = 0;
            if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                scan = s.strstart - 1;
                prev = _win[scan];
                if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                    strend = s.strstart + MAX_MATCH;
                    do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                    s.match_length = MAX_MATCH - (strend - scan);
                    if (s.match_length > s.lookahead) {
                        s.match_length = s.lookahead;
                    }
                }
            }
            if (s.match_length >= MIN_MATCH) {
                bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
                s.lookahead -= s.match_length;
                s.strstart += s.match_length;
                s.match_length = 0;
            } else {
                bflush = _tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
            }
            if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH$3) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    };
    const deflate_huff = (s, flush) => {
        let bflush;
        for (;;) {
            if (s.lookahead === 0) {
                fill_window(s);
                if (s.lookahead === 0) {
                    if (flush === Z_NO_FLUSH$2) {
                        return BS_NEED_MORE;
                    }
                    break;
                }
            }
            s.match_length = 0;
            bflush = _tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
            if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                }
            }
        }
        s.insert = 0;
        if (flush === Z_FINISH$3) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
        }
        if (s.sym_next) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
            }
        }
        return BS_BLOCK_DONE;
    };
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
    }
    const configuration_table = [ new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow) ];
    const lm_init = s => {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
    };
    function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED$2;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
        this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
        this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new Uint16Array(MAX_BITS + 1);
        this.heap = new Uint16Array(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new Uint16Array(2 * L_CODES + 1);
        zero(this.depth);
        this.sym_buf = 0;
        this.lit_bufsize = 0;
        this.sym_next = 0;
        this.sym_end = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
    }
    const deflateStateCheck = strm => {
        if (!strm) {
            return 1;
        }
        const s = strm.state;
        if (!s || s.strm !== strm || s.status !== INIT_STATE && s.status !== GZIP_STATE && s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
            return 1;
        }
        return 0;
    };
    const deflateResetKeep = strm => {
        if (deflateStateCheck(strm)) {
            return err(strm, Z_STREAM_ERROR$2);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        const s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
            s.wrap = -s.wrap;
        }
        s.status = s.wrap === 2 ? GZIP_STATE : s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = -2;
        _tr_init(s);
        return Z_OK$3;
    };
    const deflateReset = strm => {
        const ret = deflateResetKeep(strm);
        if (ret === Z_OK$3) {
            lm_init(strm.state);
        }
        return ret;
    };
    const deflateSetHeader = (strm, head) => {
        if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
            return Z_STREAM_ERROR$2;
        }
        strm.state.gzhead = head;
        return Z_OK$3;
    };
    const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
        if (!strm) {
            return Z_STREAM_ERROR$2;
        }
        let wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION$1) {
            level = 6;
        }
        if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
        } else if (windowBits > 15) {
            wrap = 2;
            windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
            return err(strm, Z_STREAM_ERROR$2);
        }
        if (windowBits === 8) {
            windowBits = 9;
        }
        const s = new DeflateState;
        strm.state = s;
        s.strm = strm;
        s.status = INIT_STATE;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new Uint8Array(s.w_size * 2);
        s.head = new Uint16Array(s.hash_size);
        s.prev = new Uint16Array(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new Uint8Array(s.pending_buf_size);
        s.sym_buf = s.lit_bufsize;
        s.sym_end = (s.lit_bufsize - 1) * 3;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
    };
    const deflateInit = (strm, level) => deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
    const deflate$2 = (strm, flush) => {
        if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
        }
        const s = strm.state;
        if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
            return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
        }
        const old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
                s.last_flush = -1;
                return Z_OK$3;
            }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
            return err(strm, Z_BUF_ERROR$1);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR$1);
        }
        if (s.status === INIT_STATE && s.wrap === 0) {
            s.status = BUSY_STATE;
        }
        if (s.status === INIT_STATE) {
            let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
            let level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                level_flags = 0;
            } else if (s.level < 6) {
                level_flags = 1;
            } else if (s.level === 6) {
                level_flags = 2;
            } else {
                level_flags = 3;
            }
            header |= level_flags << 6;
            if (s.strstart !== 0) {
                header |= PRESET_DICT;
            }
            header += 31 - header % 31;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
                putShortMSB(s, strm.adler >>> 16);
                putShortMSB(s, strm.adler & 65535);
            }
            strm.adler = 1;
            s.status = BUSY_STATE;
            flush_pending(strm);
            if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK$3;
            }
        }
        if (s.status === GZIP_STATE) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, OS_CODE);
                s.status = BUSY_STATE;
                flush_pending(strm);
                if (s.pending !== 0) {
                    s.last_flush = -1;
                    return Z_OK$3;
                }
            } else {
                put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
                put_byte(s, s.gzhead.time & 255);
                put_byte(s, s.gzhead.time >> 8 & 255);
                put_byte(s, s.gzhead.time >> 16 & 255);
                put_byte(s, s.gzhead.time >> 24 & 255);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, s.gzhead.os & 255);
                if (s.gzhead.extra && s.gzhead.extra.length) {
                    put_byte(s, s.gzhead.extra.length & 255);
                    put_byte(s, s.gzhead.extra.length >> 8 & 255);
                }
                if (s.gzhead.hcrc) {
                    strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
                }
                s.gzindex = 0;
                s.status = EXTRA_STATE;
            }
        }
        if (s.status === EXTRA_STATE) {
            if (s.gzhead.extra) {
                let beg = s.pending;
                let left = (s.gzhead.extra.length & 65535) - s.gzindex;
                while (s.pending + left > s.pending_buf_size) {
                    let copy = s.pending_buf_size - s.pending;
                    s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
                    s.pending = s.pending_buf_size;
                    if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    s.gzindex += copy;
                    flush_pending(strm);
                    if (s.pending !== 0) {
                        s.last_flush = -1;
                        return Z_OK$3;
                    }
                    beg = 0;
                    left -= copy;
                }
                let gzhead_extra = new Uint8Array(s.gzhead.extra);
                s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
                s.pending += left;
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                s.gzindex = 0;
            }
            s.status = NAME_STATE;
        }
        if (s.status === NAME_STATE) {
            if (s.gzhead.name) {
                let beg = s.pending;
                let val;
                do {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        if (s.pending !== 0) {
                            s.last_flush = -1;
                            return Z_OK$3;
                        }
                        beg = 0;
                    }
                    if (s.gzindex < s.gzhead.name.length) {
                        val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                    } else {
                        val = 0;
                    }
                    put_byte(s, val);
                } while (val !== 0);
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                s.gzindex = 0;
            }
            s.status = COMMENT_STATE;
        }
        if (s.status === COMMENT_STATE) {
            if (s.gzhead.comment) {
                let beg = s.pending;
                let val;
                do {
                    if (s.pending === s.pending_buf_size) {
                        if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                        }
                        flush_pending(strm);
                        if (s.pending !== 0) {
                            s.last_flush = -1;
                            return Z_OK$3;
                        }
                        beg = 0;
                    }
                    if (s.gzindex < s.gzhead.comment.length) {
                        val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                    } else {
                        val = 0;
                    }
                    put_byte(s, val);
                } while (val !== 0);
                if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
            }
            s.status = HCRC_STATE;
        }
        if (s.status === HCRC_STATE) {
            if (s.gzhead.hcrc) {
                if (s.pending + 2 > s.pending_buf_size) {
                    flush_pending(strm);
                    if (s.pending !== 0) {
                        s.last_flush = -1;
                        return Z_OK$3;
                    }
                }
                put_byte(s, strm.adler & 255);
                put_byte(s, strm.adler >> 8 & 255);
                strm.adler = 0;
            }
            s.status = BUSY_STATE;
            flush_pending(strm);
            if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK$3;
            }
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
            let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                s.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                if (strm.avail_out === 0) {
                    s.last_flush = -1;
                }
                return Z_OK$3;
            }
            if (bstate === BS_BLOCK_DONE) {
                if (flush === Z_PARTIAL_FLUSH) {
                    _tr_align(s);
                } else if (flush !== Z_BLOCK$1) {
                    _tr_stored_block(s, 0, 0, false);
                    if (flush === Z_FULL_FLUSH$1) {
                        zero(s.head);
                        if (s.lookahead === 0) {
                            s.strstart = 0;
                            s.block_start = 0;
                            s.insert = 0;
                        }
                    }
                }
                flush_pending(strm);
                if (strm.avail_out === 0) {
                    s.last_flush = -1;
                    return Z_OK$3;
                }
            }
        }
        if (flush !== Z_FINISH$3) {
            return Z_OK$3;
        }
        if (s.wrap <= 0) {
            return Z_STREAM_END$3;
        }
        if (s.wrap === 2) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            put_byte(s, strm.adler >> 16 & 255);
            put_byte(s, strm.adler >> 24 & 255);
            put_byte(s, strm.total_in & 255);
            put_byte(s, strm.total_in >> 8 & 255);
            put_byte(s, strm.total_in >> 16 & 255);
            put_byte(s, strm.total_in >> 24 & 255);
        } else {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
            s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
    };
    const deflateEnd = strm => {
        if (deflateStateCheck(strm)) {
            return Z_STREAM_ERROR$2;
        }
        const status = strm.state.status;
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
    };
    const deflateSetDictionary = (strm, dictionary) => {
        let dictLength = dictionary.length;
        if (deflateStateCheck(strm)) {
            return Z_STREAM_ERROR$2;
        }
        const s = strm.state;
        const wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
            return Z_STREAM_ERROR$2;
        }
        if (wrap === 1) {
            strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
            if (wrap === 0) {
                zero(s.head);
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
            }
            let tmpDict = new Uint8Array(s.w_size);
            tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
            dictionary = tmpDict;
            dictLength = s.w_size;
        }
        const avail = strm.avail_in;
        const next = strm.next_in;
        const input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
            let str = s.strstart;
            let n = s.lookahead - (MIN_MATCH - 1);
            do {
                s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
            } while (--n);
            s.strstart = str;
            s.lookahead = MIN_MATCH - 1;
            fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK$3;
    };
    var deflateInit_1 = deflateInit;
    var deflateInit2_1 = deflateInit2;
    var deflateReset_1 = deflateReset;
    var deflateResetKeep_1 = deflateResetKeep;
    var deflateSetHeader_1 = deflateSetHeader;
    var deflate_2$1 = deflate$2;
    var deflateEnd_1 = deflateEnd;
    var deflateSetDictionary_1 = deflateSetDictionary;
    var deflateInfo = "pako deflate (from Nodeca project)";
    var deflate_1$2 = {
        deflateInit: deflateInit_1,
        deflateInit2: deflateInit2_1,
        deflateReset: deflateReset_1,
        deflateResetKeep: deflateResetKeep_1,
        deflateSetHeader: deflateSetHeader_1,
        deflate: deflate_2$1,
        deflateEnd: deflateEnd_1,
        deflateSetDictionary: deflateSetDictionary_1,
        deflateInfo
    };
    const _has = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
    var pako_esm_assign = function(obj) {
        const sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
            const source = sources.shift();
            if (!source) {
                continue;
            }
            if (typeof source !== "object") {
                throw new TypeError(source + "must be non-object");
            }
            for (const p in source) {
                if (_has(source, p)) {
                    obj[p] = source[p];
                }
            }
        }
        return obj;
    };
    var flattenChunks = chunks => {
        let len = 0;
        for (let i = 0, l = chunks.length; i < l; i++) {
            len += chunks[i].length;
        }
        const result = new Uint8Array(len);
        for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
            let chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length;
        }
        return result;
    };
    var common = {
        assign: pako_esm_assign,
        flattenChunks
    };
    let STR_APPLY_UIA_OK = true;
    try {
        String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
        STR_APPLY_UIA_OK = false;
    }
    const _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = str => {
        if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
            return (new TextEncoder).encode(str);
        }
        let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 64512) === 56320) {
                    c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                    m_pos++;
                }
            }
            buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
        }
        buf = new Uint8Array(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 64512) === 56320) {
                    c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                    m_pos++;
                }
            }
            if (c < 128) {
                buf[i++] = c;
            } else if (c < 2048) {
                buf[i++] = 192 | c >>> 6;
                buf[i++] = 128 | c & 63;
            } else if (c < 65536) {
                buf[i++] = 224 | c >>> 12;
                buf[i++] = 128 | c >>> 6 & 63;
                buf[i++] = 128 | c & 63;
            } else {
                buf[i++] = 240 | c >>> 18;
                buf[i++] = 128 | c >>> 12 & 63;
                buf[i++] = 128 | c >>> 6 & 63;
                buf[i++] = 128 | c & 63;
            }
        }
        return buf;
    };
    const buf2binstring = (buf, len) => {
        if (len < 65534) {
            if (buf.subarray && STR_APPLY_UIA_OK) {
                return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
            }
        }
        let result = "";
        for (let i = 0; i < len; i++) {
            result += String.fromCharCode(buf[i]);
        }
        return result;
    };
    var buf2string = (buf, max) => {
        const len = max || buf.length;
        if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
            return (new TextDecoder).decode(buf.subarray(0, max));
        }
        let i, out;
        const utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len; ) {
            let c = buf[i++];
            if (c < 128) {
                utf16buf[out++] = c;
                continue;
            }
            let c_len = _utf8len[c];
            if (c_len > 4) {
                utf16buf[out++] = 65533;
                i += c_len - 1;
                continue;
            }
            c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
            while (c_len > 1 && i < len) {
                c = c << 6 | buf[i++] & 63;
                c_len--;
            }
            if (c_len > 1) {
                utf16buf[out++] = 65533;
                continue;
            }
            if (c < 65536) {
                utf16buf[out++] = c;
            } else {
                c -= 65536;
                utf16buf[out++] = 55296 | c >> 10 & 1023;
                utf16buf[out++] = 56320 | c & 1023;
            }
        }
        return buf2binstring(utf16buf, out);
    };
    var utf8border = (buf, max) => {
        max = max || buf.length;
        if (max > buf.length) {
            max = buf.length;
        }
        let pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
            pos--;
        }
        if (pos < 0) {
            return max;
        }
        if (pos === 0) {
            return max;
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
    var strings = {
        string2buf,
        buf2string,
        utf8border
    };
    function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
    }
    var zstream = ZStream;
    const toString$1 = Object.prototype.toString;
    const {Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2, Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED: Z_DEFLATED$1} = constants$2;
    function Deflate$1(options) {
        this.options = common.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED$1,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY
        }, options || {});
        let opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
            opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
            opt.windowBits += 16;
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new zstream;
        this.strm.avail_out = 0;
        let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
        if (status !== Z_OK$2) {
            throw new Error(messages[status]);
        }
        if (opt.header) {
            deflate_1$2.deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
            let dict;
            if (typeof opt.dictionary === "string") {
                dict = strings.string2buf(opt.dictionary);
            } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
                dict = new Uint8Array(opt.dictionary);
            } else {
                dict = opt.dictionary;
            }
            status = deflate_1$2.deflateSetDictionary(this.strm, dict);
            if (status !== Z_OK$2) {
                throw new Error(messages[status]);
            }
            this._dict_set = true;
        }
    }
    Deflate$1.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        let status, _flush_mode;
        if (this.ended) {
            return false;
        }
        if (flush_mode === ~~flush_mode) _flush_mode = flush_mode; else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
        if (typeof data === "string") {
            strm.input = strings.string2buf(data);
        } else if (toString$1.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
        } else {
            strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for (;;) {
            if (strm.avail_out === 0) {
                strm.output = new Uint8Array(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
            }
            if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
                this.onData(strm.output.subarray(0, strm.next_out));
                strm.avail_out = 0;
                continue;
            }
            status = deflate_1$2.deflate(strm, _flush_mode);
            if (status === Z_STREAM_END$2) {
                if (strm.next_out > 0) {
                    this.onData(strm.output.subarray(0, strm.next_out));
                }
                status = deflate_1$2.deflateEnd(this.strm);
                this.onEnd(status);
                this.ended = true;
                return status === Z_OK$2;
            }
            if (strm.avail_out === 0) {
                this.onData(strm.output);
                continue;
            }
            if (_flush_mode > 0 && strm.next_out > 0) {
                this.onData(strm.output.subarray(0, strm.next_out));
                strm.avail_out = 0;
                continue;
            }
            if (strm.avail_in === 0) break;
        }
        return true;
    };
    Deflate$1.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
    };
    Deflate$1.prototype.onEnd = function(status) {
        if (status === Z_OK$2) {
            this.result = common.flattenChunks(this.chunks);
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
    };
    function deflate$1(input, options) {
        const deflator = new Deflate$1(options);
        deflator.push(input, true);
        if (deflator.err) {
            throw deflator.msg || messages[deflator.err];
        }
        return deflator.result;
    }
    function deflateRaw$1(input, options) {
        options = options || {};
        options.raw = true;
        return deflate$1(input, options);
    }
    function gzip$1(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate$1(input, options);
    }
    var Deflate_1$1 = Deflate$1;
    var deflate_2 = deflate$1;
    var deflateRaw_1$1 = deflateRaw$1;
    var gzip_1$1 = gzip$1;
    var constants$1 = constants$2;
    var deflate_1$1 = {
        Deflate: Deflate_1$1,
        deflate: deflate_2,
        deflateRaw: deflateRaw_1$1,
        gzip: gzip_1$1,
        constants: constants$1
    };
    const BAD$1 = 16209;
    const TYPE$1 = 16191;
    var inffast = function inflate_fast(strm, start) {
        let _in;
        let last;
        let _out;
        let beg;
        let end;
        let dmax;
        let wsize;
        let whave;
        let wnext;
        let s_window;
        let hold;
        let bits;
        let lcode;
        let dcode;
        let lmask;
        let dmask;
        let here;
        let op;
        let len;
        let dist;
        let from;
        let from_source;
        let input, output;
        const state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top: do {
            if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
            }
            here = lcode[hold & lmask];
            dolen: for (;;) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                    output[_out++] = here & 65535;
                } else if (op & 16) {
                    len = here & 65535;
                    op &= 15;
                    if (op) {
                        if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                        }
                        len += hold & (1 << op) - 1;
                        hold >>>= op;
                        bits -= op;
                    }
                    if (bits < 15) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        hold += input[_in++] << bits;
                        bits += 8;
                    }
                    here = dcode[hold & dmask];
                    dodist: for (;;) {
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op & 16) {
                            dist = here & 65535;
                            op &= 15;
                            if (bits < op) {
                                hold += input[_in++] << bits;
                                bits += 8;
                                if (bits < op) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                }
                            }
                            dist += hold & (1 << op) - 1;
                            if (dist > dmax) {
                                strm.msg = "invalid distance too far back";
                                state.mode = BAD$1;
                                break top;
                            }
                            hold >>>= op;
                            bits -= op;
                            op = _out - beg;
                            if (dist > op) {
                                op = dist - op;
                                if (op > whave) {
                                    if (state.sane) {
                                        strm.msg = "invalid distance too far back";
                                        state.mode = BAD$1;
                                        break top;
                                    }
                                }
                                from = 0;
                                from_source = s_window;
                                if (wnext === 0) {
                                    from += wsize - op;
                                    if (op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = _out - dist;
                                        from_source = output;
                                    }
                                } else if (wnext < op) {
                                    from += wsize + wnext - op;
                                    op -= wnext;
                                    if (op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = 0;
                                        if (wnext < len) {
                                            op = wnext;
                                            len -= op;
                                            do {
                                                output[_out++] = s_window[from++];
                                            } while (--op);
                                            from = _out - dist;
                                            from_source = output;
                                        }
                                    }
                                } else {
                                    from += wnext - op;
                                    if (op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = _out - dist;
                                        from_source = output;
                                    }
                                }
                                while (len > 2) {
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    output[_out++] = from_source[from++];
                                    len -= 3;
                                }
                                if (len) {
                                    output[_out++] = from_source[from++];
                                    if (len > 1) {
                                        output[_out++] = from_source[from++];
                                    }
                                }
                            } else {
                                from = _out - dist;
                                do {
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    output[_out++] = output[from++];
                                    len -= 3;
                                } while (len > 2);
                                if (len) {
                                    output[_out++] = output[from++];
                                    if (len > 1) {
                                        output[_out++] = output[from++];
                                    }
                                }
                            }
                        } else if ((op & 64) === 0) {
                            here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                            continue dodist;
                        } else {
                            strm.msg = "invalid distance code";
                            state.mode = BAD$1;
                            break top;
                        }
                        break;
                    }
                } else if ((op & 64) === 0) {
                    here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dolen;
                } else if (op & 32) {
                    state.mode = TYPE$1;
                    break top;
                } else {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD$1;
                    break top;
                }
                break;
            }
        } while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
    };
    const MAXBITS = 15;
    const ENOUGH_LENS$1 = 852;
    const ENOUGH_DISTS$1 = 592;
    const CODES$1 = 0;
    const LENS$1 = 1;
    const DISTS$1 = 2;
    const lbase = new Uint16Array([ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ]);
    const lext = new Uint8Array([ 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78 ]);
    const dbase = new Uint16Array([ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 ]);
    const dext = new Uint8Array([ 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64 ]);
    const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
        const bits = opts.bits;
        let len = 0;
        let sym = 0;
        let min = 0, max = 0;
        let root = 0;
        let curr = 0;
        let drop = 0;
        let left = 0;
        let used = 0;
        let huff = 0;
        let incr;
        let fill;
        let low;
        let mask;
        let next;
        let base = null;
        let match;
        const count = new Uint16Array(MAXBITS + 1);
        const offs = new Uint16Array(MAXBITS + 1);
        let extra = null;
        let here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
            count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
            count[lens[lens_index + sym]]++;
        }
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
            if (count[max] !== 0) {
                break;
            }
        }
        if (root > max) {
            root = max;
        }
        if (max === 0) {
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            opts.bits = 1;
            return 0;
        }
        for (min = 1; min < max; min++) {
            if (count[min] !== 0) {
                break;
            }
        }
        if (root < min) {
            root = min;
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
            left <<= 1;
            left -= count[len];
            if (left < 0) {
                return -1;
            }
        }
        if (left > 0 && (type === CODES$1 || max !== 1)) {
            return -1;
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
            offs[len + 1] = offs[len] + count[len];
        }
        for (sym = 0; sym < codes; sym++) {
            if (lens[lens_index + sym] !== 0) {
                work[offs[lens[lens_index + sym]]++] = sym;
            }
        }
        if (type === CODES$1) {
            base = extra = work;
            match = 20;
        } else if (type === LENS$1) {
            base = lbase;
            extra = lext;
            match = 257;
        } else {
            base = dbase;
            extra = dext;
            match = 0;
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
            return 1;
        }
        for (;;) {
            here_bits = len - drop;
            if (work[sym] + 1 < match) {
                here_op = 0;
                here_val = work[sym];
            } else if (work[sym] >= match) {
                here_op = extra[work[sym] - match];
                here_val = base[work[sym] - match];
            } else {
                here_op = 32 + 64;
                here_val = 0;
            }
            incr = 1 << len - drop;
            fill = 1 << curr;
            min = fill;
            do {
                fill -= incr;
                table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
            } while (fill !== 0);
            incr = 1 << len - 1;
            while (huff & incr) {
                incr >>= 1;
            }
            if (incr !== 0) {
                huff &= incr - 1;
                huff += incr;
            } else {
                huff = 0;
            }
            sym++;
            if (--count[len] === 0) {
                if (len === max) {
                    break;
                }
                len = lens[lens_index + work[sym]];
            }
            if (len > root && (huff & mask) !== low) {
                if (drop === 0) {
                    drop = root;
                }
                next += min;
                curr = len - drop;
                left = 1 << curr;
                while (curr + drop < max) {
                    left -= count[curr + drop];
                    if (left <= 0) {
                        break;
                    }
                    curr++;
                    left <<= 1;
                }
                used += 1 << curr;
                if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
                    return 1;
                }
                low = huff & mask;
                table[low] = root << 24 | curr << 16 | next - table_index | 0;
            }
        }
        if (huff !== 0) {
            table[next + huff] = len - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root;
        return 0;
    };
    var inftrees = inflate_table;
    const CODES = 0;
    const LENS = 1;
    const DISTS = 2;
    const {Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED} = constants$2;
    const HEAD = 16180;
    const FLAGS = 16181;
    const TIME = 16182;
    const OS = 16183;
    const EXLEN = 16184;
    const EXTRA = 16185;
    const NAME = 16186;
    const COMMENT = 16187;
    const HCRC = 16188;
    const DICTID = 16189;
    const DICT = 16190;
    const TYPE = 16191;
    const TYPEDO = 16192;
    const STORED = 16193;
    const COPY_ = 16194;
    const COPY = 16195;
    const TABLE = 16196;
    const LENLENS = 16197;
    const CODELENS = 16198;
    const LEN_ = 16199;
    const LEN = 16200;
    const LENEXT = 16201;
    const DIST = 16202;
    const DISTEXT = 16203;
    const MATCH = 16204;
    const LIT = 16205;
    const CHECK = 16206;
    const LENGTH = 16207;
    const DONE = 16208;
    const BAD = 16209;
    const MEM = 16210;
    const SYNC = 16211;
    const ENOUGH_LENS = 852;
    const ENOUGH_DISTS = 592;
    const MAX_WBITS = 15;
    const DEF_WBITS = MAX_WBITS;
    const zswap32 = q => (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    function InflateState() {
        this.strm = null;
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new Uint16Array(320);
        this.work = new Uint16Array(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
    }
    const inflateStateCheck = strm => {
        if (!strm) {
            return 1;
        }
        const state = strm.state;
        if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
            return 1;
        }
        return 0;
    };
    const inflateResetKeep = strm => {
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
            strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.flags = -1;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
        state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK$1;
    };
    const inflateReset = strm => {
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
    };
    const inflateReset2 = (strm, windowBits) => {
        let wrap;
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
        } else {
            wrap = (windowBits >> 4) + 5;
            if (windowBits < 48) {
                windowBits &= 15;
            }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
            return Z_STREAM_ERROR$1;
        }
        if (state.window !== null && state.wbits !== windowBits) {
            state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
    };
    const inflateInit2 = (strm, windowBits) => {
        if (!strm) {
            return Z_STREAM_ERROR$1;
        }
        const state = new InflateState;
        strm.state = state;
        state.strm = strm;
        state.window = null;
        state.mode = HEAD;
        const ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK$1) {
            strm.state = null;
        }
        return ret;
    };
    const inflateInit = strm => inflateInit2(strm, DEF_WBITS);
    let virgin = true;
    let lenfix, distfix;
    const fixedtables = state => {
        if (virgin) {
            lenfix = new Int32Array(512);
            distfix = new Int32Array(32);
            let sym = 0;
            while (sym < 144) {
                state.lens[sym++] = 8;
            }
            while (sym < 256) {
                state.lens[sym++] = 9;
            }
            while (sym < 280) {
                state.lens[sym++] = 7;
            }
            while (sym < 288) {
                state.lens[sym++] = 8;
            }
            inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
                bits: 9
            });
            sym = 0;
            while (sym < 32) {
                state.lens[sym++] = 5;
            }
            inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
                bits: 5
            });
            virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
    };
    const updatewindow = (strm, src, end, copy) => {
        let dist;
        const state = strm.state;
        if (state.window === null) {
            state.wsize = 1 << state.wbits;
            state.wnext = 0;
            state.whave = 0;
            state.window = new Uint8Array(state.wsize);
        }
        if (copy >= state.wsize) {
            state.window.set(src.subarray(end - state.wsize, end), 0);
            state.wnext = 0;
            state.whave = state.wsize;
        } else {
            dist = state.wsize - state.wnext;
            if (dist > copy) {
                dist = copy;
            }
            state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
            copy -= dist;
            if (copy) {
                state.window.set(src.subarray(end - copy, end), 0);
                state.wnext = copy;
                state.whave = state.wsize;
            } else {
                state.wnext += dist;
                if (state.wnext === state.wsize) {
                    state.wnext = 0;
                }
                if (state.whave < state.wsize) {
                    state.whave += dist;
                }
            }
        }
        return 0;
    };
    const inflate$2 = (strm, flush) => {
        let state;
        let input, output;
        let next;
        let put;
        let have, left;
        let hold;
        let bits;
        let _in, _out;
        let copy;
        let from;
        let from_source;
        let here = 0;
        let here_bits, here_op, here_val;
        let last_bits, last_op, last_val;
        let len;
        let ret;
        const hbuf = new Uint8Array(4);
        let opts;
        let n;
        const order = new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);
        if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
            return Z_STREAM_ERROR$1;
        }
        state = strm.state;
        if (state.mode === TYPE) {
            state.mode = TYPEDO;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK$1;
        inf_leave: for (;;) {
            switch (state.mode) {
              case HEAD:
                if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                }
                while (bits < 16) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.wrap & 2 && hold === 35615) {
                    if (state.wbits === 0) {
                        state.wbits = 15;
                    }
                    state.check = 0;
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state.mode = FLAGS;
                    break;
                }
                if (state.head) {
                    state.head.done = false;
                }
                if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check";
                    state.mode = BAD;
                    break;
                }
                if ((hold & 15) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 15) + 8;
                if (state.wbits === 0) {
                    state.wbits = len;
                }
                if (len > 15 || len > state.wbits) {
                    strm.msg = "invalid window size";
                    state.mode = BAD;
                    break;
                }
                state.dmax = 1 << state.wbits;
                state.flags = 0;
                strm.adler = state.check = 1;
                state.mode = hold & 512 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;

              case FLAGS:
                while (bits < 16) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 255) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                }
                if (state.flags & 57344) {
                    strm.msg = "unknown header flags set";
                    state.mode = BAD;
                    break;
                }
                if (state.head) {
                    state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 512 && state.wrap & 4) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;

              case TIME:
                while (bits < 32) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.head) {
                    state.head.time = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    hbuf[2] = hold >>> 16 & 255;
                    hbuf[3] = hold >>> 24 & 255;
                    state.check = crc32_1(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;

              case OS:
                while (bits < 16) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state.head) {
                    state.head.xflags = hold & 255;
                    state.head.os = hold >> 8;
                }
                if (state.flags & 512 && state.wrap & 4) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;

              case EXLEN:
                if (state.flags & 1024) {
                    while (bits < 16) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.length = hold;
                    if (state.head) {
                        state.head.extra_len = hold;
                    }
                    if (state.flags & 512 && state.wrap & 4) {
                        hbuf[0] = hold & 255;
                        hbuf[1] = hold >>> 8 & 255;
                        state.check = crc32_1(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                } else if (state.head) {
                    state.head.extra = null;
                }
                state.mode = EXTRA;

              case EXTRA:
                if (state.flags & 1024) {
                    copy = state.length;
                    if (copy > have) {
                        copy = have;
                    }
                    if (copy) {
                        if (state.head) {
                            len = state.head.extra_len - state.length;
                            if (!state.head.extra) {
                                state.head.extra = new Uint8Array(state.head.extra_len);
                            }
                            state.head.extra.set(input.subarray(next, next + copy), len);
                        }
                        if (state.flags & 512 && state.wrap & 4) {
                            state.check = crc32_1(state.check, input, copy, next);
                        }
                        have -= copy;
                        next += copy;
                        state.length -= copy;
                    }
                    if (state.length) {
                        break inf_leave;
                    }
                }
                state.length = 0;
                state.mode = NAME;

              case NAME:
                if (state.flags & 2048) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    copy = 0;
                    do {
                        len = input[next + copy++];
                        if (state.head && len && state.length < 65536) {
                            state.head.name += String.fromCharCode(len);
                        }
                    } while (len && copy < have);
                    if (state.flags & 512 && state.wrap & 4) {
                        state.check = crc32_1(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                        break inf_leave;
                    }
                } else if (state.head) {
                    state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;

              case COMMENT:
                if (state.flags & 4096) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    copy = 0;
                    do {
                        len = input[next + copy++];
                        if (state.head && len && state.length < 65536) {
                            state.head.comment += String.fromCharCode(len);
                        }
                    } while (len && copy < have);
                    if (state.flags & 512 && state.wrap & 4) {
                        state.check = crc32_1(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                        break inf_leave;
                    }
                } else if (state.head) {
                    state.head.comment = null;
                }
                state.mode = HCRC;

              case HCRC:
                if (state.flags & 512) {
                    while (bits < 16) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (state.wrap & 4 && hold !== (state.check & 65535)) {
                        strm.msg = "header crc mismatch";
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;

              case DICTID:
                while (bits < 32) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;

              case DICT:
                if (state.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    return Z_NEED_DICT$1;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;

              case TYPE:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                    break inf_leave;
                }

              case TYPEDO:
                if (state.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state.mode = CHECK;
                    break;
                }
                while (bits < 3) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch (hold & 3) {
                  case 0:
                    state.mode = STORED;
                    break;

                  case 1:
                    fixedtables(state);
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                        hold >>>= 2;
                        bits -= 2;
                        break inf_leave;
                    }
                    break;

                  case 2:
                    state.mode = TABLE;
                    break;

                  case 3:
                    strm.msg = "invalid block type";
                    state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;

              case STORED:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while (bits < 32) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                    strm.msg = "invalid stored block lengths";
                    state.mode = BAD;
                    break;
                }
                state.length = hold & 65535;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                    break inf_leave;
                }

              case COPY_:
                state.mode = COPY;

              case COPY:
                copy = state.length;
                if (copy) {
                    if (copy > have) {
                        copy = have;
                    }
                    if (copy > left) {
                        copy = left;
                    }
                    if (copy === 0) {
                        break inf_leave;
                    }
                    output.set(input.subarray(next, next + copy), put);
                    have -= copy;
                    next += copy;
                    left -= copy;
                    put += copy;
                    state.length -= copy;
                    break;
                }
                state.mode = TYPE;
                break;

              case TABLE:
                while (bits < 14) {
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state.nlen = (hold & 31) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 31) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 15) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = "too many length or distance symbols";
                    state.mode = BAD;
                    break;
                }
                state.have = 0;
                state.mode = LENLENS;

              case LENLENS:
                while (state.have < state.ncode) {
                    while (bits < 3) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.lens[order[state.have++]] = hold & 7;
                    hold >>>= 3;
                    bits -= 3;
                }
                while (state.have < 19) {
                    state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = {
                    bits: state.lenbits
                };
                ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid code lengths set";
                    state.mode = BAD;
                    break;
                }
                state.have = 0;
                state.mode = CODELENS;

              case CODELENS:
                while (state.have < state.nlen + state.ndist) {
                    for (;;) {
                        here = state.lencode[hold & (1 << state.lenbits) - 1];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (here_val < 16) {
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state.lens[state.have++] = here_val;
                    } else {
                        if (here_val === 16) {
                            n = here_bits + 2;
                            while (bits < n) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            if (state.have === 0) {
                                strm.msg = "invalid bit length repeat";
                                state.mode = BAD;
                                break;
                            }
                            len = state.lens[state.have - 1];
                            copy = 3 + (hold & 3);
                            hold >>>= 2;
                            bits -= 2;
                        } else if (here_val === 17) {
                            n = here_bits + 3;
                            while (bits < n) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            len = 0;
                            copy = 3 + (hold & 7);
                            hold >>>= 3;
                            bits -= 3;
                        } else {
                            n = here_bits + 7;
                            while (bits < n) {
                                if (have === 0) {
                                    break inf_leave;
                                }
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            len = 0;
                            copy = 11 + (hold & 127);
                            hold >>>= 7;
                            bits -= 7;
                        }
                        if (state.have + copy > state.nlen + state.ndist) {
                            strm.msg = "invalid bit length repeat";
                            state.mode = BAD;
                            break;
                        }
                        while (copy--) {
                            state.lens[state.have++] = len;
                        }
                    }
                }
                if (state.mode === BAD) {
                    break;
                }
                if (state.lens[256] === 0) {
                    strm.msg = "invalid code -- missing end-of-block";
                    state.mode = BAD;
                    break;
                }
                state.lenbits = 9;
                opts = {
                    bits: state.lenbits
                };
                ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid literal/lengths set";
                    state.mode = BAD;
                    break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = {
                    bits: state.distbits
                };
                ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid distances set";
                    state.mode = BAD;
                    break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                    break inf_leave;
                }

              case LEN_:
                state.mode = LEN;

              case LEN:
                if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    inffast(strm, _out);
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    if (state.mode === TYPE) {
                        state.back = -1;
                    }
                    break;
                }
                state.back = 0;
                for (;;) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                        break;
                    }
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (;;) {
                        here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (last_bits + here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                    state.mode = LIT;
                    break;
                }
                if (here_op & 32) {
                    state.back = -1;
                    state.mode = TYPE;
                    break;
                }
                if (here_op & 64) {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;

              case LENEXT:
                if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;

              case DIST:
                for (;;) {
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                        break;
                    }
                    if (have === 0) {
                        break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if ((here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (;;) {
                        here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (last_bits + here_bits <= bits) {
                            break;
                        }
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;

              case DISTEXT:
                if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                }
                state.mode = MATCH;

              case MATCH:
                if (left === 0) {
                    break inf_leave;
                }
                copy = _out - left;
                if (state.offset > copy) {
                    copy = state.offset - copy;
                    if (copy > state.whave) {
                        if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break;
                        }
                    }
                    if (copy > state.wnext) {
                        copy -= state.wnext;
                        from = state.wsize - copy;
                    } else {
                        from = state.wnext - copy;
                    }
                    if (copy > state.length) {
                        copy = state.length;
                    }
                    from_source = state.window;
                } else {
                    from_source = output;
                    from = put - state.offset;
                    copy = state.length;
                }
                if (copy > left) {
                    copy = left;
                }
                left -= copy;
                state.length -= copy;
                do {
                    output[put++] = from_source[from++];
                } while (--copy);
                if (state.length === 0) {
                    state.mode = LEN;
                }
                break;

              case LIT:
                if (left === 0) {
                    break inf_leave;
                }
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;

              case CHECK:
                if (state.wrap) {
                    while (bits < 32) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold |= input[next++] << bits;
                        bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;
                    if (state.wrap & 4 && _out) {
                        strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
                    }
                    _out = left;
                    if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                        strm.msg = "incorrect data check";
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                state.mode = LENGTH;

              case LENGTH:
                if (state.wrap && state.flags) {
                    while (bits < 32) {
                        if (have === 0) {
                            break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                        strm.msg = "incorrect length check";
                        state.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                state.mode = DONE;

              case DONE:
                ret = Z_STREAM_END$1;
                break inf_leave;

              case BAD:
                ret = Z_DATA_ERROR$1;
                break inf_leave;

              case MEM:
                return Z_MEM_ERROR$1;

              case SYNC:
              default:
                return Z_STREAM_ERROR$1;
            }
        }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap & 4 && _out) {
            strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
            ret = Z_BUF_ERROR;
        }
        return ret;
    };
    const inflateEnd = strm => {
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        let state = strm.state;
        if (state.window) {
            state.window = null;
        }
        strm.state = null;
        return Z_OK$1;
    };
    const inflateGetHeader = (strm, head) => {
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        const state = strm.state;
        if ((state.wrap & 2) === 0) {
            return Z_STREAM_ERROR$1;
        }
        state.head = head;
        head.done = false;
        return Z_OK$1;
    };
    const inflateSetDictionary = (strm, dictionary) => {
        const dictLength = dictionary.length;
        let state;
        let dictid;
        let ret;
        if (inflateStateCheck(strm)) {
            return Z_STREAM_ERROR$1;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
            return Z_STREAM_ERROR$1;
        }
        if (state.mode === DICT) {
            dictid = 1;
            dictid = adler32_1(dictid, dictionary, dictLength, 0);
            if (dictid !== state.check) {
                return Z_DATA_ERROR$1;
            }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
            state.mode = MEM;
            return Z_MEM_ERROR$1;
        }
        state.havedict = 1;
        return Z_OK$1;
    };
    var inflateReset_1 = inflateReset;
    var inflateReset2_1 = inflateReset2;
    var inflateResetKeep_1 = inflateResetKeep;
    var inflateInit_1 = inflateInit;
    var inflateInit2_1 = inflateInit2;
    var inflate_2$1 = inflate$2;
    var inflateEnd_1 = inflateEnd;
    var inflateGetHeader_1 = inflateGetHeader;
    var inflateSetDictionary_1 = inflateSetDictionary;
    var inflateInfo = "pako inflate (from Nodeca project)";
    var inflate_1$2 = {
        inflateReset: inflateReset_1,
        inflateReset2: inflateReset2_1,
        inflateResetKeep: inflateResetKeep_1,
        inflateInit: inflateInit_1,
        inflateInit2: inflateInit2_1,
        inflate: inflate_2$1,
        inflateEnd: inflateEnd_1,
        inflateGetHeader: inflateGetHeader_1,
        inflateSetDictionary: inflateSetDictionary_1,
        inflateInfo
    };
    function GZheader() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false;
    }
    var gzheader = GZheader;
    const pako_esm_toString = Object.prototype.toString;
    const {Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR} = constants$2;
    function Inflate$1(options) {
        this.options = common.assign({
            chunkSize: 1024 * 64,
            windowBits: 15,
            to: ""
        }, options || {});
        const opt = this.options;
        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
            opt.windowBits = -opt.windowBits;
            if (opt.windowBits === 0) {
                opt.windowBits = -15;
            }
        }
        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
            opt.windowBits += 32;
        }
        if (opt.windowBits > 15 && opt.windowBits < 48) {
            if ((opt.windowBits & 15) === 0) {
                opt.windowBits |= 15;
            }
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new zstream;
        this.strm.avail_out = 0;
        let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
        if (status !== Z_OK) {
            throw new Error(messages[status]);
        }
        this.header = new gzheader;
        inflate_1$2.inflateGetHeader(this.strm, this.header);
        if (opt.dictionary) {
            if (typeof opt.dictionary === "string") {
                opt.dictionary = strings.string2buf(opt.dictionary);
            } else if (pako_esm_toString.call(opt.dictionary) === "[object ArrayBuffer]") {
                opt.dictionary = new Uint8Array(opt.dictionary);
            }
            if (opt.raw) {
                status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
                if (status !== Z_OK) {
                    throw new Error(messages[status]);
                }
            }
        }
    }
    Inflate$1.prototype.push = function(data, flush_mode) {
        const strm = this.strm;
        const chunkSize = this.options.chunkSize;
        const dictionary = this.options.dictionary;
        let status, _flush_mode, last_avail_out;
        if (this.ended) return false;
        if (flush_mode === ~~flush_mode) _flush_mode = flush_mode; else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (pako_esm_toString.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
        } else {
            strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        for (;;) {
            if (strm.avail_out === 0) {
                strm.output = new Uint8Array(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
            }
            status = inflate_1$2.inflate(strm, _flush_mode);
            if (status === Z_NEED_DICT && dictionary) {
                status = inflate_1$2.inflateSetDictionary(strm, dictionary);
                if (status === Z_OK) {
                    status = inflate_1$2.inflate(strm, _flush_mode);
                } else if (status === Z_DATA_ERROR) {
                    status = Z_NEED_DICT;
                }
            }
            while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
                inflate_1$2.inflateReset(strm);
                status = inflate_1$2.inflate(strm, _flush_mode);
            }
            switch (status) {
              case Z_STREAM_ERROR:
              case Z_DATA_ERROR:
              case Z_NEED_DICT:
              case Z_MEM_ERROR:
                this.onEnd(status);
                this.ended = true;
                return false;
            }
            last_avail_out = strm.avail_out;
            if (strm.next_out) {
                if (strm.avail_out === 0 || status === Z_STREAM_END) {
                    if (this.options.to === "string") {
                        let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                        let tail = strm.next_out - next_out_utf8;
                        let utf8str = strings.buf2string(strm.output, next_out_utf8);
                        strm.next_out = tail;
                        strm.avail_out = chunkSize - tail;
                        if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
                        this.onData(utf8str);
                    } else {
                        this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
                    }
                }
            }
            if (status === Z_OK && last_avail_out === 0) continue;
            if (status === Z_STREAM_END) {
                status = inflate_1$2.inflateEnd(this.strm);
                this.onEnd(status);
                this.ended = true;
                return true;
            }
            if (strm.avail_in === 0) break;
        }
        return true;
    };
    Inflate$1.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
    };
    Inflate$1.prototype.onEnd = function(status) {
        if (status === Z_OK) {
            if (this.options.to === "string") {
                this.result = this.chunks.join("");
            } else {
                this.result = common.flattenChunks(this.chunks);
            }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
    };
    function inflate$1(input, options) {
        const inflator = new Inflate$1(options);
        inflator.push(input);
        if (inflator.err) throw inflator.msg || messages[inflator.err];
        return inflator.result;
    }
    function inflateRaw$1(input, options) {
        options = options || {};
        options.raw = true;
        return inflate$1(input, options);
    }
    var Inflate_1$1 = Inflate$1;
    var inflate_2 = inflate$1;
    var inflateRaw_1$1 = inflateRaw$1;
    var ungzip$1 = inflate$1;
    var constants = constants$2;
    var inflate_1$1 = {
        Inflate: Inflate_1$1,
        inflate: inflate_2,
        inflateRaw: inflateRaw_1$1,
        ungzip: ungzip$1,
        constants
    };
    const {Deflate, deflate, deflateRaw, gzip} = deflate_1$1;
    const {Inflate, inflate, inflateRaw, ungzip} = inflate_1$1;
    var Deflate_1 = Deflate;
    var deflate_1 = deflate;
    var deflateRaw_1 = deflateRaw;
    var gzip_1 = gzip;
    var Inflate_1 = Inflate;
    var inflate_1 = inflate;
    var inflateRaw_1 = inflateRaw;
    var ungzip_1 = ungzip;
    var constants_1 = constants$2;
    var pako = {
        Deflate: Deflate_1,
        deflate: deflate_1,
        deflateRaw: deflateRaw_1,
        gzip: gzip_1,
        Inflate: Inflate_1,
        inflate: inflate_1,
        inflateRaw: inflateRaw_1,
        ungzip: ungzip_1,
        constants: constants_1
    };
    async function fetchCode(multithreaded, wasmPath) {
        let url;
        if (wasmPath) {
            const suffix = multithreaded ? "-threads" : "";
            const filePath = wasmPath.split("/").slice(0, -1).join("/");
            const fileNameWithExtensions = wasmPath.split("/").pop();
            const [fileName, ...extensions] = fileNameWithExtensions.split(".");
            url = `${filePath}/${fileName}${suffix}.${extensions.join(".")}`;
        } else {
            url = multithreaded ? (await import("./barretenberg-threads.js")).default : (await import("./barretenberg.js")).default;
        }
        const res = await fetch(url);
        const maybeCompressedData = await res.arrayBuffer();
        const buffer = new Uint8Array(maybeCompressedData);
        const isGzip = buffer[0] === 31 && buffer[1] === 139 && buffer[2] === 8;
        if (isGzip) {
            const decompressedData = pako.ungzip(buffer);
            return decompressedData.buffer;
        } else {
            return buffer;
        }
    }
    async function fetchModuleAndThreads(desiredThreads = 32, wasmPath, logger = browser_default()("bb.js:fetch_mat")) {
        const shared = getSharedMemoryAvailable();
        const availableThreads = shared ? await getAvailableThreads(logger) : 1;
        const limitedThreads = Math.min(desiredThreads, availableThreads, 32);
        logger(`Fetching bb wasm from ${wasmPath ?? "default location"}`);
        const code = await fetchCode(shared, wasmPath);
        logger(`Compiling bb wasm of ${code.byteLength} bytes`);
        const module = await WebAssembly.compile(code);
        logger("Compilation of bb wasm complete");
        return {
            module,
            threads: limitedThreads
        };
    }
    async function getAvailableThreads(logger) {
        if (typeof navigator !== "undefined" && navigator.hardwareConcurrency) {
            return navigator.hardwareConcurrency;
        } else {
            try {
                const os = await __webpack_require__.e(522).then(__webpack_require__.t.bind(__webpack_require__, 522, 23));
                return os.cpus().length;
            } catch (e) {
                logger(`Could not detect environment to query number of threads. Falling back to one thread. Error: ${e.message ?? e}`);
                return 1;
            }
        }
    }
    class BarretenbergWasm extends(null && BarretenbergWasmMain){
        static async new(desiredThreads, wasmPath, logger = createDebug("bb.js:bb_wasm_main")) {
            const worker = createMainWorker();
            const wasm = getRemoteBarretenbergWasm(worker);
            const {module, threads} = await fetchModuleAndThreads(desiredThreads, wasmPath, logger);
            await wasm.init(module, threads, proxy(logger));
            return {
                worker,
                wasm
            };
        }
    }
    const fieldByteSize = 32;
    function splitHonkProof(proofWithPublicInputs, numPublicInputs) {
        const publicInputs = proofWithPublicInputs.slice(0, numPublicInputs * fieldByteSize);
        const proof = proofWithPublicInputs.slice(numPublicInputs * fieldByteSize);
        return {
            proof,
            publicInputs
        };
    }
    function reconstructHonkProof(publicInputs, proof) {
        const proofWithPublicInputs = Uint8Array.from([ ...publicInputs, ...proof ]);
        return proofWithPublicInputs;
    }
    function reconstructUltraPlonkProof(proofData) {
        const publicInputsConcatenated = flattenFieldsAsArray(proofData.publicInputs);
        const proofWithPublicInputs = Uint8Array.from([ ...publicInputsConcatenated, ...proofData.proof ]);
        return proofWithPublicInputs;
    }
    function deflattenFields(flattenedFields) {
        const publicInputSize = 32;
        const chunkedFlattenedPublicInputs = [];
        for (let i = 0; i < flattenedFields.length; i += publicInputSize) {
            const publicInput = flattenedFields.slice(i, i + publicInputSize);
            chunkedFlattenedPublicInputs.push(publicInput);
        }
        return chunkedFlattenedPublicInputs.map(uint8ArrayToHex);
    }
    function flattenFieldsAsArray(fields) {
        const flattenedPublicInputs = fields.map(hexToUint8Array);
        return flattenUint8Arrays(flattenedPublicInputs);
    }
    function flattenUint8Arrays(arrays) {
        const totalLength = arrays.reduce(((acc, val) => acc + val.length), 0);
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for (const arr of arrays) {
            result.set(arr, offset);
            offset += arr.length;
        }
        return result;
    }
    function uint8ArrayToHex(buffer) {
        const hex = [];
        buffer.forEach((function(i) {
            let h = i.toString(16);
            if (h.length % 2) {
                h = "0" + h;
            }
            hex.push(h);
        }));
        return "0x" + hex.join("");
    }
    function hexToUint8Array(hex) {
        const sanitisedHex = BigInt(hex).toString(16).padStart(64, "0");
        const len = sanitisedHex.length / 2;
        const u8 = new Uint8Array(len);
        let i = 0;
        let j = 0;
        while (i < len) {
            u8[i] = parseInt(sanitisedHex.slice(j, j + 2), 16);
            i += 1;
            j += 2;
        }
        return u8;
    }
    class BarretenbergVerifier {
        constructor(options = {
            threads: 1
        }) {
            this.options = options;
        }
        async instantiate() {
            if (!this.api) {
                const api = await Barretenberg.new(this.options);
                await api.initSRSForCircuitSize(0);
                this.acirComposer = await api.acirNewAcirComposer(0);
                this.api = api;
            }
        }
        async verifyUltraPlonkProof(proofData, verificationKey) {
            await this.instantiate();
            await this.api.acirLoadVerificationKey(this.acirComposer, new RawBuffer(verificationKey));
            const proof = reconstructUltraPlonkProof(proofData);
            return await this.api.acirVerifyProof(this.acirComposer, proof);
        }
        async verifyUltraHonkProof(proofData, verificationKey) {
            await this.instantiate();
            const proof = reconstructHonkProof(flattenFieldsAsArray(proofData.publicInputs), proofData.proof);
            return await this.api.acirVerifyUltraHonk(proof, new RawBuffer(verificationKey));
        }
        async destroy() {
            if (!this.api) {
                return;
            }
            await this.api.destroy();
        }
    }
    var ch2 = {};
    var wk = function(c, id, msg, transfer, cb) {
        var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([ c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})' ], {
            type: "text/javascript"
        }))));
        w.onmessage = function(e) {
            var d = e.data, ed = d.$e$;
            if (ed) {
                var err = new Error(ed[0]);
                err["code"] = ed[1];
                err.stack = ed[2];
                cb(err, null);
            } else cb(null, d);
        };
        w.postMessage(msg, transfer);
        return w;
    };
    var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
    var fleb = new u8([ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0 ]);
    var fdeb = new u8([ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0 ]);
    var clim = new u8([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);
    var freb = function(eb, start) {
        var b = new u16(31);
        for (var i = 0; i < 31; ++i) {
            b[i] = start += 1 << eb[i - 1];
        }
        var r = new i32(b[30]);
        for (var i = 1; i < 30; ++i) {
            for (var j = b[i]; j < b[i + 1]; ++j) {
                r[j] = j - b[i] << 5 | i;
            }
        }
        return {
            b,
            r
        };
    };
    var browser_a = freb(fleb, 2), fl = browser_a.b, revfl = browser_a.r;
    fl[28] = 258, revfl[258] = 28;
    var browser_b = freb(fdeb, 0), fd = browser_b.b, revfd = browser_b.r;
    var rev = new u16(32768);
    for (var i = 0; i < 32768; ++i) {
        var x = (i & 43690) >> 1 | (i & 21845) << 1;
        x = (x & 52428) >> 2 | (x & 13107) << 2;
        x = (x & 61680) >> 4 | (x & 3855) << 4;
        rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
    }
    var hMap = function(cd, mb, r) {
        var s = cd.length;
        var i = 0;
        var l = new u16(mb);
        for (;i < s; ++i) {
            if (cd[i]) ++l[cd[i] - 1];
        }
        var le = new u16(mb);
        for (i = 1; i < mb; ++i) {
            le[i] = le[i - 1] + l[i - 1] << 1;
        }
        var co;
        if (r) {
            co = new u16(1 << mb);
            var rvb = 15 - mb;
            for (i = 0; i < s; ++i) {
                if (cd[i]) {
                    var sv = i << 4 | cd[i];
                    var r_1 = mb - cd[i];
                    var v = le[cd[i] - 1]++ << r_1;
                    for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
                        co[rev[v] >> rvb] = sv;
                    }
                }
            }
        } else {
            co = new u16(s);
            for (i = 0; i < s; ++i) {
                if (cd[i]) {
                    co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
                }
            }
        }
        return co;
    };
    var flt = new u8(288);
    for (var i = 0; i < 144; ++i) flt[i] = 8;
    for (var i = 144; i < 256; ++i) flt[i] = 9;
    for (var i = 256; i < 280; ++i) flt[i] = 7;
    for (var i = 280; i < 288; ++i) flt[i] = 8;
    var fdt = new u8(32);
    for (var i = 0; i < 32; ++i) fdt[i] = 5;
    var flm = null && hMap(flt, 9, 0), flrm = hMap(flt, 9, 1);
    var fdm = null && hMap(fdt, 5, 0), fdrm = hMap(fdt, 5, 1);
    var max = function(a) {
        var m = a[0];
        for (var i = 1; i < a.length; ++i) {
            if (a[i] > m) m = a[i];
        }
        return m;
    };
    var bits = function(d, p, m) {
        var o = p / 8 | 0;
        return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
    };
    var bits16 = function(d, p) {
        var o = p / 8 | 0;
        return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
    };
    var shft = function(p) {
        return (p + 7) / 8 | 0;
    };
    var slc = function(v, s, e) {
        if (s == null || s < 0) s = 0;
        if (e == null || e > v.length) e = v.length;
        return new u8(v.subarray(s, e));
    };
    var FlateErrorCode = {
        UnexpectedEOF: 0,
        InvalidBlockType: 1,
        InvalidLengthLiteral: 2,
        InvalidDistance: 3,
        StreamFinished: 4,
        NoStreamHandler: 5,
        InvalidHeader: 6,
        NoCallback: 7,
        InvalidUTF8: 8,
        ExtraFieldTooLong: 9,
        InvalidDate: 10,
        FilenameTooLong: 11,
        StreamFinishing: 12,
        InvalidZipData: 13,
        UnknownCompressionMethod: 14
    };
    var ec = [ "unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data" ];
    var browser_err = function(ind, msg, nt) {
        var e = new Error(msg || ec[ind]);
        e.code = ind;
        if (Error.captureStackTrace) Error.captureStackTrace(e, browser_err);
        if (!nt) throw e;
        return e;
    };
    var inflt = function(dat, st, buf, dict) {
        var sl = dat.length, dl = dict ? dict.length : 0;
        if (!sl || st.f && !st.l) return buf || new u8(0);
        var noBuf = !buf;
        var resize = noBuf || st.i != 2;
        var noSt = st.i;
        if (noBuf) buf = new u8(sl * 3);
        var cbuf = function(l) {
            var bl = buf.length;
            if (l > bl) {
                var nbuf = new u8(Math.max(bl * 2, l));
                nbuf.set(buf);
                buf = nbuf;
            }
        };
        var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
        var tbts = sl * 8;
        do {
            if (!lm) {
                final = bits(dat, pos, 1);
                var type = bits(dat, pos + 1, 3);
                pos += 3;
                if (!type) {
                    var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
                    if (t > sl) {
                        if (noSt) browser_err(0);
                        break;
                    }
                    if (resize) cbuf(bt + l);
                    buf.set(dat.subarray(s, t), bt);
                    st.b = bt += l, st.p = pos = t * 8, st.f = final;
                    continue;
                } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5; else if (type == 2) {
                    var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                    var tl = hLit + bits(dat, pos + 5, 31) + 1;
                    pos += 14;
                    var ldt = new u8(tl);
                    var clt = new u8(19);
                    for (var i = 0; i < hcLen; ++i) {
                        clt[clim[i]] = bits(dat, pos + i * 3, 7);
                    }
                    pos += hcLen * 3;
                    var clb = max(clt), clbmsk = (1 << clb) - 1;
                    var clm = hMap(clt, clb, 1);
                    for (var i = 0; i < tl; ) {
                        var r = clm[bits(dat, pos, clbmsk)];
                        pos += r & 15;
                        var s = r >> 4;
                        if (s < 16) {
                            ldt[i++] = s;
                        } else {
                            var c = 0, n = 0;
                            if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1]; else if (s == 17) n = 3 + bits(dat, pos, 7), 
                            pos += 3; else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;
                            while (n--) ldt[i++] = c;
                        }
                    }
                    var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                    lbt = max(lt);
                    dbt = max(dt);
                    lm = hMap(lt, lbt, 1);
                    dm = hMap(dt, dbt, 1);
                } else browser_err(1);
                if (pos > tbts) {
                    if (noSt) browser_err(0);
                    break;
                }
            }
            if (resize) cbuf(bt + 131072);
            var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
            var lpos = pos;
            for (;;lpos = pos) {
                var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
                pos += c & 15;
                if (pos > tbts) {
                    if (noSt) browser_err(0);
                    break;
                }
                if (!c) browser_err(2);
                if (sym < 256) buf[bt++] = sym; else if (sym == 256) {
                    lpos = pos, lm = null;
                    break;
                } else {
                    var add = sym - 254;
                    if (sym > 264) {
                        var i = sym - 257, b = fleb[i];
                        add = bits(dat, pos, (1 << b) - 1) + fl[i];
                        pos += b;
                    }
                    var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
                    if (!d) browser_err(3);
                    pos += d & 15;
                    var dt = fd[dsym];
                    if (dsym > 3) {
                        var b = fdeb[dsym];
                        dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
                    }
                    if (pos > tbts) {
                        if (noSt) browser_err(0);
                        break;
                    }
                    if (resize) cbuf(bt + 131072);
                    var end = bt + add;
                    if (bt < dt) {
                        var shift = dl - dt, dend = Math.min(dt, end);
                        if (shift + bt < 0) browser_err(3);
                        for (;bt < dend; ++bt) buf[bt] = dict[shift + bt];
                    }
                    for (;bt < end; ++bt) buf[bt] = buf[bt - dt];
                }
            }
            st.l = lm, st.p = lpos, st.b = bt, st.f = final;
            if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;
        } while (!final);
        return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
    };
    var wbits = function(d, p, v) {
        v <<= p & 7;
        var o = p / 8 | 0;
        d[o] |= v;
        d[o + 1] |= v >> 8;
    };
    var wbits16 = function(d, p, v) {
        v <<= p & 7;
        var o = p / 8 | 0;
        d[o] |= v;
        d[o + 1] |= v >> 8;
        d[o + 2] |= v >> 16;
    };
    var hTree = function(d, mb) {
        var t = [];
        for (var i = 0; i < d.length; ++i) {
            if (d[i]) t.push({
                s: i,
                f: d[i]
            });
        }
        var s = t.length;
        var t2 = t.slice();
        if (!s) return {
            t: et,
            l: 0
        };
        if (s == 1) {
            var v = new u8(t[0].s + 1);
            v[t[0].s] = 1;
            return {
                t: v,
                l: 1
            };
        }
        t.sort((function(a, b) {
            return a.f - b.f;
        }));
        t.push({
            s: -1,
            f: 25001
        });
        var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
        t[0] = {
            s: -1,
            f: l.f + r.f,
            l,
            r
        };
        while (i1 != s - 1) {
            l = t[t[i0].f < t[i2].f ? i0++ : i2++];
            r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
            t[i1++] = {
                s: -1,
                f: l.f + r.f,
                l,
                r
            };
        }
        var maxSym = t2[0].s;
        for (var i = 1; i < s; ++i) {
            if (t2[i].s > maxSym) maxSym = t2[i].s;
        }
        var tr = new u16(maxSym + 1);
        var mbt = ln(t[i1 - 1], tr, 0);
        if (mbt > mb) {
            var i = 0, dt = 0;
            var lft = mbt - mb, cst = 1 << lft;
            t2.sort((function(a, b) {
                return tr[b.s] - tr[a.s] || a.f - b.f;
            }));
            for (;i < s; ++i) {
                var i2_1 = t2[i].s;
                if (tr[i2_1] > mb) {
                    dt += cst - (1 << mbt - tr[i2_1]);
                    tr[i2_1] = mb;
                } else break;
            }
            dt >>= lft;
            while (dt > 0) {
                var i2_2 = t2[i].s;
                if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1; else ++i;
            }
            for (;i >= 0 && dt; --i) {
                var i2_3 = t2[i].s;
                if (tr[i2_3] == mb) {
                    --tr[i2_3];
                    ++dt;
                }
            }
            mbt = mb;
        }
        return {
            t: new u8(tr),
            l: mbt
        };
    };
    var ln = function(n, l, d) {
        return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
    };
    var lc = function(c) {
        var s = c.length;
        while (s && !c[--s]) ;
        var cl = new u16(++s);
        var cli = 0, cln = c[0], cls = 1;
        var w = function(v) {
            cl[cli++] = v;
        };
        for (var i = 1; i <= s; ++i) {
            if (c[i] == cln && i != s) ++cls; else {
                if (!cln && cls > 2) {
                    for (;cls > 138; cls -= 138) w(32754);
                    if (cls > 2) {
                        w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
                        cls = 0;
                    }
                } else if (cls > 3) {
                    w(cln), --cls;
                    for (;cls > 6; cls -= 6) w(8304);
                    if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;
                }
                while (cls--) w(cln);
                cls = 1;
                cln = c[i];
            }
        }
        return {
            c: cl.subarray(0, cli),
            n: s
        };
    };
    var clen = function(cf, cl) {
        var l = 0;
        for (var i = 0; i < cl.length; ++i) l += cf[i] * cl[i];
        return l;
    };
    var wfblk = function(out, pos, dat) {
        var s = dat.length;
        var o = shft(pos + 2);
        out[o] = s & 255;
        out[o + 1] = s >> 8;
        out[o + 2] = out[o] ^ 255;
        out[o + 3] = out[o + 1] ^ 255;
        for (var i = 0; i < s; ++i) out[o + i + 4] = dat[i];
        return (o + 4 + s) * 8;
    };
    var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
        wbits(out, p++, final);
        ++lf[256];
        var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;
        var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;
        var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
        var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
        var lcfreq = new u16(19);
        for (var i = 0; i < lclt.length; ++i) ++lcfreq[lclt[i] & 31];
        for (var i = 0; i < lcdt.length; ++i) ++lcfreq[lcdt[i] & 31];
        var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
        var nlcc = 19;
        for (;nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc) ;
        var flen = bl + 5 << 3;
        var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
        var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
        if (bs >= 0 && flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));
        var lm, ll, dm, dl;
        wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
        if (dtlen < ftlen) {
            lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
            var llm = hMap(lct, mlcb, 0);
            wbits(out, p, nlc - 257);
            wbits(out, p + 5, ndc - 1);
            wbits(out, p + 10, nlcc - 4);
            p += 14;
            for (var i = 0; i < nlcc; ++i) wbits(out, p + 3 * i, lct[clim[i]]);
            p += 3 * nlcc;
            var lcts = [ lclt, lcdt ];
            for (var it = 0; it < 2; ++it) {
                var clct = lcts[it];
                for (var i = 0; i < clct.length; ++i) {
                    var len = clct[i] & 31;
                    wbits(out, p, llm[len]), p += lct[len];
                    if (len > 15) wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
                }
            }
        } else {
            lm = flm, ll = flt, dm = fdm, dl = fdt;
        }
        for (var i = 0; i < li; ++i) {
            var sym = syms[i];
            if (sym > 255) {
                var len = sym >> 18 & 31;
                wbits16(out, p, lm[len + 257]), p += ll[len + 257];
                if (len > 7) wbits(out, p, sym >> 23 & 31), p += fleb[len];
                var dst = sym & 31;
                wbits16(out, p, dm[dst]), p += dl[dst];
                if (dst > 3) wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
            } else {
                wbits16(out, p, lm[sym]), p += ll[sym];
            }
        }
        wbits16(out, p, lm[256]);
        return p + ll[256];
    };
    var deo = new i32([ 65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632 ]);
    var et = new u8(0);
    var dflt = function(dat, lvl, plvl, pre, post, st) {
        var s = st.z || dat.length;
        var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
        var w = o.subarray(pre, o.length - post);
        var lst = st.l;
        var pos = (st.r || 0) & 7;
        if (lvl) {
            if (pos) w[0] = st.r >> 3;
            var opt = deo[lvl - 1];
            var n = opt >> 13, c = opt & 8191;
            var msk_1 = (1 << plvl) - 1;
            var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
            var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
            var hsh = function(i) {
                return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;
            };
            var syms = new i32(25e3);
            var lf = new u16(288), df = new u16(32);
            var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
            for (;i + 2 < s; ++i) {
                var hv = hsh(i);
                var imod = i & 32767, pimod = head[hv];
                prev[imod] = pimod;
                head[hv] = imod;
                if (wi <= i) {
                    var rem = s - i;
                    if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
                        pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
                        li = lc_1 = eb = 0, bs = i;
                        for (var j = 0; j < 286; ++j) lf[j] = 0;
                        for (var j = 0; j < 30; ++j) df[j] = 0;
                    }
                    var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
                    if (rem > 2 && hv == hsh(i - dif)) {
                        var maxn = Math.min(n, rem) - 1;
                        var maxd = Math.min(32767, i);
                        var ml = Math.min(258, rem);
                        while (dif <= maxd && --ch_1 && imod != pimod) {
                            if (dat[i + l] == dat[i + l - dif]) {
                                var nl = 0;
                                for (;nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl) ;
                                if (nl > l) {
                                    l = nl, d = dif;
                                    if (nl > maxn) break;
                                    var mmd = Math.min(dif, nl - 2);
                                    var md = 0;
                                    for (var j = 0; j < mmd; ++j) {
                                        var ti = i - dif + j & 32767;
                                        var pti = prev[ti];
                                        var cd = ti - pti & 32767;
                                        if (cd > md) md = cd, pimod = ti;
                                    }
                                }
                            }
                            imod = pimod, pimod = prev[imod];
                            dif += imod - pimod & 32767;
                        }
                    }
                    if (d) {
                        syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
                        var lin = revfl[l] & 31, din = revfd[d] & 31;
                        eb += fleb[lin] + fdeb[din];
                        ++lf[257 + lin];
                        ++df[din];
                        wi = i + l;
                        ++lc_1;
                    } else {
                        syms[li++] = dat[i];
                        ++lf[dat[i]];
                    }
                }
            }
            for (i = Math.max(i, wi); i < s; ++i) {
                syms[li++] = dat[i];
                ++lf[dat[i]];
            }
            pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
            if (!lst) {
                st.r = pos & 7 | w[pos / 8 | 0] << 3;
                pos -= 7;
                st.h = head, st.p = prev, st.i = i, st.w = wi;
            }
        } else {
            for (var i = st.w || 0; i < s + lst; i += 65535) {
                var e = i + 65535;
                if (e >= s) {
                    w[pos / 8 | 0] = lst;
                    e = s;
                }
                pos = wfblk(w, pos + 1, dat.subarray(i, e));
            }
            st.i = s;
        }
        return slc(o, 0, pre + shft(pos) + post);
    };
    var crct = null && function() {
        var t = new Int32Array(256);
        for (var i = 0; i < 256; ++i) {
            var c = i, k = 9;
            while (--k) c = (c & 1 && -306674912) ^ c >>> 1;
            t[i] = c;
        }
        return t;
    }();
    var crc = function() {
        var c = -1;
        return {
            p: function(d) {
                var cr = c;
                for (var i = 0; i < d.length; ++i) cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
                c = cr;
            },
            d: function() {
                return ~c;
            }
        };
    };
    var adler = function() {
        var a = 1, b = 0;
        return {
            p: function(d) {
                var n = a, m = b;
                var l = d.length | 0;
                for (var i = 0; i != l; ) {
                    var e = Math.min(i + 2655, l);
                    for (;i < e; ++i) m += n += d[i];
                    n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
                }
                a = n, b = m;
            },
            d: function() {
                a %= 65521, b %= 65521;
                return (a & 255) << 24 | (a & 65280) << 8 | (b & 255) << 8 | b >> 8;
            }
        };
    };
    var dopt = function(dat, opt, pre, post, st) {
        if (!st) {
            st = {
                l: 1
            };
            if (opt.dictionary) {
                var dict = opt.dictionary.subarray(-32768);
                var newDat = new u8(dict.length + dat.length);
                newDat.set(dict);
                newDat.set(dat, dict.length);
                dat = newDat;
                st.w = dict.length;
            }
        }
        return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
    };
    var mrg = function(a, b) {
        var o = {};
        for (var k in a) o[k] = a[k];
        for (var k in b) o[k] = b[k];
        return o;
    };
    var wcln = function(fn, fnStr, td) {
        var dt = fn();
        var st = fn.toString();
        var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\s+/g, "").split(",");
        for (var i = 0; i < dt.length; ++i) {
            var v = dt[i], k = ks[i];
            if (typeof v == "function") {
                fnStr += ";" + k + "=";
                var st_1 = v.toString();
                if (v.prototype) {
                    if (st_1.indexOf("[native code]") != -1) {
                        var spInd = st_1.indexOf(" ", 8) + 1;
                        fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
                    } else {
                        fnStr += st_1;
                        for (var t in v.prototype) fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();
                    }
                } else fnStr += st_1;
            } else td[k] = v;
        }
        return fnStr;
    };
    var ch = null && [];
    var cbfs = function(v) {
        var tl = [];
        for (var k in v) {
            if (v[k].buffer) {
                tl.push((v[k] = new v[k].constructor(v[k])).buffer);
            }
        }
        return tl;
    };
    var wrkr = function(fns, init, id, cb) {
        if (!ch[id]) {
            var fnStr = "", td_1 = {}, m = fns.length - 1;
            for (var i = 0; i < m; ++i) fnStr = wcln(fns[i], fnStr, td_1);
            ch[id] = {
                c: wcln(fns[m], fnStr, td_1),
                e: td_1
            };
        }
        var td = mrg({}, ch[id].e);
        return wk(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td, cbfs(td), cb);
    };
    var bInflt = function() {
        return [ u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, browser_err, inflt, inflateSync, pbf, gopt ];
    };
    var bDflt = function() {
        return [ u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf ];
    };
    var gze = function() {
        return [ gzh, gzhl, wbytes, crc, crct ];
    };
    var guze = function() {
        return [ gzs, gzl ];
    };
    var zle = function() {
        return [ zlh, wbytes, adler ];
    };
    var zule = function() {
        return [ zls ];
    };
    var pbf = function(msg) {
        return postMessage(msg, [ msg.buffer ]);
    };
    var gopt = function(o) {
        return o && {
            out: o.size && new u8(o.size),
            dictionary: o.dictionary
        };
    };
    var cbify = function(dat, opts, fns, init, id, cb) {
        var w = wrkr(fns, init, id, (function(err, dat) {
            w.terminate();
            cb(err, dat);
        }));
        w.postMessage([ dat, opts ], opts.consume ? [ dat.buffer ] : []);
        return function() {
            w.terminate();
        };
    };
    var astrm = function(strm) {
        strm.ondata = function(dat, final) {
            return postMessage([ dat, final ], [ dat.buffer ]);
        };
        return function(ev) {
            if (ev.data.length) {
                strm.push(ev.data[0], ev.data[1]);
                postMessage([ ev.data[0].length ]);
            } else strm.flush();
        };
    };
    var astrmify = function(fns, strm, opts, init, id, flush, ext) {
        var t;
        var w = wrkr(fns, init, id, (function(err, dat) {
            if (err) w.terminate(), strm.ondata.call(strm, err); else if (!Array.isArray(dat)) ext(dat); else if (dat.length == 1) {
                strm.queuedSize -= dat[0];
                if (strm.ondrain) strm.ondrain(dat[0]);
            } else {
                if (dat[1]) w.terminate();
                strm.ondata.call(strm, err, dat[0], dat[1]);
            }
        }));
        w.postMessage(opts);
        strm.queuedSize = 0;
        strm.push = function(d, f) {
            if (!strm.ondata) browser_err(5);
            if (t) strm.ondata(browser_err(4, 0, 1), null, !!f);
            strm.queuedSize += d.length;
            w.postMessage([ d, t = f ], [ d.buffer ]);
        };
        strm.terminate = function() {
            w.terminate();
        };
        if (flush) {
            strm.flush = function() {
                w.postMessage([]);
            };
        }
    };
    var b2 = function(d, b) {
        return d[b] | d[b + 1] << 8;
    };
    var b4 = function(d, b) {
        return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
    };
    var b8 = function(d, b) {
        return b4(d, b) + b4(d, b + 4) * 4294967296;
    };
    var wbytes = function(d, b, v) {
        for (;v; ++b) d[b] = v, v >>>= 8;
    };
    var gzh = function(c, o) {
        var fn = o.filename;
        c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, 
        c[9] = 3;
        if (o.mtime != 0) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
        if (fn) {
            c[3] = 8;
            for (var i = 0; i <= fn.length; ++i) c[i + 10] = fn.charCodeAt(i);
        }
    };
    var gzs = function(d) {
        if (d[0] != 31 || d[1] != 139 || d[2] != 8) browser_err(6, "invalid gzip data");
        var flg = d[3];
        var st = 10;
        if (flg & 4) st += (d[10] | d[11] << 8) + 2;
        for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]) ;
        return st + (flg & 2);
    };
    var gzl = function(d) {
        var l = d.length;
        return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
    };
    var gzhl = function(o) {
        return 10 + (o.filename ? o.filename.length + 1 : 0);
    };
    var zlh = function(c, o) {
        var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
        c[0] = 120, c[1] = fl << 6 | (o.dictionary && 32);
        c[1] |= 31 - (c[0] << 8 | c[1]) % 31;
        if (o.dictionary) {
            var h = adler();
            h.p(o.dictionary);
            wbytes(c, 2, h.d());
        }
    };
    var zls = function(d, dict) {
        if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31) browser_err(6, "invalid zlib data");
        if ((d[1] >> 5 & 1) == +!dict) browser_err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
        return (d[1] >> 3 & 4) + 2;
    };
    function StrmOpt(opts, cb) {
        if (typeof opts == "function") cb = opts, opts = {};
        this.ondata = cb;
        return opts;
    }
    var browser_Deflate = null && function() {
        function Deflate(opts, cb) {
            if (typeof opts == "function") cb = opts, opts = {};
            this.ondata = cb;
            this.o = opts || {};
            this.s = {
                l: 0,
                i: 32768,
                w: 32768,
                z: 32768
            };
            this.b = new u8(98304);
            if (this.o.dictionary) {
                var dict = this.o.dictionary.subarray(-32768);
                this.b.set(dict, 32768 - dict.length);
                this.s.i = 32768 - dict.length;
            }
        }
        Deflate.prototype.p = function(c, f) {
            this.ondata(dopt(c, this.o, 0, 0, this.s), f);
        };
        Deflate.prototype.push = function(chunk, final) {
            if (!this.ondata) browser_err(5);
            if (this.s.l) browser_err(4);
            var endLen = chunk.length + this.s.z;
            if (endLen > this.b.length) {
                if (endLen > 2 * this.b.length - 32768) {
                    var newBuf = new u8(endLen & -32768);
                    newBuf.set(this.b.subarray(0, this.s.z));
                    this.b = newBuf;
                }
                var split = this.b.length - this.s.z;
                this.b.set(chunk.subarray(0, split), this.s.z);
                this.s.z = this.b.length;
                this.p(this.b, false);
                this.b.set(this.b.subarray(-32768));
                this.b.set(chunk.subarray(split), 32768);
                this.s.z = chunk.length - split + 32768;
                this.s.i = 32766, this.s.w = 32768;
            } else {
                this.b.set(chunk, this.s.z);
                this.s.z += chunk.length;
            }
            this.s.l = final & 1;
            if (this.s.z > this.s.w + 8191 || final) {
                this.p(this.b, final || false);
                this.s.w = this.s.i, this.s.i -= 2;
            }
        };
        Deflate.prototype.flush = function() {
            if (!this.ondata) browser_err(5);
            if (this.s.l) browser_err(4);
            this.p(this.b, false);
            this.s.w = this.s.i, this.s.i -= 2;
        };
        return Deflate;
    }();
    var AsyncDeflate = null && function() {
        function AsyncDeflate(opts, cb) {
            astrmify([ bDflt, function() {
                return [ astrm, browser_Deflate ];
            } ], this, StrmOpt.call(this, opts, cb), (function(ev) {
                var strm = new browser_Deflate(ev.data);
                onmessage = astrm(strm);
            }), 6, 1);
        }
        return AsyncDeflate;
    }();
    function browser_deflate(data, opts, cb) {
        if (!cb) cb = opts, opts = {};
        if (typeof cb != "function") browser_err(7);
        return cbify(data, opts, [ bDflt ], (function(ev) {
            return pbf(deflateSync(ev.data[0], ev.data[1]));
        }), 0, cb);
    }
    function deflateSync(data, opts) {
        return dopt(data, opts || {}, 0, 0);
    }
    var browser_Inflate = null && function() {
        function Inflate(opts, cb) {
            if (typeof opts == "function") cb = opts, opts = {};
            this.ondata = cb;
            var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
            this.s = {
                i: 0,
                b: dict ? dict.length : 0
            };
            this.o = new u8(32768);
            this.p = new u8(0);
            if (dict) this.o.set(dict);
        }
        Inflate.prototype.e = function(c) {
            if (!this.ondata) browser_err(5);
            if (this.d) browser_err(4);
            if (!this.p.length) this.p = c; else if (c.length) {
                var n = new u8(this.p.length + c.length);
                n.set(this.p), n.set(c, this.p.length), this.p = n;
            }
        };
        Inflate.prototype.c = function(final) {
            this.s.i = +(this.d = final || false);
            var bts = this.s.b;
            var dt = inflt(this.p, this.s, this.o);
            this.ondata(slc(dt, bts, this.s.b), this.d);
            this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
            this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
        };
        Inflate.prototype.push = function(chunk, final) {
            this.e(chunk), this.c(final);
        };
        return Inflate;
    }();
    var AsyncInflate = null && function() {
        function AsyncInflate(opts, cb) {
            astrmify([ bInflt, function() {
                return [ astrm, browser_Inflate ];
            } ], this, StrmOpt.call(this, opts, cb), (function(ev) {
                var strm = new browser_Inflate(ev.data);
                onmessage = astrm(strm);
            }), 7, 0);
        }
        return AsyncInflate;
    }();
    function browser_inflate(data, opts, cb) {
        if (!cb) cb = opts, opts = {};
        if (typeof cb != "function") browser_err(7);
        return cbify(data, opts, [ bInflt ], (function(ev) {
            return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));
        }), 1, cb);
    }
    function inflateSync(data, opts) {
        return inflt(data, {
            i: 2
        }, opts && opts.out, opts && opts.dictionary);
    }
    var Gzip = null && function() {
        function Gzip(opts, cb) {
            this.c = crc();
            this.l = 0;
            this.v = 1;
            browser_Deflate.call(this, opts, cb);
        }
        Gzip.prototype.push = function(chunk, final) {
            this.c.p(chunk);
            this.l += chunk.length;
            browser_Deflate.prototype.push.call(this, chunk, final);
        };
        Gzip.prototype.p = function(c, f) {
            var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);
            if (this.v) gzh(raw, this.o), this.v = 0;
            if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
            this.ondata(raw, f);
        };
        Gzip.prototype.flush = function() {
            browser_Deflate.prototype.flush.call(this);
        };
        return Gzip;
    }();
    var AsyncGzip = null && function() {
        function AsyncGzip(opts, cb) {
            astrmify([ bDflt, gze, function() {
                return [ astrm, browser_Deflate, Gzip ];
            } ], this, StrmOpt.call(this, opts, cb), (function(ev) {
                var strm = new Gzip(ev.data);
                onmessage = astrm(strm);
            }), 8, 1);
        }
        return AsyncGzip;
    }();
    function browser_gzip(data, opts, cb) {
        if (!cb) cb = opts, opts = {};
        if (typeof cb != "function") browser_err(7);
        return cbify(data, opts, [ bDflt, gze, function() {
            return [ gzipSync ];
        } ], (function(ev) {
            return pbf(gzipSync(ev.data[0], ev.data[1]));
        }), 2, cb);
    }
    function gzipSync(data, opts) {
        if (!opts) opts = {};
        var c = crc(), l = data.length;
        c.p(data);
        var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
        return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
    }
    var Gunzip = null && function() {
        function Gunzip(opts, cb) {
            this.v = 1;
            this.r = 0;
            browser_Inflate.call(this, opts, cb);
        }
        Gunzip.prototype.push = function(chunk, final) {
            browser_Inflate.prototype.e.call(this, chunk);
            this.r += chunk.length;
            if (this.v) {
                var p = this.p.subarray(this.v - 1);
                var s = p.length > 3 ? gzs(p) : 4;
                if (s > p.length) {
                    if (!final) return;
                } else if (this.v > 1 && this.onmember) {
                    this.onmember(this.r - p.length);
                }
                this.p = p.subarray(s), this.v = 0;
            }
            browser_Inflate.prototype.c.call(this, final);
            if (this.s.f && !this.s.l && !final) {
                this.v = shft(this.s.p) + 9;
                this.s = {
                    i: 0
                };
                this.o = new u8(0);
                this.push(new u8(0), final);
            }
        };
        return Gunzip;
    }();
    var AsyncGunzip = null && function() {
        function AsyncGunzip(opts, cb) {
            var _this = this;
            astrmify([ bInflt, guze, function() {
                return [ astrm, browser_Inflate, Gunzip ];
            } ], this, StrmOpt.call(this, opts, cb), (function(ev) {
                var strm = new Gunzip(ev.data);
                strm.onmember = function(offset) {
                    return postMessage(offset);
                };
                onmessage = astrm(strm);
            }), 9, 0, (function(offset) {
                return _this.onmember && _this.onmember(offset);
            }));
        }
        return AsyncGunzip;
    }();
    function gunzip(data, opts, cb) {
        if (!cb) cb = opts, opts = {};
        if (typeof cb != "function") browser_err(7);
        return cbify(data, opts, [ bInflt, guze, function() {
            return [ gunzipSync ];
        } ], (function(ev) {
            return pbf(gunzipSync(ev.data[0], ev.data[1]));
        }), 3, cb);
    }
    function gunzipSync(data, opts) {
        var st = gzs(data);
        if (st + 8 > data.length) browser_err(6, "invalid gzip data");
        return inflt(data.subarray(st, -8), {
            i: 2
        }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
    }
    var Zlib = null && function() {
        function Zlib(opts, cb) {
            this.c = adler();
            this.v = 1;
            browser_Deflate.call(this, opts, cb);
        }
        Zlib.prototype.push = function(chunk, final) {
            this.c.p(chunk);
            browser_Deflate.prototype.push.call(this, chunk, final);
        };
        Zlib.prototype.p = function(c, f) {
            var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);
            if (this.v) zlh(raw, this.o), this.v = 0;
            if (f) wbytes(raw, raw.length - 4, this.c.d());
            this.ondata(raw, f);
        };
        Zlib.prototype.flush = function() {
            browser_Deflate.prototype.flush.call(this);
        };
        return Zlib;
    }();
    var AsyncZlib = null && function() {
        function AsyncZlib(opts, cb) {
            astrmify([ bDflt, zle, function() {
                return [ astrm, browser_Deflate, Zlib ];
            } ], this, StrmOpt.call(this, opts, cb), (function(ev) {
                var strm = new Zlib(ev.data);
                onmessage = astrm(strm);
            }), 10, 1);
        }
        return AsyncZlib;
    }();
    function zlib(data, opts, cb) {
        if (!cb) cb = opts, opts = {};
        if (typeof cb != "function") browser_err(7);
        return cbify(data, opts, [ bDflt, zle, function() {
            return [ zlibSync ];
        } ], (function(ev) {
            return pbf(zlibSync(ev.data[0], ev.data[1]));
        }), 4, cb);
    }
    function zlibSync(data, opts) {
        if (!opts) opts = {};
        var a = adler();
        a.p(data);
        var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
        return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
    }
    var Unzlib = null && function() {
        function Unzlib(opts, cb) {
            browser_Inflate.call(this, opts, cb);
            this.v = opts && opts.dictionary ? 2 : 1;
        }
        Unzlib.prototype.push = function(chunk, final) {
            browser_Inflate.prototype.e.call(this, chunk);
            if (this.v) {
                if (this.p.length < 6 && !final) return;
                this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
            }
            if (final) {
                if (this.p.length < 4) browser_err(6, "invalid zlib data");
                this.p = this.p.subarray(0, -4);
            }
            browser_Inflate.prototype.c.call(this, final);
        };
        return Unzlib;
    }();
    var AsyncUnzlib = null && function() {
        function AsyncUnzlib(opts, cb) {
            astrmify([ bInflt, zule, function() {
                return [ astrm, browser_Inflate, Unzlib ];
            } ], this, StrmOpt.call(this, opts, cb), (function(ev) {
                var strm = new Unzlib(ev.data);
                onmessage = astrm(strm);
            }), 11, 0);
        }
        return AsyncUnzlib;
    }();
    function unzlib(data, opts, cb) {
        if (!cb) cb = opts, opts = {};
        if (typeof cb != "function") browser_err(7);
        return cbify(data, opts, [ bInflt, zule, function() {
            return [ unzlibSync ];
        } ], (function(ev) {
            return pbf(unzlibSync(ev.data[0], gopt(ev.data[1])));
        }), 5, cb);
    }
    function unzlibSync(data, opts) {
        return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), {
            i: 2
        }, opts && opts.out, opts && opts.dictionary);
    }
    var Decompress = null && function() {
        function Decompress(opts, cb) {
            this.o = StrmOpt.call(this, opts, cb) || {};
            this.G = Gunzip;
            this.I = browser_Inflate;
            this.Z = Unzlib;
        }
        Decompress.prototype.i = function() {
            var _this = this;
            this.s.ondata = function(dat, final) {
                _this.ondata(dat, final);
            };
        };
        Decompress.prototype.push = function(chunk, final) {
            if (!this.ondata) browser_err(5);
            if (!this.s) {
                if (this.p && this.p.length) {
                    var n = new u8(this.p.length + chunk.length);
                    n.set(this.p), n.set(chunk, this.p.length);
                } else this.p = chunk;
                if (this.p.length > 2) {
                    this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o) : new this.Z(this.o);
                    this.i();
                    this.s.push(this.p, final);
                    this.p = null;
                }
            } else this.s.push(chunk, final);
        };
        return Decompress;
    }();
    var AsyncDecompress = null && function() {
        function AsyncDecompress(opts, cb) {
            Decompress.call(this, opts, cb);
            this.queuedSize = 0;
            this.G = AsyncGunzip;
            this.I = AsyncInflate;
            this.Z = AsyncUnzlib;
        }
        AsyncDecompress.prototype.i = function() {
            var _this = this;
            this.s.ondata = function(err, dat, final) {
                _this.ondata(err, dat, final);
            };
            this.s.ondrain = function(size) {
                _this.queuedSize -= size;
                if (_this.ondrain) _this.ondrain(size);
            };
        };
        AsyncDecompress.prototype.push = function(chunk, final) {
            this.queuedSize += chunk.length;
            Decompress.prototype.push.call(this, chunk, final);
        };
        return AsyncDecompress;
    }();
    function decompress(data, opts, cb) {
        if (!cb) cb = opts, opts = {};
        if (typeof cb != "function") browser_err(7);
        return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? browser_inflate(data, opts, cb) : unzlib(data, opts, cb);
    }
    function decompressSync(data, opts) {
        return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
    }
    var fltn = function(d, p, t, o) {
        for (var k in d) {
            var val = d[k], n = p + k, op = o;
            if (Array.isArray(val)) op = mrg(o, val[1]), val = val[0];
            if (val instanceof u8) t[n] = [ val, op ]; else {
                t[n += "/"] = [ new u8(0), op ];
                fltn(val, n, t, o);
            }
        }
    };
    var te = typeof TextEncoder != "undefined" && new TextEncoder;
    var td = typeof TextDecoder != "undefined" && new TextDecoder;
    var tds = 0;
    try {
        td.decode(et, {
            stream: true
        });
        tds = 1;
    } catch (e) {}
    var dutf8 = function(d) {
        for (var r = "", i = 0; ;) {
            var c = d[i++];
            var eb = (c > 127) + (c > 223) + (c > 239);
            if (i + eb > d.length) return {
                s: r,
                r: slc(d, i - 1)
            };
            if (!eb) r += String.fromCharCode(c); else if (eb == 3) {
                c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, 
                r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
            } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63); else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
        }
    };
    var DecodeUTF8 = null && function() {
        function DecodeUTF8(cb) {
            this.ondata = cb;
            if (tds) this.t = new TextDecoder; else this.p = et;
        }
        DecodeUTF8.prototype.push = function(chunk, final) {
            if (!this.ondata) browser_err(5);
            final = !!final;
            if (this.t) {
                this.ondata(this.t.decode(chunk, {
                    stream: true
                }), final);
                if (final) {
                    if (this.t.decode().length) browser_err(8);
                    this.t = null;
                }
                return;
            }
            if (!this.p) browser_err(4);
            var dat = new u8(this.p.length + chunk.length);
            dat.set(this.p);
            dat.set(chunk, this.p.length);
            var _a = dutf8(dat), s = _a.s, r = _a.r;
            if (final) {
                if (r.length) browser_err(8);
                this.p = null;
            } else this.p = r;
            this.ondata(s, final);
        };
        return DecodeUTF8;
    }();
    var EncodeUTF8 = null && function() {
        function EncodeUTF8(cb) {
            this.ondata = cb;
        }
        EncodeUTF8.prototype.push = function(chunk, final) {
            if (!this.ondata) browser_err(5);
            if (this.d) browser_err(4);
            this.ondata(strToU8(chunk), this.d = final || false);
        };
        return EncodeUTF8;
    }();
    function strToU8(str, latin1) {
        if (latin1) {
            var ar_1 = new u8(str.length);
            for (var i = 0; i < str.length; ++i) ar_1[i] = str.charCodeAt(i);
            return ar_1;
        }
        if (te) return te.encode(str);
        var l = str.length;
        var ar = new u8(str.length + (str.length >> 1));
        var ai = 0;
        var w = function(v) {
            ar[ai++] = v;
        };
        for (var i = 0; i < l; ++i) {
            if (ai + 5 > ar.length) {
                var n = new u8(ai + 8 + (l - i << 1));
                n.set(ar);
                ar = n;
            }
            var c = str.charCodeAt(i);
            if (c < 128 || latin1) w(c); else if (c < 2048) w(192 | c >> 6), w(128 | c & 63); else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, 
            w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63); else w(224 | c >> 12), 
            w(128 | c >> 6 & 63), w(128 | c & 63);
        }
        return slc(ar, 0, ai);
    }
    function strFromU8(dat, latin1) {
        if (latin1) {
            var r = "";
            for (var i = 0; i < dat.length; i += 16384) r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
            return r;
        } else if (td) {
            return td.decode(dat);
        } else {
            var _a = dutf8(dat), s = _a.s, r = _a.r;
            if (r.length) browser_err(8);
            return s;
        }
    }
    var dbf = function(l) {
        return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
    };
    var slzh = function(d, b) {
        return b + 30 + b2(d, b + 26) + b2(d, b + 28);
    };
    var zh = function(d, b, z) {
        var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
        var _a = z && bs == 4294967295 ? z64e(d, es) : [ bs, b4(d, b + 24), b4(d, b + 42) ], sc = _a[0], su = _a[1], off = _a[2];
        return [ b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off ];
    };
    var z64e = function(d, b) {
        for (;b2(d, b) != 1; b += 4 + b2(d, b + 2)) ;
        return [ b8(d, b + 12), b8(d, b + 4), b8(d, b + 20) ];
    };
    var exfl = function(ex) {
        var le = 0;
        if (ex) {
            for (var k in ex) {
                var l = ex[k].length;
                if (l > 65535) browser_err(9);
                le += l + 4;
            }
        }
        return le;
    };
    var wzh = function(d, b, f, fn, u, c, ce, co) {
        var fl = fn.length, ex = f.extra, col = co && co.length;
        var exl = exfl(ex);
        wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;
        if (ce != null) d[b++] = 20, d[b++] = f.os;
        d[b] = 20, b += 2;
        d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;
        d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
        var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
        if (y < 0 || y > 119) browser_err(10);
        wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), 
        b += 4;
        if (c != -1) {
            wbytes(d, b, f.crc);
            wbytes(d, b + 4, c < 0 ? -c - 2 : c);
            wbytes(d, b + 8, f.size);
        }
        wbytes(d, b + 12, fl);
        wbytes(d, b + 14, exl), b += 16;
        if (ce != null) {
            wbytes(d, b, col);
            wbytes(d, b + 6, f.attrs);
            wbytes(d, b + 10, ce), b += 14;
        }
        d.set(fn, b);
        b += fl;
        if (exl) {
            for (var k in ex) {
                var exf = ex[k], l = exf.length;
                wbytes(d, b, +k);
                wbytes(d, b + 2, l);
                d.set(exf, b + 4), b += 4 + l;
            }
        }
        if (col) d.set(co, b), b += col;
        return b;
    };
    var wzf = function(o, b, c, d, e) {
        wbytes(o, b, 101010256);
        wbytes(o, b + 8, c);
        wbytes(o, b + 10, c);
        wbytes(o, b + 12, d);
        wbytes(o, b + 16, e);
    };
    var ZipPassThrough = null && function() {
        function ZipPassThrough(filename) {
            this.filename = filename;
            this.c = crc();
            this.size = 0;
            this.compression = 0;
        }
        ZipPassThrough.prototype.process = function(chunk, final) {
            this.ondata(null, chunk, final);
        };
        ZipPassThrough.prototype.push = function(chunk, final) {
            if (!this.ondata) browser_err(5);
            this.c.p(chunk);
            this.size += chunk.length;
            if (final) this.crc = this.c.d();
            this.process(chunk, final || false);
        };
        return ZipPassThrough;
    }();
    var ZipDeflate = null && function() {
        function ZipDeflate(filename, opts) {
            var _this = this;
            if (!opts) opts = {};
            ZipPassThrough.call(this, filename);
            this.d = new browser_Deflate(opts, (function(dat, final) {
                _this.ondata(null, dat, final);
            }));
            this.compression = 8;
            this.flag = dbf(opts.level);
        }
        ZipDeflate.prototype.process = function(chunk, final) {
            try {
                this.d.push(chunk, final);
            } catch (e) {
                this.ondata(e, null, final);
            }
        };
        ZipDeflate.prototype.push = function(chunk, final) {
            ZipPassThrough.prototype.push.call(this, chunk, final);
        };
        return ZipDeflate;
    }();
    var AsyncZipDeflate = null && function() {
        function AsyncZipDeflate(filename, opts) {
            var _this = this;
            if (!opts) opts = {};
            ZipPassThrough.call(this, filename);
            this.d = new AsyncDeflate(opts, (function(err, dat, final) {
                _this.ondata(err, dat, final);
            }));
            this.compression = 8;
            this.flag = dbf(opts.level);
            this.terminate = this.d.terminate;
        }
        AsyncZipDeflate.prototype.process = function(chunk, final) {
            this.d.push(chunk, final);
        };
        AsyncZipDeflate.prototype.push = function(chunk, final) {
            ZipPassThrough.prototype.push.call(this, chunk, final);
        };
        return AsyncZipDeflate;
    }();
    var Zip = null && function() {
        function Zip(cb) {
            this.ondata = cb;
            this.u = [];
            this.d = 1;
        }
        Zip.prototype.add = function(file) {
            var _this = this;
            if (!this.ondata) browser_err(5);
            if (this.d & 2) this.ondata(browser_err(4 + (this.d & 1) * 8, 0, 1), null, false); else {
                var f = strToU8(file.filename), fl_1 = f.length;
                var com = file.comment, o = com && strToU8(com);
                var u = fl_1 != file.filename.length || o && com.length != o.length;
                var hl_1 = fl_1 + exfl(file.extra) + 30;
                if (fl_1 > 65535) this.ondata(browser_err(11, 0, 1), null, false);
                var header = new u8(hl_1);
                wzh(header, 0, file, f, u, -1);
                var chks_1 = [ header ];
                var pAll_1 = function() {
                    for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
                        var chk = chks_2[_i];
                        _this.ondata(null, chk, false);
                    }
                    chks_1 = [];
                };
                var tr_1 = this.d;
                this.d = 0;
                var ind_1 = this.u.length;
                var uf_1 = mrg(file, {
                    f,
                    u,
                    o,
                    t: function() {
                        if (file.terminate) file.terminate();
                    },
                    r: function() {
                        pAll_1();
                        if (tr_1) {
                            var nxt = _this.u[ind_1 + 1];
                            if (nxt) nxt.r(); else _this.d = 1;
                        }
                        tr_1 = 1;
                    }
                });
                var cl_1 = 0;
                file.ondata = function(err, dat, final) {
                    if (err) {
                        _this.ondata(err, dat, final);
                        _this.terminate();
                    } else {
                        cl_1 += dat.length;
                        chks_1.push(dat);
                        if (final) {
                            var dd = new u8(16);
                            wbytes(dd, 0, 134695760);
                            wbytes(dd, 4, file.crc);
                            wbytes(dd, 8, cl_1);
                            wbytes(dd, 12, file.size);
                            chks_1.push(dd);
                            uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
                            if (tr_1) uf_1.r();
                            tr_1 = 1;
                        } else if (tr_1) pAll_1();
                    }
                };
                this.u.push(uf_1);
            }
        };
        Zip.prototype.end = function() {
            var _this = this;
            if (this.d & 2) {
                this.ondata(browser_err(4 + (this.d & 1) * 8, 0, 1), null, true);
                return;
            }
            if (this.d) this.e(); else this.u.push({
                r: function() {
                    if (!(_this.d & 1)) return;
                    _this.u.splice(-1, 1);
                    _this.e();
                },
                t: function() {}
            });
            this.d = 3;
        };
        Zip.prototype.e = function() {
            var bt = 0, l = 0, tl = 0;
            for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
                var f = _a[_i];
                tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
            }
            var out = new u8(tl + 22);
            for (var _b = 0, _c = this.u; _b < _c.length; _b++) {
                var f = _c[_b];
                wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);
                bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
            }
            wzf(out, bt, this.u.length, tl, l);
            this.ondata(null, out, true);
            this.d = 2;
        };
        Zip.prototype.terminate = function() {
            for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
                var f = _a[_i];
                f.t();
            }
            this.d = 2;
        };
        return Zip;
    }();
    function zip(data, opts, cb) {
        if (!cb) cb = opts, opts = {};
        if (typeof cb != "function") browser_err(7);
        var r = {};
        fltn(data, "", r, opts);
        var k = Object.keys(r);
        var lft = k.length, o = 0, tot = 0;
        var slft = lft, files = new Array(lft);
        var term = [];
        var tAll = function() {
            for (var i = 0; i < term.length; ++i) term[i]();
        };
        var cbd = function(a, b) {
            mt((function() {
                cb(a, b);
            }));
        };
        mt((function() {
            cbd = cb;
        }));
        var cbf = function() {
            var out = new u8(tot + 22), oe = o, cdl = tot - o;
            tot = 0;
            for (var i = 0; i < slft; ++i) {
                var f = files[i];
                try {
                    var l = f.c.length;
                    wzh(out, tot, f, f.f, f.u, l);
                    var badd = 30 + f.f.length + exfl(f.extra);
                    var loc = tot + badd;
                    out.set(f.c, loc);
                    wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), 
                    tot = loc + l;
                } catch (e) {
                    return cbd(e, null);
                }
            }
            wzf(out, o, files.length, cdl, oe);
            cbd(null, out);
        };
        if (!lft) cbf();
        var _loop_1 = function(i) {
            var fn = k[i];
            var _a = r[fn], file = _a[0], p = _a[1];
            var c = crc(), size = file.length;
            c.p(file);
            var f = strToU8(fn), s = f.length;
            var com = p.comment, m = com && strToU8(com), ms = m && m.length;
            var exl = exfl(p.extra);
            var compression = p.level == 0 ? 0 : 8;
            var cbl = function(e, d) {
                if (e) {
                    tAll();
                    cbd(e, null);
                } else {
                    var l = d.length;
                    files[i] = mrg(p, {
                        size,
                        crc: c.d(),
                        c: d,
                        f,
                        m,
                        u: s != fn.length || m && com.length != ms,
                        compression
                    });
                    o += 30 + s + exl + l;
                    tot += 76 + 2 * (s + exl) + (ms || 0) + l;
                    if (! --lft) cbf();
                }
            };
            if (s > 65535) cbl(browser_err(11, 0, 1), null);
            if (!compression) cbl(null, file); else if (size < 16e4) {
                try {
                    cbl(null, deflateSync(file, p));
                } catch (e) {
                    cbl(e, null);
                }
            } else term.push(browser_deflate(file, p, cbl));
        };
        for (var i = 0; i < slft; ++i) {
            _loop_1(i);
        }
        return tAll;
    }
    function zipSync(data, opts) {
        if (!opts) opts = {};
        var r = {};
        var files = [];
        fltn(data, "", r, opts);
        var o = 0;
        var tot = 0;
        for (var fn in r) {
            var _a = r[fn], file = _a[0], p = _a[1];
            var compression = p.level == 0 ? 0 : 8;
            var f = strToU8(fn), s = f.length;
            var com = p.comment, m = com && strToU8(com), ms = m && m.length;
            var exl = exfl(p.extra);
            if (s > 65535) browser_err(11);
            var d = compression ? deflateSync(file, p) : file, l = d.length;
            var c = crc();
            c.p(file);
            files.push(mrg(p, {
                size: file.length,
                crc: c.d(),
                c: d,
                f,
                m,
                u: s != fn.length || m && com.length != ms,
                o,
                compression
            }));
            o += 30 + s + exl + l;
            tot += 76 + 2 * (s + exl) + (ms || 0) + l;
        }
        var out = new u8(tot + 22), oe = o, cdl = tot - o;
        for (var i = 0; i < files.length; ++i) {
            var f = files[i];
            wzh(out, f.o, f, f.f, f.u, f.c.length);
            var badd = 30 + f.f.length + exfl(f.extra);
            out.set(f.c, f.o + badd);
            wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
        }
        wzf(out, o, files.length, cdl, oe);
        return out;
    }
    var UnzipPassThrough = null && function() {
        function UnzipPassThrough() {}
        UnzipPassThrough.prototype.push = function(data, final) {
            this.ondata(null, data, final);
        };
        UnzipPassThrough.compression = 0;
        return UnzipPassThrough;
    }();
    var UnzipInflate = null && function() {
        function UnzipInflate() {
            var _this = this;
            this.i = new browser_Inflate((function(dat, final) {
                _this.ondata(null, dat, final);
            }));
        }
        UnzipInflate.prototype.push = function(data, final) {
            try {
                this.i.push(data, final);
            } catch (e) {
                this.ondata(e, null, final);
            }
        };
        UnzipInflate.compression = 8;
        return UnzipInflate;
    }();
    var AsyncUnzipInflate = null && function() {
        function AsyncUnzipInflate(_, sz) {
            var _this = this;
            if (sz < 32e4) {
                this.i = new browser_Inflate((function(dat, final) {
                    _this.ondata(null, dat, final);
                }));
            } else {
                this.i = new AsyncInflate((function(err, dat, final) {
                    _this.ondata(err, dat, final);
                }));
                this.terminate = this.i.terminate;
            }
        }
        AsyncUnzipInflate.prototype.push = function(data, final) {
            if (this.i.terminate) data = slc(data, 0);
            this.i.push(data, final);
        };
        AsyncUnzipInflate.compression = 8;
        return AsyncUnzipInflate;
    }();
    var Unzip = null && function() {
        function Unzip(cb) {
            this.onfile = cb;
            this.k = [];
            this.o = {
                0: UnzipPassThrough
            };
            this.p = et;
        }
        Unzip.prototype.push = function(chunk, final) {
            var _this = this;
            if (!this.onfile) browser_err(5);
            if (!this.p) browser_err(4);
            if (this.c > 0) {
                var len = Math.min(this.c, chunk.length);
                var toAdd = chunk.subarray(0, len);
                this.c -= len;
                if (this.d) this.d.push(toAdd, !this.c); else this.k[0].push(toAdd);
                chunk = chunk.subarray(len);
                if (chunk.length) return this.push(chunk, final);
            } else {
                var f = 0, i = 0, is = void 0, buf = void 0;
                if (!this.p.length) buf = chunk; else if (!chunk.length) buf = this.p; else {
                    buf = new u8(this.p.length + chunk.length);
                    buf.set(this.p), buf.set(chunk, this.p.length);
                }
                var l = buf.length, oc = this.c, add = oc && this.d;
                var _loop_2 = function() {
                    var _a;
                    var sig = b4(buf, i);
                    if (sig == 67324752) {
                        f = 1, is = i;
                        this_1.d = null;
                        this_1.c = 0;
                        var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
                        if (l > i + 30 + fnl + es) {
                            var chks_3 = [];
                            this_1.k.unshift(chks_3);
                            f = 2;
                            var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
                            var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
                            if (sc_1 == 4294967295) {
                                _a = dd ? [ -2 ] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];
                            } else if (dd) sc_1 = -1;
                            i += es;
                            this_1.c = sc_1;
                            var d_1;
                            var file_1 = {
                                name: fn_1,
                                compression: cmp_1,
                                start: function() {
                                    if (!file_1.ondata) browser_err(5);
                                    if (!sc_1) file_1.ondata(null, et, true); else {
                                        var ctr = _this.o[cmp_1];
                                        if (!ctr) file_1.ondata(browser_err(14, "unknown compression type " + cmp_1, 1), null, false);
                                        d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                                        d_1.ondata = function(err, dat, final) {
                                            file_1.ondata(err, dat, final);
                                        };
                                        for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                                            var dat = chks_4[_i];
                                            d_1.push(dat, false);
                                        }
                                        if (_this.k[0] == chks_3 && _this.c) _this.d = d_1; else d_1.push(et, true);
                                    }
                                },
                                terminate: function() {
                                    if (d_1 && d_1.terminate) d_1.terminate();
                                }
                            };
                            if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;
                            this_1.onfile(file_1);
                        }
                        return "break";
                    } else if (oc) {
                        if (sig == 134695760) {
                            is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
                            return "break";
                        } else if (sig == 33639248) {
                            is = i -= 4, f = 3, this_1.c = 0;
                            return "break";
                        }
                    }
                };
                var this_1 = this;
                for (;i < l - 4; ++i) {
                    var state_1 = _loop_2();
                    if (state_1 === "break") break;
                }
                this.p = et;
                if (oc < 0) {
                    var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i);
                    if (add) add.push(dat, !!f); else this.k[+(f == 2)].push(dat);
                }
                if (f & 2) return this.push(buf.subarray(i), final);
                this.p = buf.subarray(i);
            }
            if (final) {
                if (this.c) browser_err(13);
                this.p = null;
            }
        };
        Unzip.prototype.register = function(decoder) {
            this.o[decoder.compression] = decoder;
        };
        return Unzip;
    }();
    var mt = typeof queueMicrotask == "function" ? queueMicrotask : typeof setTimeout == "function" ? setTimeout : function(fn) {
        fn();
    };
    function unzip(data, opts, cb) {
        if (!cb) cb = opts, opts = {};
        if (typeof cb != "function") browser_err(7);
        var term = [];
        var tAll = function() {
            for (var i = 0; i < term.length; ++i) term[i]();
        };
        var files = {};
        var cbd = function(a, b) {
            mt((function() {
                cb(a, b);
            }));
        };
        mt((function() {
            cbd = cb;
        }));
        var e = data.length - 22;
        for (;b4(data, e) != 101010256; --e) {
            if (!e || data.length - e > 65558) {
                cbd(browser_err(13, 0, 1), null);
                return tAll;
            }
        }
        var lft = b2(data, e + 8);
        if (lft) {
            var c = lft;
            var o = b4(data, e + 16);
            var z = o == 4294967295 || c == 65535;
            if (z) {
                var ze = b4(data, e - 12);
                z = b4(data, ze) == 101075792;
                if (z) {
                    c = lft = b4(data, ze + 32);
                    o = b4(data, ze + 48);
                }
            }
            var fltr = opts && opts.filter;
            var _loop_3 = function(i) {
                var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
                o = no;
                var cbl = function(e, d) {
                    if (e) {
                        tAll();
                        cbd(e, null);
                    } else {
                        if (d) files[fn] = d;
                        if (! --lft) cbd(null, files);
                    }
                };
                if (!fltr || fltr({
                    name: fn,
                    size: sc,
                    originalSize: su,
                    compression: c_1
                })) {
                    if (!c_1) cbl(null, slc(data, b, b + sc)); else if (c_1 == 8) {
                        var infl = data.subarray(b, b + sc);
                        if (su < 524288 || sc > .8 * su) {
                            try {
                                cbl(null, inflateSync(infl, {
                                    out: new u8(su)
                                }));
                            } catch (e) {
                                cbl(e, null);
                            }
                        } else term.push(browser_inflate(infl, {
                            size: su
                        }, cbl));
                    } else cbl(browser_err(14, "unknown compression type " + c_1, 1), null);
                } else cbl(null, null);
            };
            for (var i = 0; i < c; ++i) {
                _loop_3(i);
            }
        } else cbd(null, {});
        return tAll;
    }
    function unzipSync(data, opts) {
        var files = {};
        var e = data.length - 22;
        for (;b4(data, e) != 101010256; --e) {
            if (!e || data.length - e > 65558) browser_err(13);
        }
        var c = b2(data, e + 8);
        if (!c) return {};
        var o = b4(data, e + 16);
        var z = o == 4294967295 || c == 65535;
        if (z) {
            var ze = b4(data, e - 12);
            z = b4(data, ze) == 101075792;
            if (z) {
                c = b4(data, ze + 32);
                o = b4(data, ze + 48);
            }
        }
        var fltr = opts && opts.filter;
        for (var i = 0; i < c; ++i) {
            var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);
            o = no;
            if (!fltr || fltr({
                name: fn,
                size: sc,
                originalSize: su,
                compression: c_2
            })) {
                if (!c_2) files[fn] = slc(data, b, b + sc); else if (c_2 == 8) files[fn] = inflateSync(data.subarray(b, b + sc), {
                    out: new u8(su)
                }); else browser_err(14, "unknown compression type " + c_2);
            }
        }
        return files;
    }
    var backend_Buffer = __webpack_require__(764)["lW"];
    class AztecClientBackendError extends Error {
        constructor(message) {
            super(message);
        }
    }
    class UltraPlonkBackend {
        constructor(acirBytecode, backendOptions = {
            threads: 1
        }, circuitOptions = {
            recursive: false
        }) {
            this.backendOptions = backendOptions;
            this.circuitOptions = circuitOptions;
            this.acirUncompressedBytecode = acirToUint8Array(acirBytecode);
        }
        async instantiate() {
            if (!this.api) {
                const api = await Barretenberg.new(this.backendOptions);
                const honkRecursion = false;
                const [_total, subgroupSize] = await api.acirGetCircuitSizes(this.acirUncompressedBytecode, this.circuitOptions.recursive, honkRecursion);
                await api.initSRSForCircuitSize(subgroupSize);
                this.acirComposer = await api.acirNewAcirComposer(subgroupSize);
                await api.acirInitProvingKey(this.acirComposer, this.acirUncompressedBytecode, this.circuitOptions.recursive);
                this.api = api;
            }
        }
        async generateProof(compressedWitness) {
            await this.instantiate();
            const proofWithPublicInputs = await this.api.acirCreateProof(this.acirComposer, this.acirUncompressedBytecode, this.circuitOptions.recursive, decompressSync(compressedWitness));
            const numBytesInProofWithoutPublicInputs = 2144;
            const splitIndex = proofWithPublicInputs.length - numBytesInProofWithoutPublicInputs;
            const publicInputsConcatenated = proofWithPublicInputs.slice(0, splitIndex);
            const proof = proofWithPublicInputs.slice(splitIndex);
            const publicInputs = deflattenFields(publicInputsConcatenated);
            return {
                proof,
                publicInputs
            };
        }
        async generateRecursiveProofArtifacts(proofData, numOfPublicInputs = 0) {
            await this.instantiate();
            const proof = reconstructUltraPlonkProof(proofData);
            const proofAsFields = (await this.api.acirSerializeProofIntoFields(this.acirComposer, proof, numOfPublicInputs)).slice(numOfPublicInputs);
            await this.api.acirInitVerificationKey(this.acirComposer);
            const vk = await this.api.acirSerializeVerificationKeyIntoFields(this.acirComposer);
            return {
                proofAsFields: proofAsFields.map((p => p.toString())),
                vkAsFields: vk[0].map((vk => vk.toString())),
                vkHash: vk[1].toString()
            };
        }
        async verifyProof(proofData) {
            await this.instantiate();
            await this.api.acirInitVerificationKey(this.acirComposer);
            const proof = reconstructUltraPlonkProof(proofData);
            return await this.api.acirVerifyProof(this.acirComposer, proof);
        }
        async getVerificationKey() {
            await this.instantiate();
            await this.api.acirInitVerificationKey(this.acirComposer);
            return await this.api.acirGetVerificationKey(this.acirComposer);
        }
        async getSolidityVerifier() {
            await this.instantiate();
            await this.api.acirInitVerificationKey(this.acirComposer);
            return await this.api.acirGetSolidityVerifier(this.acirComposer);
        }
        async destroy() {
            if (!this.api) {
                return;
            }
            await this.api.destroy();
        }
    }
    class UltraHonkBackend {
        constructor(acirBytecode, backendOptions = {
            threads: 1
        }, circuitOptions = {
            recursive: false
        }) {
            this.backendOptions = backendOptions;
            this.circuitOptions = circuitOptions;
            this.acirUncompressedBytecode = acirToUint8Array(acirBytecode);
        }
        async instantiate() {
            if (!this.api) {
                const api = await Barretenberg.new(this.backendOptions);
                const honkRecursion = true;
                await api.acirInitSRS(this.acirUncompressedBytecode, this.circuitOptions.recursive, honkRecursion);
                this.api = api;
            }
        }
        async generateProof(compressedWitness, options) {
            await this.instantiate();
            const proveUltraHonk = options?.keccak ? this.api.acirProveUltraKeccakHonk.bind(this.api) : this.api.acirProveUltraHonk.bind(this.api);
            const proofWithPublicInputs = await proveUltraHonk(this.acirUncompressedBytecode, this.circuitOptions.recursive, decompressSync(compressedWitness));
            const writeVKUltraHonk = options?.keccak ? this.api.acirWriteVkUltraKeccakHonk.bind(this.api) : this.api.acirWriteVkUltraHonk.bind(this.api);
            const vk = await writeVKUltraHonk(this.acirUncompressedBytecode, this.circuitOptions.recursive);
            const vkAsFields = await this.api.acirVkAsFieldsUltraHonk(new RawBuffer(vk));
            const numPublicInputs = Number(vkAsFields[1].toString());
            const {proof, publicInputs: publicInputsBytes} = splitHonkProof(proofWithPublicInputs, numPublicInputs);
            const publicInputs = deflattenFields(publicInputsBytes);
            return {
                proof,
                publicInputs
            };
        }
        async generateProofForRecursiveAggregation(compressedWitness, options) {
            await this.instantiate();
            const proveUltraHonk = options?.keccak ? this.api.acirProveUltraKeccakHonk.bind(this.api) : this.api.acirProveUltraHonk.bind(this.api);
            const proofWithPublicInputs = await proveUltraHonk(this.acirUncompressedBytecode, this.circuitOptions.recursive, decompressSync(compressedWitness));
            const writeVKUltraHonk = options?.keccak ? this.api.acirWriteVkUltraKeccakHonk.bind(this.api) : this.api.acirWriteVkUltraHonk.bind(this.api);
            const vk = await writeVKUltraHonk(this.acirUncompressedBytecode, this.circuitOptions.recursive);
            const vkAsFields = await this.api.acirVkAsFieldsUltraHonk(new RawBuffer(vk));
            const numKZGAccumulatorFieldElements = 16;
            const publicInputsSizeIndex = 1;
            const numPublicInputs = Number(vkAsFields[publicInputsSizeIndex].toString()) - numKZGAccumulatorFieldElements;
            const {proof: proofBytes, publicInputs: publicInputsBytes} = splitHonkProof(proofWithPublicInputs, numPublicInputs);
            const publicInputs = deflattenFields(publicInputsBytes);
            const proof = deflattenFields(proofBytes);
            return {
                proof,
                publicInputs
            };
        }
        async verifyProof(proofData, options) {
            await this.instantiate();
            const proof = reconstructHonkProof(flattenFieldsAsArray(proofData.publicInputs), proofData.proof);
            const writeVkUltraHonk = options?.keccak ? this.api.acirWriteVkUltraKeccakHonk.bind(this.api) : this.api.acirWriteVkUltraHonk.bind(this.api);
            const verifyUltraHonk = options?.keccak ? this.api.acirVerifyUltraKeccakHonk.bind(this.api) : this.api.acirVerifyUltraHonk.bind(this.api);
            const vkBuf = await writeVkUltraHonk(this.acirUncompressedBytecode, this.circuitOptions.recursive);
            return await verifyUltraHonk(proof, new RawBuffer(vkBuf));
        }
        async getVerificationKey(options) {
            await this.instantiate();
            return options?.keccak ? await this.api.acirWriteVkUltraKeccakHonk(this.acirUncompressedBytecode, this.circuitOptions.recursive) : await this.api.acirWriteVkUltraHonk(this.acirUncompressedBytecode, this.circuitOptions.recursive);
        }
        async getSolidityVerifier(vk) {
            await this.instantiate();
            const vkBuf = vk ?? await this.api.acirWriteVkUltraKeccakHonk(this.acirUncompressedBytecode, this.circuitOptions.recursive);
            return await this.api.acirHonkSolidityVerifier(this.acirUncompressedBytecode, new RawBuffer(vkBuf));
        }
        async generateRecursiveProofArtifacts(_proof, _numOfPublicInputs) {
            await this.instantiate();
            const vkBuf = await this.api.acirWriteVkUltraHonk(this.acirUncompressedBytecode, this.circuitOptions.recursive);
            const vk = await this.api.acirVkAsFieldsUltraHonk(vkBuf);
            return {
                proofAsFields: [],
                vkAsFields: vk.map((vk => vk.toString())),
                vkHash: ""
            };
        }
        async destroy() {
            if (!this.api) {
                return;
            }
            await this.api.destroy();
        }
    }
    class AztecClientBackend {
        constructor(acirMsgpack, options = {
            threads: 1
        }) {
            this.acirMsgpack = acirMsgpack;
            this.options = options;
        }
        async instantiate() {
            if (!this.api) {
                const api = await Barretenberg.new(this.options);
                await api.initSRSClientIVC();
                this.api = api;
            }
        }
        async prove(witnessMsgpack) {
            await this.instantiate();
            const proofAndVk = await this.api.acirProveAztecClient(this.acirMsgpack, witnessMsgpack);
            const [proof, vk] = proofAndVk;
            if (!await this.verify(proof, vk)) {
                throw new AztecClientBackendError("Failed to verify the private (ClientIVC) transaction proof!");
            }
            return proofAndVk;
        }
        async verify(proof, vk) {
            await this.instantiate();
            return this.api.acirVerifyAztecClient(proof, vk);
        }
        async proveAndVerify(witnessMsgpack) {
            await this.instantiate();
            return this.api.acirProveAndVerifyAztecClient(this.acirMsgpack, witnessMsgpack);
        }
        async gates() {
            await this.instantiate();
            return this.api.acirGatesAztecClient(this.acirMsgpack);
        }
        async destroy() {
            if (!this.api) {
                return;
            }
            await this.api.destroy();
        }
    }
    function acirToUint8Array(base64EncodedBytecode) {
        const compressedByteCode = base64Decode(base64EncodedBytecode);
        return decompressSync(compressedByteCode);
    }
    function base64Decode(input) {
        if (typeof backend_Buffer !== "undefined") {
            const b = backend_Buffer.from(input, "base64");
            return new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
        } else if (typeof atob === "function") {
            return Uint8Array.from(atob(input), (c => c.charCodeAt(0)));
        } else {
            throw new Error("No implementation found for base64 decoding.");
        }
    }
    class Barretenberg extends BarretenbergApi {
        constructor(worker, wasm, options) {
            super(wasm);
            this.worker = worker;
            this.options = options;
        }
        static async new(options = {}) {
            const worker = browser_createMainWorker();
            const wasm = browser_getRemoteBarretenbergWasm(worker);
            const {module, threads} = await fetchModuleAndThreads(options.threads, options.wasmPath, options.logger);
            await wasm.init(module, threads, comlink_proxy(options.logger ?? browser_default()("bb.js:bb_wasm_async")), options.memory?.initial, options.memory?.maximum);
            return new Barretenberg(worker, wasm, options);
        }
        async getNumThreads() {
            return await this.wasm.getNumThreads();
        }
        async initSRSForCircuitSize(circuitSize) {
            const crs = await CachedNetCrs.new(circuitSize + 1, this.options.crsPath, this.options.logger);
            await this.srsInitSrs(new RawBuffer(crs.getG1Data()), crs.numPoints, new RawBuffer(crs.getG2Data()));
        }
        async initSRSClientIVC() {
            const crs = await CachedNetCrs.new(2 ** 20 + 1, this.options.crsPath, this.options.logger);
            const grumpkinCrs = await CachedNetGrumpkinCrs.new(2 ** 16 + 1, this.options.crsPath, this.options.logger);
            await this.srsInitSrs(new RawBuffer(crs.getG1Data()), crs.numPoints, new RawBuffer(crs.getG2Data()));
            await this.srsInitGrumpkinSrs(new RawBuffer(grumpkinCrs.getG1Data()), grumpkinCrs.numPoints);
        }
        async acirInitSRS(bytecode, recursive, honkRecursion) {
            const [_total, subgroupSize] = await this.acirGetCircuitSizes(bytecode, recursive, honkRecursion);
            return this.initSRSForCircuitSize(subgroupSize);
        }
        async destroy() {
            await this.wasm.destroy();
            await this.worker.terminate();
        }
    }
    let barrentenbergSyncSingletonPromise;
    let barretenbergSyncSingleton;
    class BarretenbergSync extends BarretenbergApiSync {
        constructor(wasm) {
            super(wasm);
        }
        static async new(wasmPath, logger = browser_default()("bb.js:bb_wasm_sync")) {
            const wasm = new barretenberg_wasm_main_BarretenbergWasmMain;
            const {module, threads} = await fetchModuleAndThreads(1, wasmPath, logger);
            await wasm.init(module, threads, logger);
            return new BarretenbergSync(wasm);
        }
        static async initSingleton(wasmPath, logger = browser_default()("bb.js:bb_wasm_sync")) {
            if (!barrentenbergSyncSingletonPromise) {
                barrentenbergSyncSingletonPromise = BarretenbergSync.new(wasmPath, logger);
            }
            barretenbergSyncSingleton = await barrentenbergSyncSingletonPromise;
            return barretenbergSyncSingleton;
        }
        static getSingleton() {
            if (!barretenbergSyncSingleton) {
                throw new Error("First call BarretenbergSync.initSingleton() on @aztec/bb.js module.");
            }
            return barretenbergSyncSingleton;
        }
        getWasm() {
            return this.wasm;
        }
    }
})();

var __webpack_exports__AztecClientBackend = __webpack_exports__.Dv;

var __webpack_exports__Barretenberg = __webpack_exports__.Zh;

var __webpack_exports__BarretenbergSync = __webpack_exports__.AL;

var __webpack_exports__BarretenbergVerifier = __webpack_exports__.tD;

var __webpack_exports__Crs = __webpack_exports__.i2;

var __webpack_exports__Fr = __webpack_exports__.Fr;

var __webpack_exports__GrumpkinCrs = __webpack_exports__.pS;

var __webpack_exports__RawBuffer = __webpack_exports__.ld;

var __webpack_exports__UltraHonkBackend = __webpack_exports__.yh;

var __webpack_exports__UltraPlonkBackend = __webpack_exports__._7;

var __webpack_exports__reconstructHonkProof = __webpack_exports__.H2;

var __webpack_exports__splitHonkProof = __webpack_exports__.ly;

export { __webpack_exports__AztecClientBackend as AztecClientBackend, __webpack_exports__Barretenberg as Barretenberg, __webpack_exports__BarretenbergSync as BarretenbergSync, __webpack_exports__BarretenbergVerifier as BarretenbergVerifier, __webpack_exports__Crs as Crs, __webpack_exports__Fr as Fr, __webpack_exports__GrumpkinCrs as GrumpkinCrs, __webpack_exports__RawBuffer as RawBuffer, __webpack_exports__UltraHonkBackend as UltraHonkBackend, __webpack_exports__UltraPlonkBackend as UltraPlonkBackend, __webpack_exports__reconstructHonkProof as reconstructHonkProof, __webpack_exports__splitHonkProof as splitHonkProof };