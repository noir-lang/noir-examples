{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"12703455923193888750","abi":{"parameters":[{"name":"input","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"do_encode","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},"error_types":{"11197946769672997277":{"error_kind":"string","string":"Unused input bytes for encoding must be zero"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"15932022181841714848":{"error_kind":"fmtstring","length":53,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]}}},"bytecode":"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","debug_symbols":"pdnNbhNZEIbhe/E6i66fc04VtzIaoRAMimQ5kUlGGiHune52vSZZtIWcVX3E9KPq9vkcSH7uvu6/vH7//Hj89vRj9+mfn7svp8fD4fH758PTw/3L49Nx/urPX3c7/vj55bTfz1/avXl9vur5/rQ/vuw+HV8Ph7vdf/eH1/Uv/Xi+P67z5f40vzrd7fbHr/OcwW+Ph/2Sft39uXravnT0XheP4ZfL203X5w3Xp1tdn01uuX4I1+fYut63r3e1KMA19Y9gfy9MdhGk3SRofnAHG5cdLG7awV0RvOWWkNtCH4rQh8dFkPjrHXrwZvqY7Ja7GHa5i9E3n6ToNqGqXsScNh+l2JUz2QdnsudNO5giqLlvEu0asbxahN5EyNT4YJGpbz6J6Zpwafcs2FY9Ja49S7l8QHR/847qe+LKwRx5KcfI9C1Cr91I+OVRxG1bhFw+KUPyRkLkQmhs3oh9eItrhOWgY5YxNm8krp6s/uZoab8R0X5Bmt26SZOPbzIufZ2zxY1I/LmdePvx9x6xK+e0afBcm2bf+gw2+fDH+PVbybzcikwyvbuVf+c/3T88nt79S2gnYz51dzuJ88h16HQespjz1JpW02u2mr3mqBk18zxtqlmelWflWXlWnpVn5Vl5Vp6X5+V5eV6el+fleXlenpfn5bXyWnmtvFZeK6+V18pr5bXyWnm9vF5eL68v3vwGda/Zavaao+bizQe753mOqabU1JpW02u2mr3mqFneKC/Ki/KivCgvyovyorwoL8qL8rK8LC/Ly/KyvCwvy8vysrwsT6aJIAQlGMEJjdAJgxAEZEEWZEEWZEEWZEEWZEEWZEVWZEVWZEVWZEVWZEVWZEM2ZEM2ZEO2OlNinTAIQcgKjuzIa5XWl4zgBGRHdnZ2dnbktVJrEAJyQ27s3HgaDbmxc2PnhtyROzt3ngb9EgomNEyomNAxoWRCy2QgD3Ye7DyQBzJdE8omA3mw82DnQA5kKid0TgI52DnYOZADmeYJ1ZNETnZOdk7kRKaAQgMlkbN21mkiCEEJtbPSQZ0aL3XCIAQBmQ4qHVRBFiM4AVmQ6aDSQRVkZWdlZ0VWZDqodFAVWdlZ2VmRDZkOKh1UQzZ2poNKB5UOqrGz1TuoSweX//no0sFzUIIRnDDL2pbQCYMQhKywdPAchKAEIzgBuSE35IbckDtyR+7IHbkjd+SO3JE7ckceyAN5IA/kgTyQB/JAHsgDOZADOZADOZADOZADOZADOZETOZETOZETOZETOZGzZJsmwiLrEpRgBCe08yGxpYPnMAhByAqCLEJAFmRBXjp4DsiCLMiCrBMBWZWArMiKvHTwHJAVWZEN2YSAbEZANmRDXjp4DsiGTAeNDhodNEd2JyA7siOvHVwDckNuyA25GQGZDlpDbsgNee3gEjpyR+7IHbk7AZkOWkfuyB157eAakAfyQB7Ig1NHB40O2kAeyIEcnOdADuRADuTg1NFBo4MWyImcyMl5TuRETuRETk4dHTQ66FPJTgedDjod9Klkp4NOB50OOh30CZkOuiDTQaeDTgddkOmg00Gng04HXZHpoCsyHXQ66HTQFZkOOh10Ouh00A2ZDroh00Gng04H3ZDpoNNBp4NOB92R6aA7Mh10Ouh00B2ZDjoddDrodND5Puh00BsyHXQ66HTQGzIddDrodNDpoPN90Omgd2Q66HTQ6aAvHbQ1CEEJRnBCI3TCIAQhKwRyIAdyIAdyIAdyIAdyICdyIidyIidyIidyIidyltymibDKv5YfgZwe778c9j/Ov8359np8ePPLnZf/n3mFX/88n54e9l9fT/vlxx/ra/MPRH4D","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"use noir_base64_lib::encode::base64_encode;\nuse noir_base64_lib::decode::base64_decode;\n\n/// Noir Base64 Encode/Decode Circuit\n/// - If `do_encode` is true, encodes the first 12 bytes of `input` as base64.\n///   - Asserts unused bytes (input[12..16]) are zero for safety.\n/// - If `do_encode` is false, decodes all 16 bytes of `input` as base64.\n///   - Invalid base64 input aborts the circuit (library asserts).\n///   - Output is zero-padded to 16 bytes.\n/// - Output: \n///   - [u8; 16]: Encoded or decoded result (decoded is zero-padded).\n/// - All inputs are private; output is public.\n/// \nfn main(input: [u8; 16], do_encode: bool) -> pub [u8; 16] {\n    if do_encode {\n        // Validate unused input bytes are zero\n        for i in 12..16 {\n            assert(input[i] == 0, \"Unused input bytes for encoding must be zero\");\n        }\n        let mut short_input: [u8; 12] = [0; 12];\n        for i in 0..12 {\n            short_input[i] = input[i];\n        }\n        base64_encode(short_input)\n    } else {\n        let decoded: [u8; 12] = base64_decode(input);    // Will abort on invalid base64\n        let mut output: [u8; 16] = [0; 16];\n        for i in 0..12 {\n            output[i] = decoded[i];\n        }\n        output\n    }\n}\n\n#[test]\nfn test_encode() {\n    let input: [u8; 16] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0];\n    let expected: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    let encoded = main(input, true);\n    assert(encoded == expected, \"Encoding failed\");\n}\n\n#[test]\nfn test_decode() {\n    let encoded: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n    let decoded_padded = main(encoded, false);\n    for i in 0..12 {\n        assert(decoded_padded[i] == expected[i], \"Decoding failed\");\n    }\n}\n\n#[test(should_fail)]\nfn test_invalid_encode_input() {\n    // Last 4 bytes non-zero should fail encoding\n    let input: [u8; 16] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 1, 2, 3, 4];\n    let _ = main(input, true);\n}\n\n#[test(should_fail_with = \"DecodeError\")]\nfn test_invalid_base64_decode() {\n    let bad_base64: [u8; 16] = [0; 16]; // invalid base64, triggers library assertion\n    let _ = main(bad_base64, false);\n}","path":"/home/cyprian/rustprograms/noir-examples/lib_examples/base64_example/src/main.nr"},"52":{"source":"use crate::extensions::PartialEq;\nuse crate::constants::INVALID_VALUE;\n\nstruct Base64DecodeBE {\n    table: [u8; 256]\n}\nstruct Base64URLDecodeBE {\n    table: [u8; 256]\n}\n\nimpl Base64DecodeBE {\n    /// Creates a new decoder that uses the standard Base64 Alphabet (base64) specified in RFC 4648\n    /// https://datatracker.ietf.org/doc/html/rfc4648#section-4\n    fn new() -> Self {\n        Base64DecodeBE {\n            table: [\n                // 0-42\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                62,// 43\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,// 44-46\n                63,// 47\n                52, 53, 54, 55, 56, 57, 58, 59, 60, 61,// 48-57\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,// 58-64\n                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,// 65-90 (A-Z)\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,// 91-96\n                26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,// 97-122 (a-z)\n                // 123-255\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE\n            ]\n        }\n    }\n\n    fn get(self, idx: Field) -> u8 {\n        self.table[idx]\n    }\n}\n\nimpl Base64URLDecodeBE {\n    /// Creates a new decoder that uses the standard Base64 with URL and Filename safe (base64) specified in RFC 4648\n    /// https://datatracker.ietf.org/doc/html/rfc4648#page-7\n    fn new() -> Self {\n        Base64URLDecodeBE {\n            table: [\n                // 0-42\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE,\n                62,// 45\n                INVALID_VALUE, INVALID_VALUE,\n                52, 53, 54, 55, 56, 57, 58, 59, 60, 61,// 48-57\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,// 58-64\n                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,// 65-90 (A-Z)\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,// 91-94\n                63,// 95\n                INVALID_VALUE,// 96\n                26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,// 97-122 (a-z)\n                // 123-255\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE\n            ]\n        }\n    }\n\n    fn get(self, idx: Field) -> u8 {\n        self.table[idx]\n    }\n}\n\npub fn base64_decode_elements<let M: u32>(input: [u8; M]) -> [u8; M] {\n    let mut Base64Decoder = Base64DecodeBE::new();\n\n    let mut result: [u8; M] = [0; M];\n\n    for i in 0..M {\n        let input_byte = input[i];\n        result[i] = Base64Decoder.get(input_byte as Field);\n        assert(result[i] != INVALID_VALUE, f\"DecodeError: invalid symbol {input_byte}, offset {i}.\");\n    }\n    result\n}\n\npub fn base64_decode_elements_var(input: Vec<u8>) -> Vec<u8> {\n    let mut Base64Decoder = Base64DecodeBE::new();\n\n    let mut result = Vec::new();\n\n    for i in 0..input.len() {\n        let input_byte = input.get(i);\n        result.insert(i, Base64Decoder.get(input_byte as Field));\n        assert(input_byte != INVALID_VALUE, f\"DecodeError: invalid symbol {input_byte}, offset {i}.\");\n    }\n    result\n}\n\npub fn base64_url_decode_elements<let M: u32>(input: [u8; M]) -> [u8; M] {\n    let mut Base64URLDecoder = Base64URLDecodeBE::new();\n\n    let mut result: [u8; M] = [0; M];\n\n    for i in 0..M {\n        let input_byte = input[i];\n        result[i] = Base64URLDecoder.get(input_byte as Field);\n        assert(result[i] != INVALID_VALUE, f\"DecodeError: invalid symbol {input_byte}, offset {i}.\");\n    }\n    result\n}\n\npub fn base64_url_decode_elements_var(input: Vec<u8>) -> Vec<u8> {\n    let mut Base64URLDecoder = Base64URLDecodeBE::new();\n\n    let mut result = Vec::new();\n\n    for i in 0..input.len() {\n        let input_byte = input.get(i);\n        result.insert(i, Base64URLDecoder.get(input_byte as Field));\n        assert(input_byte != INVALID_VALUE, f\"DecodeError: invalid symbol {input_byte}, offset {i}.\");\n    }\n    result\n}\n\npub fn base64_decode<let M: u32, let N: u32>(input: [u8; M]) -> [u8; N] {\n    let decoded: [u8; M] = base64_decode_elements(input);\n    let mut result: [u8; N] = [0; N];\n    let BASE64_ELEMENTS_PER_CHUNK: u32 = 40;\n    let BYTES_PER_CHUNK: u32 = 30;\n    let num_chunks = (M / BASE64_ELEMENTS_PER_CHUNK) + (M % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        for i in 0..num_chunks - 1 {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                slice += decoded[i * BASE64_ELEMENTS_PER_CHUNK + j] as Field;\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        let base64_elements_in_final_chunk = M - ((num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK);\n\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            slice += decoded[(num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK + j] as Field;\n        }\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = N - ((num_chunks - 1) * BYTES_PER_CHUNK);\n        for i in 0..num_bytes_in_final_chunk {\n            result[(num_chunks - 1) * BYTES_PER_CHUNK + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\npub fn base64_decode_var(input: Vec<u8>) -> Vec<u8> {\n    let decoded: Vec<u8>  = base64_decode_elements_var(input);\n    let mut result: Vec<u8> = Vec::new();\n    let M: u32 = input.len();\n    // Base64 Fixed output Value = ((length + 3) / 4)\n    let N: u32 = ((M * 3) / 4);\n    let BASE64_ELEMENTS_PER_CHUNK: u32 = 40;\n    let BYTES_PER_CHUNK: u32 = 30;\n    let num_chunks: u32 = (M / BASE64_ELEMENTS_PER_CHUNK) + (M % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        for i in 0..num_chunks - 1 {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                slice += decoded.get(i * BASE64_ELEMENTS_PER_CHUNK + j) as Field;\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result.insert(i * BYTES_PER_CHUNK + j, slice_bytes[j]);\n            }\n        }\n\n        let base64_elements_in_final_chunk: u32 = M - ((num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK);\n\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            slice += decoded.get((num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK + j) as Field;\n        }\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk: u32 = N - ((num_chunks - 1) * BYTES_PER_CHUNK);\n        for i in 0..num_bytes_in_final_chunk {\n            result.insert((num_chunks - 1) * BYTES_PER_CHUNK + i, slice_bytes[i]);\n        }\n    }\n\n    result\n}\n\npub fn base64_url_decode<let M: u32, let N: u32>(input: [u8; M]) -> [u8; N] {\n    let decoded: [u8; M] = base64_url_decode_elements(input);\n    let mut result: [u8; N] = [0; N];\n    let BASE64_ELEMENTS_PER_CHUNK: u32 = 40;\n    let BYTES_PER_CHUNK: u32 = 30;\n    let num_chunks = (M / BASE64_ELEMENTS_PER_CHUNK) + (M % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        for i in 0..num_chunks - 1 {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                slice += decoded[i * BASE64_ELEMENTS_PER_CHUNK + j] as Field;\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        let base64_elements_in_final_chunk = M - ((num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK);\n\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            slice += decoded[(num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK + j] as Field;\n        }\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = N - ((num_chunks - 1) * BYTES_PER_CHUNK);\n        for i in 0..num_bytes_in_final_chunk {\n            result[(num_chunks - 1) * BYTES_PER_CHUNK + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\npub fn base64_url_decode_var(input: Vec<u8>) -> Vec<u8> {\n    let decoded  = base64_url_decode_elements_var(input);\n    let mut result = Vec::new();\n    let M = input.len();\n    // Base64 Fixed output Value = ((length + 3) / 4) \n    let N: u32 = ((M * 3) / 4);\n    let BASE64_ELEMENTS_PER_CHUNK: u32 = 40;\n    let BYTES_PER_CHUNK: u32 = 30;\n    let num_chunks = (M / BASE64_ELEMENTS_PER_CHUNK) + (M % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        for i in 0..num_chunks - 1 {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                slice += decoded.get(i * BASE64_ELEMENTS_PER_CHUNK + j) as Field;\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result.insert(i * BYTES_PER_CHUNK + j, slice_bytes[j]);\n            }\n        }\n\n        let base64_elements_in_final_chunk = M - ((num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK);\n\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            slice += decoded.get((num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK + j) as Field;\n        }\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n\n        let num_bytes_in_final_chunk = N - ((num_chunks - 1) * BYTES_PER_CHUNK);\n        for i in 0..num_bytes_in_final_chunk {\n            result.insert((num_chunks - 1) * BYTES_PER_CHUNK + i, slice_bytes[i]);\n        }\n    }\n\n    result\n}\n\n#[test]\nfn test_decode() {\n    let expected = \"The quick brown fox jumps over the lazy dog, while 42 ravens perch atop a rusty mailbox.\".as_bytes();\n    let input = \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZywgd2hpbGUgNDIgcmF2ZW5zIHBlcmNoIGF0b3AgYSBydXN0eSBtYWlsYm94Lg\".as_bytes();\n\n    let decoded  = base64_decode(input);\n    assert_eq(expected, decoded);\n}\n\n#[test]\nfn test_decode_var() {\n    let expected: Vec<u8> = \"The quick brown fox jumps over the lazy dog, while 42 ravens perch atop a rusty mailbox.\".as_bytes_vec();\n    let input: Vec<u8> = \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZywgd2hpbGUgNDIgcmF2ZW5zIHBlcmNoIGF0b3AgYSBydXN0eSBtYWlsYm94Lg\".as_bytes_vec();\n    let decoded: Vec<u8>  = base64_decode_var(input);\n    assert(expected.eq(decoded));\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = base64_decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte_var() {\n    let mut input= \"/w\".as_bytes_vec();\n    let result = base64_decode_var(input);\n    assert(result.len() == 1);\n    assert(result.get(0) == 255);\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = base64_decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_empty_var() {\n    let input: Vec<u8> = Vec::new();\n    let expected: Vec<u8> = Vec::new();\n    let result = base64_decode_var(input);\n    assert(expected.eq(result));\n}\n\n#[test(should_fail_with=\"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 1] = [255];\n    let _: [u8; 0] = base64_decode(input);\n}\n\n#[test(should_fail_with=\"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid_var() {\n    let mut input: Vec<u8> = Vec::new();\n    input.push(255);\n    let _: Vec<u8> = base64_decode_var(input);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    let result: [u8; 12] = base64_decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii_var() {\n    let input  = \"SGVsbG8gV29ybGQh\".as_bytes_vec();\n    let expected = \"Hello World!\".as_bytes_vec();\n\n    let result = base64_decode_var(input);\n    assert(expected.eq(result));\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52, 67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129, 228, 184, 150, 231, 149, 140, 239, 188, 129\n    ];\n\n    let result: [u8; 27] = base64_decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8_var() {\n    let input  = \"44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\".as_bytes_vec();\n    let mut expected: Vec<u8> = Vec::from_slice(\n        [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129, 228, 184, 150, 231, 149, 140, 239, 188, 129\n    ]\n    );\n\n    let result = base64_decode_var(input);\n    assert(expected.eq(result));\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    let input:[u8; 814] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73, 71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73, 72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 119, 103, 100, 50, 104, 112, 98, 71, 85, 103, 78, 68, 73, 103, 99, 109, 70, 50, 90, 87, 53, 122, 73, 72, 66, 108, 99, 109, 78, 111, 73, 71, 70, 48, 98, 51, 65, 103, 89, 83, 66, 121, 100, 88, 78, 48, 101, 83, 66, 116, 89, 87, 108, 115, 89, 109, 57, 52, 76, 105, 66, 97, 89, 87, 53, 53, 73, 72, 70, 49, 97, 87, 120, 48, 90, 88, 74, 122, 73, 71, 90, 104, 89, 110, 74, 112, 89, 50, 70, 48, 90, 83, 65, 53, 73, 71, 78, 118, 101, 110, 107, 103, 89, 109, 120, 104, 98, 109, 116, 108, 100, 72, 77, 115, 73, 71, 70, 122, 73, 68, 77, 103, 97, 109, 57, 50, 97, 87, 70, 115, 73, 72, 100, 112, 101, 109, 70, 121, 90, 72, 77, 103, 90, 88, 104, 119, 90, 88, 74, 48, 98, 72, 107, 103, 98, 87, 108, 52, 73, 68, 85, 103, 99, 71, 57, 48, 90, 87, 53, 48, 73, 71, 86, 115, 97, 88, 104, 112, 99, 110, 77, 117, 73, 69, 74, 121, 97, 87, 100, 111, 100, 67, 66, 117, 90, 87, 57, 117, 73, 72, 78, 112, 90, 50, 53, 122, 73, 71, 90, 115, 89, 88, 78, 111, 73, 67, 74, 80, 85, 69, 86, 79, 73, 68, 73, 48, 76, 122, 99, 105, 73, 71, 108, 117, 73, 72, 82, 111, 90, 83, 66, 116, 97, 88, 78, 48, 101, 83, 66, 117, 97, 87, 100, 111, 100, 67, 66, 104, 97, 88, 73, 115, 73, 71, 108, 115, 98, 72, 86, 116, 97, 87, 53, 104, 100, 71, 108, 117, 90, 121, 65, 52, 73, 72, 90, 112, 98, 110, 82, 104, 90, 50, 85, 103, 89, 50, 70, 121, 99, 121, 66, 119, 89, 88, 74, 114, 90, 87, 81, 103, 89, 87, 120, 118, 98, 109, 99, 103, 84, 87, 70, 112, 98, 105, 66, 84, 100, 72, 74, 108, 90, 88, 81, 117, 73, 69, 69, 103, 90, 50, 86, 117, 100, 71, 120, 108, 73, 71, 74, 121, 90, 87, 86, 54, 90, 83, 66, 106, 89, 88, 74, 121, 97, 87, 86, 122, 73, 72, 82, 111, 90, 83, 66, 104, 99, 109, 57, 116, 89, 83, 66, 118, 90, 105, 66, 109, 99, 109, 86, 122, 97, 67, 66, 106, 98, 50, 90, 109, 90, 87, 85, 103, 89, 87, 53, 107, 73, 72, 100, 104, 99, 109, 48, 103, 89, 50, 108, 117, 98, 109, 70, 116, 98, 50, 52, 103, 99, 109, 57, 115, 98, 72, 77, 103, 90, 110, 74, 118, 98, 83, 66, 75, 98, 50, 85, 110, 99, 121, 66, 69, 97, 87, 53, 108, 99, 105, 119, 103, 90, 87, 53, 48, 97, 87, 78, 112, 98, 109, 99, 103, 78, 105, 66, 122, 98, 71, 86, 108, 99, 72, 107, 103, 100, 72, 74, 49, 89, 50, 116, 108, 99, 110, 77, 103, 100, 71, 56, 103, 99, 51, 82, 118, 99, 67, 66, 109, 98, 51, 73, 103, 89, 83, 66, 115, 89, 88, 82, 108, 76, 87, 53, 112, 90, 50, 104, 48, 73, 72, 78, 117, 89, 87, 78, 114, 76, 105, 66, 78, 90, 87, 70, 117, 100, 50, 104, 112, 98, 71, 85, 115, 73, 68, 69, 120, 73, 71, 49, 112, 99, 50, 78, 111, 97, 87, 86, 50, 98, 51, 86, 122, 73, 71, 116, 112, 100, 72, 82, 108, 98, 110, 77, 103, 99, 71, 120, 104, 101, 87, 90, 49, 98, 71, 120, 53, 73, 71, 78, 111, 89, 88, 78, 108, 73, 71, 69, 103, 89, 109, 70, 115, 98, 67, 66, 118, 90, 105, 66, 53, 89, 88, 74, 117, 73, 71, 70, 106, 99, 109, 57, 122, 99, 121, 66, 78, 99, 110, 77, 117, 73, 69, 112, 118, 97, 71, 53, 122, 98, 50, 52, 110, 99, 121, 66, 119, 98, 51, 74, 106, 97, 67, 119, 103, 100, 71, 104, 108, 97, 88, 73, 103, 89, 87, 53, 48, 97, 87, 78, 122, 73, 71, 57, 105, 99, 50, 86, 121, 100, 109, 86, 107, 73, 71, 74, 53, 73, 68, 73, 103, 100, 50, 108, 122, 90, 83, 66, 118, 98, 71, 81, 103, 98, 51, 100, 115, 99, 121, 66, 119, 90, 88, 74, 106, 97, 71, 86, 107, 73, 71, 57, 117, 73, 71, 69, 103, 98, 109, 86, 104, 99, 109, 74, 53, 73, 71, 57, 104, 97, 121, 66, 48, 99, 109, 86, 108, 76, 103\n    ];\n    let result:[u8; 610] = base64_decode(input);\n    let expected = \"The quick brown fox jumps over the lazy dog, while 42 ravens perch atop a rusty mailbox. Zany quilters fabricate 9 cozy blankets, as 3 jovial wizards expertly mix 5 potent elixirs. Bright neon signs flash \\\"OPEN 24/7\\\" in the misty night air, illuminating 8 vintage cars parked along Main Street. A gentle breeze carries the aroma of fresh coffee and warm cinnamon rolls from Joe's Diner, enticing 6 sleepy truckers to stop for a late-night snack. Meanwhile, 11 mischievous kittens playfully chase a ball of yarn across Mrs. Johnson's porch, their antics observed by 2 wise old owls perched on a nearby oak tree.\";\n\n    assert(result == expected.as_bytes());\n}\n\n#[test]\nfn test_decode_multi_chunks_var() {\n    let input = Vec::from_slice(\n        [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73, 71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73, 72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 119, 103, 100, 50, 104, 112, 98, 71, 85, 103, 78, 68, 73, 103, 99, 109, 70, 50, 90, 87, 53, 122, 73, 72, 66, 108, 99, 109, 78, 111, 73, 71, 70, 48, 98, 51, 65, 103, 89, 83, 66, 121, 100, 88, 78, 48, 101, 83, 66, 116, 89, 87, 108, 115, 89, 109, 57, 52, 76, 105, 66, 97, 89, 87, 53, 53, 73, 72, 70, 49, 97, 87, 120, 48, 90, 88, 74, 122, 73, 71, 90, 104, 89, 110, 74, 112, 89, 50, 70, 48, 90, 83, 65, 53, 73, 71, 78, 118, 101, 110, 107, 103, 89, 109, 120, 104, 98, 109, 116, 108, 100, 72, 77, 115, 73, 71, 70, 122, 73, 68, 77, 103, 97, 109, 57, 50, 97, 87, 70, 115, 73, 72, 100, 112, 101, 109, 70, 121, 90, 72, 77, 103, 90, 88, 104, 119, 90, 88, 74, 48, 98, 72, 107, 103, 98, 87, 108, 52, 73, 68, 85, 103, 99, 71, 57, 48, 90, 87, 53, 48, 73, 71, 86, 115, 97, 88, 104, 112, 99, 110, 77, 117, 73, 69, 74, 121, 97, 87, 100, 111, 100, 67, 66, 117, 90, 87, 57, 117, 73, 72, 78, 112, 90, 50, 53, 122, 73, 71, 90, 115, 89, 88, 78, 111, 73, 67, 74, 80, 85, 69, 86, 79, 73, 68, 73, 48, 76, 122, 99, 105, 73, 71, 108, 117, 73, 72, 82, 111, 90, 83, 66, 116, 97, 88, 78, 48, 101, 83, 66, 117, 97, 87, 100, 111, 100, 67, 66, 104, 97, 88, 73, 115, 73, 71, 108, 115, 98, 72, 86, 116, 97, 87, 53, 104, 100, 71, 108, 117, 90, 121, 65, 52, 73, 72, 90, 112, 98, 110, 82, 104, 90, 50, 85, 103, 89, 50, 70, 121, 99, 121, 66, 119, 89, 88, 74, 114, 90, 87, 81, 103, 89, 87, 120, 118, 98, 109, 99, 103, 84, 87, 70, 112, 98, 105, 66, 84, 100, 72, 74, 108, 90, 88, 81, 117, 73, 69, 69, 103, 90, 50, 86, 117, 100, 71, 120, 108, 73, 71, 74, 121, 90, 87, 86, 54, 90, 83, 66, 106, 89, 88, 74, 121, 97, 87, 86, 122, 73, 72, 82, 111, 90, 83, 66, 104, 99, 109, 57, 116, 89, 83, 66, 118, 90, 105, 66, 109, 99, 109, 86, 122, 97, 67, 66, 106, 98, 50, 90, 109, 90, 87, 85, 103, 89, 87, 53, 107, 73, 72, 100, 104, 99, 109, 48, 103, 89, 50, 108, 117, 98, 109, 70, 116, 98, 50, 52, 103, 99, 109, 57, 115, 98, 72, 77, 103, 90, 110, 74, 118, 98, 83, 66, 75, 98, 50, 85, 110, 99, 121, 66, 69, 97, 87, 53, 108, 99, 105, 119, 103, 90, 87, 53, 48, 97, 87, 78, 112, 98, 109, 99, 103, 78, 105, 66, 122, 98, 71, 86, 108, 99, 72, 107, 103, 100, 72, 74, 49, 89, 50, 116, 108, 99, 110, 77, 103, 100, 71, 56, 103, 99, 51, 82, 118, 99, 67, 66, 109, 98, 51, 73, 103, 89, 83, 66, 115, 89, 88, 82, 108, 76, 87, 53, 112, 90, 50, 104, 48, 73, 72, 78, 117, 89, 87, 78, 114, 76, 105, 66, 78, 90, 87, 70, 117, 100, 50, 104, 112, 98, 71, 85, 115, 73, 68, 69, 120, 73, 71, 49, 112, 99, 50, 78, 111, 97, 87, 86, 50, 98, 51, 86, 122, 73, 71, 116, 112, 100, 72, 82, 108, 98, 110, 77, 103, 99, 71, 120, 104, 101, 87, 90, 49, 98, 71, 120, 53, 73, 71, 78, 111, 89, 88, 78, 108, 73, 71, 69, 103, 89, 109, 70, 115, 98, 67, 66, 118, 90, 105, 66, 53, 89, 88, 74, 117, 73, 71, 70, 106, 99, 109, 57, 122, 99, 121, 66, 78, 99, 110, 77, 117, 73, 69, 112, 118, 97, 71, 53, 122, 98, 50, 52, 110, 99, 121, 66, 119, 98, 51, 74, 106, 97, 67, 119, 103, 100, 71, 104, 108, 97, 88, 73, 103, 89, 87, 53, 48, 97, 87, 78, 122, 73, 71, 57, 105, 99, 50, 86, 121, 100, 109, 86, 107, 73, 71, 74, 53, 73, 68, 73, 103, 100, 50, 108, 122, 90, 83, 66, 118, 98, 71, 81, 103, 98, 51, 100, 115, 99, 121, 66, 119, 90, 88, 74, 106, 97, 71, 86, 107, 73, 71, 57, 117, 73, 71, 69, 103, 98, 109, 86, 104, 99, 109, 74, 53, 73, 71, 57, 104, 97, 121, 66, 48, 99, 109, 86, 108, 76, 103\n    ]\n    );\n\n    let result = base64_decode_var(input);\n    let expected = \"The quick brown fox jumps over the lazy dog, while 42 ravens perch atop a rusty mailbox. Zany quilters fabricate 9 cozy blankets, as 3 jovial wizards expertly mix 5 potent elixirs. Bright neon signs flash \\\"OPEN 24/7\\\" in the misty night air, illuminating 8 vintage cars parked along Main Street. A gentle breeze carries the aroma of fresh coffee and warm cinnamon rolls from Joe's Diner, enticing 6 sleepy truckers to stop for a late-night snack. Meanwhile, 11 mischievous kittens playfully chase a ball of yarn across Mrs. Johnson's porch, their antics observed by 2 wise old owls perched on a nearby oak tree.\".as_bytes_vec();\n\n    assert(expected.eq(result));\n}\n\n#[test(should_fail)]\nfn test_base64_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103,\n        119, 76, 105, 121, 112,\n        110, 86, 114, 69, 50,\n        67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87,\n        84, 107, 65, 104, 83,\n        90, 53, 43, 87, 69,\n        82, 104, 75, 104, 88,\n        116, 108, 85, 61\n    ];\n\n    let result: [u8; 32] = base64_decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172,\n        77, 130, 209, 39, 248, 203, 56, 92, 89, 57,\n        0, 133, 38, 121, 249, 97, 17, 132, 168, 87,\n        182, 85\n    ];\n    assert(result == expected);\n}\n\n#[test(should_fail)]\nfn test_base64_decode_with_padding_var() {\n    let input  = Vec::from_slice(\n        [\n        71, 120, 77, 108, 103,\n        119, 76, 105, 121, 112,\n        110, 86, 114, 69, 50,\n        67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87,\n        84, 107, 65, 104, 83,\n        90, 53, 43, 87, 69,\n        82, 104, 75, 104, 88,\n        116, 108, 85, 61\n    ]\n    );\n\n    let expected = Vec::from_slice(\n        [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172,\n        77, 130, 209, 39, 248, 203, 56, 92, 89, 57,\n        0, 133, 38, 121, 249, 97, 17, 132, 168, 87,\n        182, 85\n    ]\n    );\n\n    let result = base64_decode_var(input);\n\n    assert(expected.eq(result));\n}\n","path":"/home/cyprian/rustprograms/noir-examples/lib_examples/base64_example/noir_base64_lib/src/decode.nr"},"53":{"source":"use crate::extensions::PartialEq;\nstruct Base64EncodeBE {\n    table: [u8; 64]\n}\n\nimpl Base64EncodeBE {\n    /// Creates a new encoder that uses the standard Base64 Alphabet (base64) specified in RFC 4648 \n    /// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\n    fn new() -> Self {\n        Base64EncodeBE {\n            // The alphabet values here are standard UTF-8 (and ASCII) byte encodings, so the index\n            // in the table is the 6-bit Base64 value, and the value at that index is the UTF-8 \n            // encoding of that value.\n            table: [\n                65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,// 0-25 (A-Z)\n                97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,// 26-51 (a-z)\n                48, 49, 50, 51, 52, 53, 54, 55, 56, 57,// 0-9\n                43,// +\n                47// /\n            ]\n        }\n    }\n\n    fn get(self, idx: Field) -> u8 {\n        self.table[idx]\n    }\n}\n\nstruct Base64URLEncodeBE {\n    table: [u8; 64]\n}\n\nimpl Base64URLEncodeBE {\n    /// Creates a new encoder that uses the standard Base64 Alphabet (base64) specified in RFC 4648 \n    /// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\n    fn new() -> Self {\n        Base64URLEncodeBE {\n            // The alphabet values here are standard UTF-8 (and ASCII) byte encodings, so the index\n            // in the table is the 6-bit Base64 value, and the value at that index is the UTF-8 \n            // encoding of that value.\n            table: [\n                65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,// 0-25 (A-Z)\n                97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,// 26-51 (a-z)\n                48, 49, 50, 51, 52, 53, 54, 55, 56, 57,// 0-9\n                45,// -\n                95// _\n            ]\n        }\n    }\n\n    fn get(self, idx: Field) -> u8 {\n        self.table[idx]\n    }\n}\n\npub fn base64_encode_elements<let M: u32>(input: [u8; M]) -> [u8; M] {\n    let mut Base64Encoder = Base64EncodeBE::new();\n\n    let mut result: [u8; M] = [0; M];\n\n    for i in 0..M {\n        result[i] = Base64Encoder.get(input[i] as Field);\n    }\n    result\n}\n\npub fn base64_encode_elements_var(input: Vec<u8>) -> Vec<u8> {\n    let mut Base64Encoder = Base64EncodeBE::new();\n\n    let mut result = Vec::new();\n\n    for i in 0..input.len() {\n        let input_byte = input.get(i);\n        result.insert(i, Base64Encoder.get(input_byte as Field));\n    }\n    result\n}\n\npub fn base64_url_encode_elements<let M: u32>(input: [u8; M]) -> [u8; M] {\n    let mut Base64URLEncoder = Base64URLEncodeBE::new();\n\n    let mut result: [u8; M] = [0; M];\n\n    for i in 0..M {\n        result[i] = Base64URLEncoder.get(input[i] as Field);\n    }\n    result\n}\n\npub fn base64_url_encode_elements_var(input: Vec<u8>) -> Vec<u8> {\n    let mut Base64URLEncoder = Base64URLEncodeBE::new();\n\n    let mut result = Vec::new();\n\n    for i in 0..input.len() {\n        let input_byte = input.get(i);\n        result.insert(i, Base64URLEncoder.get(input_byte as Field));\n    }\n    result\n}\n\npub fn base64_encode<let M: u32, let N: u32>(input: [u8; M]) -> [u8; N] {\n    let mut result: [u8; N] = [0; N];\n    let BASE64_ELEMENTS_PER_CHUNK: u32 = 40;\n    let BYTES_PER_CHUNK: u32 = 30;\n    let num_chunks = (M / BYTES_PER_CHUNK) + (M % BYTES_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        for i in 0..num_chunks - 1 {\n            let mut slice: Field = 0;\n            for j in 0..BYTES_PER_CHUNK {\n                slice *= 256;\n                slice += input[i * BYTES_PER_CHUNK + j] as Field;\n            }\n\n            let slice_base64_chunks: [u8; 40] = slice.to_be_radix(64);\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                result[i * BASE64_ELEMENTS_PER_CHUNK + j] = slice_base64_chunks[j];\n            }\n        }\n\n        let bytes_in_final_chunk = M - ((num_chunks - 1) * BYTES_PER_CHUNK);\n\n        let mut slice: Field = 0;\n        for j in 0..bytes_in_final_chunk {\n            slice *= 256;\n            slice += input[(num_chunks - 1) * BYTES_PER_CHUNK + j] as Field;\n        }\n        for _ in bytes_in_final_chunk..BYTES_PER_CHUNK {\n            slice *= 256;\n        }\n\n        let slice_base64_chunks: [u8; 40] = slice.to_be_radix(64);\n\n        let num_elements_in_final_chunk = N - ((num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK);\n        for i in 0..num_elements_in_final_chunk {\n            result[(num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK + i] = slice_base64_chunks[i];\n        }\n        result = base64_encode_elements(result);\n    }\n\n    result\n}\n\npub fn base64_encode_var(input: Vec<u8>) -> Vec<u8> {\n    let mut result: Vec<u8> = Vec::new();\n    let M: u32 = input.len();\n    let N: u32 = (M * 4 + 2) / 3;\n    let BASE64_ELEMENTS_PER_CHUNK: u32 = 40;\n    let BYTES_PER_CHUNK: u32 = 30;\n    let num_chunks = (M / BYTES_PER_CHUNK) + (M % BYTES_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        for i in 0..num_chunks - 1 {\n            let mut slice: Field = 0;\n            for j in 0..BYTES_PER_CHUNK {\n                slice *= 256;\n                slice += input.get(i * BYTES_PER_CHUNK + j) as Field;\n            }\n\n            let slice_base64_chunks: [u8; 40] = slice.to_be_radix(64);\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                result.insert(i * BASE64_ELEMENTS_PER_CHUNK + j, slice_base64_chunks[j]);\n            }\n        }\n\n        let bytes_in_final_chunk = M - ((num_chunks - 1) * BYTES_PER_CHUNK);\n\n        let mut slice: Field = 0;\n        for j in 0..bytes_in_final_chunk {\n            slice *= 256;\n            slice += input.get((num_chunks - 1) * BYTES_PER_CHUNK + j) as Field;\n        }\n        for _ in bytes_in_final_chunk..BYTES_PER_CHUNK {\n            slice *= 256;\n        }\n\n        let slice_base64_chunks: [u8; 40] = slice.to_be_radix(64);\n\n        let num_elements_in_final_chunk = N - ((num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK);\n        for i in 0..num_elements_in_final_chunk {\n            result.insert(\n                (num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK + i,\n                slice_base64_chunks[i]\n            );\n        }\n        result = base64_encode_elements_var(result);\n    }\n\n    result\n}\n\npub fn base64_url_encode<let M: u32, let N: u32>(input: [u8; M]) -> [u8; N] {\n    let mut result: [u8; N] = [0; N];\n    let BASE64_ELEMENTS_PER_CHUNK: u32 = 40;\n    let BYTES_PER_CHUNK: u32 = 30;\n    let num_chunks = (M / BYTES_PER_CHUNK) + (M % BYTES_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        for i in 0..num_chunks - 1 {\n            let mut slice: Field = 0;\n            for j in 0..BYTES_PER_CHUNK {\n                slice *= 256;\n                slice += input[i * BYTES_PER_CHUNK + j] as Field;\n            }\n\n            let slice_base64_chunks: [u8; 40] = slice.to_be_radix(64);\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                result[i * BASE64_ELEMENTS_PER_CHUNK + j] = slice_base64_chunks[j];\n            }\n        }\n\n        let bytes_in_final_chunk = M - ((num_chunks - 1) * BYTES_PER_CHUNK);\n\n        let mut slice: Field = 0;\n        for j in 0..bytes_in_final_chunk {\n            slice *= 256;\n            slice += input[(num_chunks - 1) * BYTES_PER_CHUNK + j] as Field;\n        }\n        for _ in bytes_in_final_chunk..BYTES_PER_CHUNK {\n            slice *= 256;\n        }\n\n        let slice_base64_chunks: [u8; 40] = slice.to_be_radix(64);\n\n        let num_elements_in_final_chunk = N - ((num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK);\n        for i in 0..num_elements_in_final_chunk {\n            result[(num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK + i] = slice_base64_chunks[i];\n        }\n        result = base64_url_encode_elements(result);\n    }\n\n    result\n}\n\npub fn base64_url_encode_var(input: Vec<u8>) -> Vec<u8> {\n    let mut result: Vec<u8> = Vec::new();\n    let M: u32 = input.len();\n    let N: u32 = (M * 4 + 2) / 3;\n    let BASE64_ELEMENTS_PER_CHUNK: u32 = 40;\n    let BYTES_PER_CHUNK: u32 = 30;\n    let num_chunks = (M / BYTES_PER_CHUNK) + (M % BYTES_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        for i in 0..num_chunks - 1 {\n            let mut slice: Field = 0;\n            for j in 0..BYTES_PER_CHUNK {\n                slice *= 256;\n                slice += input.get(i * BYTES_PER_CHUNK + j) as Field;\n            }\n\n            let slice_base64_chunks: [u8; 40] = slice.to_be_radix(64);\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                result.insert(i * BASE64_ELEMENTS_PER_CHUNK + j, slice_base64_chunks[j]);\n            }\n        }\n\n        let bytes_in_final_chunk = M - ((num_chunks - 1) * BYTES_PER_CHUNK);\n\n        let mut slice: Field = 0;\n        for j in 0..bytes_in_final_chunk {\n            slice *= 256;\n            slice += input.get((num_chunks - 1) * BYTES_PER_CHUNK + j) as Field;\n        }\n        for _ in bytes_in_final_chunk..BYTES_PER_CHUNK {\n            slice *= 256;\n        }\n\n        let slice_base64_chunks: [u8; 40] = slice.to_be_radix(64);\n\n        let num_elements_in_final_chunk = N - ((num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK);\n        for i in 0..num_elements_in_final_chunk {\n            result.insert(\n                (num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK + i,\n                slice_base64_chunks[i]\n            );\n        }\n        result = base64_url_encode_elements_var(result);\n    }\n\n    result\n}\n\n#[test]\nfn test_base64_encode_elements() {\n    let ascii_expected: [u8; 43] = \"GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU\".as_bytes();\n\n    let input: [u8; 43] = [\n        6, 49, 12, 37, 32, 48, 11, 34, 50, 41, 39, 21, 43, 4, 54, 2, 52, 18, 31, 56, 50, 51, 33, 28, 22, 19, 36, 0, 33, 18, 25, 57, 62, 22, 4, 17, 33, 10, 33, 23, 45, 37, 20\n    ];\n\n    let ascii_result = base64_encode_elements(input);\n\n    assert(ascii_result == ascii_expected);\n}\n\n#[test]\nfn test_base64_encode_elements_var() {\n    let ascii_expected = \"GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU\".as_bytes_vec();\n\n    let data: [u8; 43] = [\n        6, 49, 12, 37, 32, 48, 11, 34, 50, 41, 39, 21, 43, 4, 54, 2, 52, 18, 31, 56, 50, 51, 33, 28, 22, 19, 36, 0, 33, 18, 25, 57, 62, 22, 4, 17, 33, 10, 33, 23, 45, 37, 20\n    ];\n\n    let input = Vec::from_slice(data);\n\n    let ascii_result = base64_encode_elements_var(input);\n\n    assert(ascii_result.eq(ascii_expected));\n}\n\n#[test]\nfn test_encode_empty() {\n    let input: [u8; 0] = [];\n    let result = base64_encode(input);\n    let expected: [u8; 0] = [];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_empty_var() {\n    let input = Vec::new();\n    let result = base64_encode_var(input);\n    let expected = Vec::new();\n\n    assert(result.eq(expected));\n}\n\n#[test]\nfn test_encode_max_byte() {\n    let input: [u8; 1] = [255];\n\n    let result: [u8; 2] = base64_encode(input);\n    let expected: [u8; 2] = [47, 119]; // \"/w\"\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_max_byte_var() {\n    let mut input = Vec::from_slice([255]);\n    let result = base64_encode_var(input);\n    let expected = Vec::from_slice([47, 119]); // \"/w\"\n\n    assert(result.eq(expected));\n}\n\n#[test]\nfn test_encode_ascii() {\n    let input: [u8; 12] = \"Hello World!\".as_bytes();\n    let expected: [u8; 16] = \"SGVsbG8gV29ybGQh\".as_bytes();\n\n    let result = base64_encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_ascii_var() {\n    let input = \"Hello World!\".as_bytes_vec();\n    let expected = \"SGVsbG8gV29ybGQh\".as_bytes_vec();\n\n    let result = base64_encode_var(input);\n    assert(result.eq(expected));\n}\n\n#[test]\nfn test_encode_utf8() {\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let input: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129, 228, 184, 150, 231, 149, 140, 239, 188, 129\n    ];\n    let expected: [u8; 36] = \"44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\".as_bytes();\n\n    let result = base64_encode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_utf8_var() {\n    let input = Vec::from_slice(\n        [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129, 228, 184, 150, 231, 149, 140, 239, 188, 129\n    ]\n    );\n\n    let expected = \"44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\".as_bytes_vec();\n\n    let result = base64_encode_var(input);\n    assert(result.eq(expected));\n}\n\n#[test]\nfn test_encode_multi_chunks() {\n    let input_str = \"The quick brown fox jumps over the lazy dog, while 42 ravens perch atop a rusty mailbox. Zany quilters fabricate 9 cozy blankets, as 3 jovial wizards expertly mix 5 potent elixirs. Bright neon signs flash \\\"OPEN 24/7\\\" in the misty night air, illuminating 8 vintage cars parked along Main Street. A gentle breeze carries the aroma of fresh coffee and warm cinnamon rolls from Joe's Diner, enticing 6 sleepy truckers to stop for a late-night snack. Meanwhile, 11 mischievous kittens playfully chase a ball of yarn across Mrs. Johnson's porch, their antics observed by 2 wise old owls perched on a nearby oak tree.\".as_bytes();\n\n    let result:[u8; 814] = base64_encode(input_str);\n    let expected:[u8; 814] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73, 71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73, 72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 119, 103, 100, 50, 104, 112, 98, 71, 85, 103, 78, 68, 73, 103, 99, 109, 70, 50, 90, 87, 53, 122, 73, 72, 66, 108, 99, 109, 78, 111, 73, 71, 70, 48, 98, 51, 65, 103, 89, 83, 66, 121, 100, 88, 78, 48, 101, 83, 66, 116, 89, 87, 108, 115, 89, 109, 57, 52, 76, 105, 66, 97, 89, 87, 53, 53, 73, 72, 70, 49, 97, 87, 120, 48, 90, 88, 74, 122, 73, 71, 90, 104, 89, 110, 74, 112, 89, 50, 70, 48, 90, 83, 65, 53, 73, 71, 78, 118, 101, 110, 107, 103, 89, 109, 120, 104, 98, 109, 116, 108, 100, 72, 77, 115, 73, 71, 70, 122, 73, 68, 77, 103, 97, 109, 57, 50, 97, 87, 70, 115, 73, 72, 100, 112, 101, 109, 70, 121, 90, 72, 77, 103, 90, 88, 104, 119, 90, 88, 74, 48, 98, 72, 107, 103, 98, 87, 108, 52, 73, 68, 85, 103, 99, 71, 57, 48, 90, 87, 53, 48, 73, 71, 86, 115, 97, 88, 104, 112, 99, 110, 77, 117, 73, 69, 74, 121, 97, 87, 100, 111, 100, 67, 66, 117, 90, 87, 57, 117, 73, 72, 78, 112, 90, 50, 53, 122, 73, 71, 90, 115, 89, 88, 78, 111, 73, 67, 74, 80, 85, 69, 86, 79, 73, 68, 73, 48, 76, 122, 99, 105, 73, 71, 108, 117, 73, 72, 82, 111, 90, 83, 66, 116, 97, 88, 78, 48, 101, 83, 66, 117, 97, 87, 100, 111, 100, 67, 66, 104, 97, 88, 73, 115, 73, 71, 108, 115, 98, 72, 86, 116, 97, 87, 53, 104, 100, 71, 108, 117, 90, 121, 65, 52, 73, 72, 90, 112, 98, 110, 82, 104, 90, 50, 85, 103, 89, 50, 70, 121, 99, 121, 66, 119, 89, 88, 74, 114, 90, 87, 81, 103, 89, 87, 120, 118, 98, 109, 99, 103, 84, 87, 70, 112, 98, 105, 66, 84, 100, 72, 74, 108, 90, 88, 81, 117, 73, 69, 69, 103, 90, 50, 86, 117, 100, 71, 120, 108, 73, 71, 74, 121, 90, 87, 86, 54, 90, 83, 66, 106, 89, 88, 74, 121, 97, 87, 86, 122, 73, 72, 82, 111, 90, 83, 66, 104, 99, 109, 57, 116, 89, 83, 66, 118, 90, 105, 66, 109, 99, 109, 86, 122, 97, 67, 66, 106, 98, 50, 90, 109, 90, 87, 85, 103, 89, 87, 53, 107, 73, 72, 100, 104, 99, 109, 48, 103, 89, 50, 108, 117, 98, 109, 70, 116, 98, 50, 52, 103, 99, 109, 57, 115, 98, 72, 77, 103, 90, 110, 74, 118, 98, 83, 66, 75, 98, 50, 85, 110, 99, 121, 66, 69, 97, 87, 53, 108, 99, 105, 119, 103, 90, 87, 53, 48, 97, 87, 78, 112, 98, 109, 99, 103, 78, 105, 66, 122, 98, 71, 86, 108, 99, 72, 107, 103, 100, 72, 74, 49, 89, 50, 116, 108, 99, 110, 77, 103, 100, 71, 56, 103, 99, 51, 82, 118, 99, 67, 66, 109, 98, 51, 73, 103, 89, 83, 66, 115, 89, 88, 82, 108, 76, 87, 53, 112, 90, 50, 104, 48, 73, 72, 78, 117, 89, 87, 78, 114, 76, 105, 66, 78, 90, 87, 70, 117, 100, 50, 104, 112, 98, 71, 85, 115, 73, 68, 69, 120, 73, 71, 49, 112, 99, 50, 78, 111, 97, 87, 86, 50, 98, 51, 86, 122, 73, 71, 116, 112, 100, 72, 82, 108, 98, 110, 77, 103, 99, 71, 120, 104, 101, 87, 90, 49, 98, 71, 120, 53, 73, 71, 78, 111, 89, 88, 78, 108, 73, 71, 69, 103, 89, 109, 70, 115, 98, 67, 66, 118, 90, 105, 66, 53, 89, 88, 74, 117, 73, 71, 70, 106, 99, 109, 57, 122, 99, 121, 66, 78, 99, 110, 77, 117, 73, 69, 112, 118, 97, 71, 53, 122, 98, 50, 52, 110, 99, 121, 66, 119, 98, 51, 74, 106, 97, 67, 119, 103, 100, 71, 104, 108, 97, 88, 73, 103, 89, 87, 53, 48, 97, 87, 78, 122, 73, 71, 57, 105, 99, 50, 86, 121, 100, 109, 86, 107, 73, 71, 74, 53, 73, 68, 73, 103, 100, 50, 108, 122, 90, 83, 66, 118, 98, 71, 81, 103, 98, 51, 100, 115, 99, 121, 66, 119, 90, 88, 74, 106, 97, 71, 86, 107, 73, 71, 57, 117, 73, 71, 69, 103, 98, 109, 86, 104, 99, 109, 74, 53, 73, 71, 57, 104, 97, 121, 66, 48, 99, 109, 86, 108, 76, 103\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_multi_chunks_var() {\n    let input_str = \"The quick brown fox jumps over the lazy dog, while 42 ravens perch atop a rusty mailbox. Zany quilters fabricate 9 cozy blankets, as 3 jovial wizards expertly mix 5 potent elixirs. Bright neon signs flash \\\"OPEN 24/7\\\" in the misty night air, illuminating 8 vintage cars parked along Main Street. A gentle breeze carries the aroma of fresh coffee and warm cinnamon rolls from Joe's Diner, enticing 6 sleepy truckers to stop for a late-night snack. Meanwhile, 11 mischievous kittens playfully chase a ball of yarn across Mrs. Johnson's porch, their antics observed by 2 wise old owls perched on a nearby oak tree.\".as_bytes_vec();\n\n    let result  = base64_encode_var(input_str);\n    let expected = Vec::from_slice(\n        [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73, 71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73, 72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 119, 103, 100, 50, 104, 112, 98, 71, 85, 103, 78, 68, 73, 103, 99, 109, 70, 50, 90, 87, 53, 122, 73, 72, 66, 108, 99, 109, 78, 111, 73, 71, 70, 48, 98, 51, 65, 103, 89, 83, 66, 121, 100, 88, 78, 48, 101, 83, 66, 116, 89, 87, 108, 115, 89, 109, 57, 52, 76, 105, 66, 97, 89, 87, 53, 53, 73, 72, 70, 49, 97, 87, 120, 48, 90, 88, 74, 122, 73, 71, 90, 104, 89, 110, 74, 112, 89, 50, 70, 48, 90, 83, 65, 53, 73, 71, 78, 118, 101, 110, 107, 103, 89, 109, 120, 104, 98, 109, 116, 108, 100, 72, 77, 115, 73, 71, 70, 122, 73, 68, 77, 103, 97, 109, 57, 50, 97, 87, 70, 115, 73, 72, 100, 112, 101, 109, 70, 121, 90, 72, 77, 103, 90, 88, 104, 119, 90, 88, 74, 48, 98, 72, 107, 103, 98, 87, 108, 52, 73, 68, 85, 103, 99, 71, 57, 48, 90, 87, 53, 48, 73, 71, 86, 115, 97, 88, 104, 112, 99, 110, 77, 117, 73, 69, 74, 121, 97, 87, 100, 111, 100, 67, 66, 117, 90, 87, 57, 117, 73, 72, 78, 112, 90, 50, 53, 122, 73, 71, 90, 115, 89, 88, 78, 111, 73, 67, 74, 80, 85, 69, 86, 79, 73, 68, 73, 48, 76, 122, 99, 105, 73, 71, 108, 117, 73, 72, 82, 111, 90, 83, 66, 116, 97, 88, 78, 48, 101, 83, 66, 117, 97, 87, 100, 111, 100, 67, 66, 104, 97, 88, 73, 115, 73, 71, 108, 115, 98, 72, 86, 116, 97, 87, 53, 104, 100, 71, 108, 117, 90, 121, 65, 52, 73, 72, 90, 112, 98, 110, 82, 104, 90, 50, 85, 103, 89, 50, 70, 121, 99, 121, 66, 119, 89, 88, 74, 114, 90, 87, 81, 103, 89, 87, 120, 118, 98, 109, 99, 103, 84, 87, 70, 112, 98, 105, 66, 84, 100, 72, 74, 108, 90, 88, 81, 117, 73, 69, 69, 103, 90, 50, 86, 117, 100, 71, 120, 108, 73, 71, 74, 121, 90, 87, 86, 54, 90, 83, 66, 106, 89, 88, 74, 121, 97, 87, 86, 122, 73, 72, 82, 111, 90, 83, 66, 104, 99, 109, 57, 116, 89, 83, 66, 118, 90, 105, 66, 109, 99, 109, 86, 122, 97, 67, 66, 106, 98, 50, 90, 109, 90, 87, 85, 103, 89, 87, 53, 107, 73, 72, 100, 104, 99, 109, 48, 103, 89, 50, 108, 117, 98, 109, 70, 116, 98, 50, 52, 103, 99, 109, 57, 115, 98, 72, 77, 103, 90, 110, 74, 118, 98, 83, 66, 75, 98, 50, 85, 110, 99, 121, 66, 69, 97, 87, 53, 108, 99, 105, 119, 103, 90, 87, 53, 48, 97, 87, 78, 112, 98, 109, 99, 103, 78, 105, 66, 122, 98, 71, 86, 108, 99, 72, 107, 103, 100, 72, 74, 49, 89, 50, 116, 108, 99, 110, 77, 103, 100, 71, 56, 103, 99, 51, 82, 118, 99, 67, 66, 109, 98, 51, 73, 103, 89, 83, 66, 115, 89, 88, 82, 108, 76, 87, 53, 112, 90, 50, 104, 48, 73, 72, 78, 117, 89, 87, 78, 114, 76, 105, 66, 78, 90, 87, 70, 117, 100, 50, 104, 112, 98, 71, 85, 115, 73, 68, 69, 120, 73, 71, 49, 112, 99, 50, 78, 111, 97, 87, 86, 50, 98, 51, 86, 122, 73, 71, 116, 112, 100, 72, 82, 108, 98, 110, 77, 103, 99, 71, 120, 104, 101, 87, 90, 49, 98, 71, 120, 53, 73, 71, 78, 111, 89, 88, 78, 108, 73, 71, 69, 103, 89, 109, 70, 115, 98, 67, 66, 118, 90, 105, 66, 53, 89, 88, 74, 117, 73, 71, 70, 106, 99, 109, 57, 122, 99, 121, 66, 78, 99, 110, 77, 117, 73, 69, 112, 118, 97, 71, 53, 122, 98, 50, 52, 110, 99, 121, 66, 119, 98, 51, 74, 106, 97, 67, 119, 103, 100, 71, 104, 108, 97, 88, 73, 103, 89, 87, 53, 48, 97, 87, 78, 122, 73, 71, 57, 105, 99, 50, 86, 121, 100, 109, 86, 107, 73, 71, 74, 53, 73, 68, 73, 103, 100, 50, 108, 122, 90, 83, 66, 118, 98, 71, 81, 103, 98, 51, 100, 115, 99, 121, 66, 119, 90, 88, 74, 106, 97, 71, 86, 107, 73, 71, 57, 117, 73, 71, 69, 103, 98, 109, 86, 104, 99, 109, 74, 53, 73, 71, 57, 104, 97, 121, 66, 48, 99, 109, 86, 108, 76, 103\n    ]\n    );\n\n    assert(result.eq(expected));\n}\n\n#[test]\nfn test_base64_encode_slash() {\n    let input: [u8; 1] = [63]; // '/' in Base64\n    let result: [u8; 1] = base64_encode_elements(input);\n\n    // Should map to '/' in ASCII, which is 47\n    assert(result[0] == 47);\n}\n\n#[test]\nfn test_base64_encode_slash_var() {\n    let input: Vec<u8> = Vec::from_slice([63]); // '/' in Base64\n    let result = base64_encode_elements_var(input);\n\n    // Should map to '/' in ASCII, which is 47\n    assert(result.get(0) == 47);\n}\n","path":"/home/cyprian/rustprograms/noir-examples/lib_examples/base64_example/noir_base64_lib/src/encode.nr"}},"names":["main"],"brillig_names":["directive_to_radix","directive_integer_quotient","directive_invert"]}